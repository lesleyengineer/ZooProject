/*
 * Author: Daniel Silva
 * https://wiki.nge.wdig.com/display/NGE/Syndication-jQuery-Uplift-Fix
*/
(function() {
    if (!jQuery.isFunction(jQuery.fn.on)) {
        jQuery.fn.extend({
            on: function(types, data, fn) {
                jQuery(this.selector).live(types, data, fn);
                return this;
            },
            off: function(types, fn) {
                jQuery(this.selector).die(types, fn);
                return this;
            }
        });
    }
}());

// Simply sets up the global PEP namespace.
if (typeof PEP === 'undefined') {
    window.PEP = {};
}

/**
 * PEP.namespace returns a reference to the namespace object described
 * by the first argument, creating it if it doesn't exist
 * 
 * @param namespace string - dot separated namespace hierarchy
 * @param base object (optional) - object inside of which to create
 * the namespace - defaults to PEP
 * 
 * Usage:
 * get reference to window.PEP.Mapplication.Constants:
 * var C = PEP.namespace('Mapplication.Constants');
 * 
 * make namespace available within local function scope
 * (function ($, FU) {
 *     FU.loadFacets = function...
 * })(jQuery, PEP.namespace('Finder.Utils'));
 * 
 * get a reference to a namespace outside of window.PEP
 * var A = PEP.namespace('WDPRO.Analytics', window);
 */
PEP.namespace = function (namespace, base) {
    base = base || PEP;

    var tokens = namespace.split('.'),
        i = 0,
        name;

    while ((name = tokens[i++])) {
        base[name] = base[name] || {};
        base = base[name];
    }

    return base;
};
(function ($, util) {

    /**
     * Polyfills
     */
    // polyfill for missing "startsWith", needed for IE11 support
    if (typeof String.prototype.startsWith !== 'function') {
        String.prototype.startsWith = function (prefix) {
            return this.slice(0, prefix.length) === prefix;
        };
    }

    /**
     * Function: traverseToOption
     * Helper function for getOption
     */
    function traverseToOption(options, keyPath, defaultValue) {
        var keyToCheck = keyPath.pop();

        if (options !== null && typeof options === 'object' && typeof options[keyToCheck] !== 'undefined') {
            if (keyPath.length === 0) {
                return options[keyToCheck];
            } else if (typeof options[keyToCheck] === 'object') {
                return traverseToOption(options[keyToCheck], keyPath, defaultValue);
            }
        }
        return defaultValue;
    }

    /**
     * Function: getOption
     * Gets an value from a hash and checks first if the key exists and substitutes a default value
     * if it does not exist.
     *
     * Parameters:
     *     options      - Object containing options
     *     key          - The key of the value to retrieve. Can use dot (.) to specify a traversal path through a
     *         multi-level object. i.e. 'level1.level2.value1' would return 5 given the following options object:
     *         options = {
     *             level1: {
     *                 level2:
     *                     value1: 5,
     *                     value2: 6
     *                 }
     *             }
     *         };
     *     defaultValue - The default value to use if key doesn't exist
     *
     * Returns:
     *     The value for the corresponding key could be any type
     */
    util.getOption = function (options, key, defaultValue) {
        var keyPath = key.split('.');
        keyPath.reverse();
        return traverseToOption(options, keyPath, defaultValue);
    };

    /**
     * Function: objectify
     * Creates an object whose keys are the odd arguments and values are the even arguments. This is useful when
     * creating objects whose keys must be the value of other variables. (It can be done inline rather than in a
     * separate statement using bracket notation.
     *
     * Parameters:
     * zero or more values or objects
     *
     * Examples:
     * objectify('a', 'b'); // returns {a: 'b'}
     * objectify('a', 'b', 'c') // returns {a: 'b', c: undefined}
     *
     * Returns:
     * An object whose keys are the odd arguments and values are the even arguments
     */
    util.objectify = function (/* variable arity */) {
        var o = {},
           i = 0,
           len = arguments.length;

        while (i < len) {
           o[arguments[i++]] = arguments[i++];
        }
        return o;
    };

    /**
     * Builds a URL query string from a hash of parameters
     *
     *
     * Example:
     *
     * var params = {
     *     key1: 'value1',
     *     key2: 'value2',
     *     key3: ['value4', 'value5']
     * };
     *
     * PEP.util.createQueryString(params);
     * "?key1=value1&key2=value2&key3[0]=value4&key3[1]=value5"
     *
     * PEP.util.createQueryString(params, false, false);
     * "key1=value1&key2=value2&key3=value4&key3=value5"
     *
     *
     * @param params Object with key-value pair of URL parameters
     * @param addLeadingQuestionMark <optional> true by default
     * @param addSquareBrackets <optional> true by default
     * @return {String} A string containing the query string
     */
    util.createQueryString = function(params, addLeadingQuestionMark, addSquareBrackets) {
        var queryString = '';

        // If optional parameters are not defined, set their default value
        addLeadingQuestionMark = typeof addLeadingQuestionMark === 'undefined' ? true : addLeadingQuestionMark;
        addSquareBrackets = typeof addSquareBrackets === 'undefined' ? true : addSquareBrackets;

        $.each(params, function(key, value) {
            if (typeof value === 'object' && value !== null) {
                $.each(value, function(paramKey, paramValue) {
                    if (queryString.length > 0) {
                        queryString += '&';
                    }
                    queryString += encodeURIComponent(key);
                    if (addSquareBrackets) {
                        queryString += '[' + encodeURIComponent(paramKey) + ']';
                    }
                    queryString += '=' + encodeURIComponent(paramValue);
                });
            } else if (value) {
                if (queryString.length > 0) {
                    queryString += '&';
                }
                queryString += encodeURIComponent(key) + '=' + encodeURIComponent(value);
            }
        });
        if (addLeadingQuestionMark && queryString.length > 0) {
            queryString = '?' + queryString;
        }
        return queryString;
    };

    /**
     * Inserts URL parameters into the url string provided. Params that are not
     * found as replacements within the URL string are added to the query
     * parameter(s).
     *
     * @param url string
     * @param options object of key-value pairs
     */
    util.insertUrlParams = function (url, params) {
        var queryParams = {},
            addQuestionMark = false,
            queryParamCount = 0;

        // Insert URL replacements
        $.each(params, function (key, value) {
            switch ($.type(value)) {
                case 'string':
                    //fall-through
                case 'number':
                    //fall-through
                case 'boolean':
                    if (url.indexOf('{' + key + '}') > -1) {
                        url = url.replace('{' + key + '}', value);
                    } else {
                        queryParams[key] = value;
                        queryParamCount++;
                    }
                    break;
                default:
                    return true; //continue
            }
        });

        // Add Query params
        if (queryParamCount > 0) {
            if (url.indexOf('?') === -1) {
                addQuestionMark = true;
            } else {
                url = url + "&";
            }
            url = url + util.createQueryString(queryParams, addQuestionMark);
        }

        return url;
    };

    /**
     * Function: decodeHtml
     * Decodes string HTML
     *
     * Parameters:
     *     strHTML - string HTML
     *
     * Returns:
     *     The decoded html
     */
    util.decodeHtml = function(strHTML) {
        var tempTextArea = document.createElement("textarea");
        tempTextArea.innerHTML = strHTML.replace(/</g,"<").replace(/>/g,">");
        var decodedString = tempTextArea.value;
        return decodedString;
    };

    /**
     * Used to simplify the base 64 encoding and decoding.
     */
    util.base64String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /**
     * Function: base64Encode
     * Encodes the given string into a base64 string.
     *
     * Parameters:
     *     str - string to encode
     *
     * Returns:
     *     The base64 encoded string
     */
    util.base64Encode = (function() {
        if ($.isFunction(window.btoa)) {

            // Native base64 encode
            return function(str) {
                return window.btoa(str);
            };

        } else {

            // For other browsers
            return function(str) {
                var base64 = "";
                var i = 0, len = str.length;
                for (; i < len; i += 3) {
                    var c1 = str.charAt(i).charCodeAt();
                    var c2 = (i + 1 < len ? str.charAt(i + 1).charCodeAt() : null);
                    var c3 = (i + 2 < len ? str.charAt(i + 2).charCodeAt() : null);

                    var b1 = (c1 & 0xFC) >> 2;
                    var b2 = ((c1 & 0x03) << 4) + (c2 === null ? 0 : (c2 & 0xF0) >> 4);
                    var b3 = (c2 === null ? 0 : ((c2 & 0x0F) << 2)) +
                             (c3 === null ? 0 : ((c3 & 0xC0) >> 6));
                    var b4 = (c3 === null ? 0 : (c3 & 0x3F));

                    base64 += util.base64String.charAt(b1) +
                        util.base64String.charAt(b2) +
                        (c2 === null ? "=" : util.base64String.charAt(b3)) +
                        (c3 === null ? "=" : util.base64String.charAt(b4));
                }

                return base64;
            };

        }
    })();

    /**
     * Function: base64Decode
     * Decodes the given base64 string back to a plain string.
     *
     * Parameters:
     *     base64 - string to decode
     *
     * Returns:
     *     The string represented by the base64 encoding
     */
    util.base64Decode = (function() {
        if ($.isFunction(window.atob)) {

            // Native base64 decode
            return function(base64) {
                return window.atob($.trim(base64));
            };

        } else {

            // For other browsers
            return function(base64) {
                base64 = $.trim(base64);

                var str = "";
                var i = 0, len = base64.length;

                for (; i < len; i += 4) {
                    var b1 = util.base64String.indexOf(base64.charAt(i));
                    var b2 = util.base64String.indexOf(base64.charAt(i + 1));
                    var b3 = base64.charAt(i + 2);
                    var b4 = base64.charAt(i + 3);

                    b3 = (b3 === "=" ? b3 : util.base64String.indexOf(b3));
                    b4 = (b4 === "=" ? b4 : util.base64String.indexOf(b4));

                    var c1 = (b1 << 2) + ((b2 & 0x30) >> 4);
                    var c2 = (b3 === "=" ? null :
                            ((b2 & 0x0F) << 4) + ((b3 & 0x3C) >> 2));
                    var c3 = (b4 === "=" ? null :
                            ((b3 & 0x03) << 6) + b4);

                    str += String.fromCharCode(c1) +
                        (c2 === null ? "" : String.fromCharCode(c2)) +
                        (c3 === null ? "" : String.fromCharCode(c3));
                }

                return str;
            };

        }
    })();

    /**
     * Retrieves all query params from the current url and returns them in the form of an array (or null if no
     * params are found).
     * @param string href The href in context for locating query params
     * @return array | null
     */
    util.getQueryParams = function (href) {
        var argStartIndex = href.lastIndexOf('?');
        if (argStartIndex >= 0) {
            var params = href.substr(argStartIndex + 1, href.length - argStartIndex + 1);
            var paramArray = params.split('&');
            var paramAssociativeArray = {};

            var length = paramArray.length;
            for (var i = 0; i < length; i++) {
                var currentItem = paramArray[i].split('=');
                if (typeof paramAssociativeArray[currentItem[0]] !== 'undefined') {
                    if (typeof paramAssociativeArray[currentItem[0]] !== 'object') {
                        paramAssociativeArray[currentItem[0]] = [paramAssociativeArray[currentItem[0]]];
                    }
                    paramAssociativeArray[currentItem[0]].push(currentItem[1]);
                } else {
                    paramAssociativeArray[currentItem[0]] = currentItem[1];
                }
            }
            return paramAssociativeArray;
        }

        return null;
    };

    /***
     * Removes the host name from the url returning the path only
     * (including params, if any)
     *
     * For example:
     * http://test.com/facility-service/restaurants/90002245?name=test#foo
     *  will return
     * /facility-service/restaurants/90002245?name=test#foo (with leading slash)
     *
     * @param string url
     * @return string path
     */
    util.removeHostFromUrl = function (url) {
        return url.replace(/^http[^\/]*\/\/[^\/]+/i, '');
    };

    /***
     * Determine whether a given String is Absolute.
     * NOTE: This is a naive method and does not take
     * into account url formatting. A URL is considered absolute
     * if it contains "://"
     *
     * For example:
     * PEP.util.isAbsoluteUrl('http://foobar'); # true
     * PEP.util.isAbsoluteUrl('foobar.com'); # false
     * @param string url
     * @return boolean
     */
    util.isAbsoluteUrl = function (url) {
        var hasHost = url.indexOf('://');
        return (hasHost !== -1);
    };

    /***
     * Remove the beginning slash from a string (if needed)
     *
     * For example:
     * PEP.util.removeBeginningSlash('/foo/bar'); # foo/bar
     * PEP.util.removeBeginningSlash('foobar/'); # foobar/
     * @param string url
     * @return string
     */
    util.stripBeginningSlash = function (url) {
        var normalized = url;
        if (normalized && normalized[0] === '/') {
            normalized = normalized.substr(1);
        }
        return normalized;
    };

    /***
     * Remove the query string from a URL (if needed)
     * NOTE: This is a naive method and does not take
     * into account url formatting. A query-string is considered a string
     * that can be split into 2 or more parts by a "?"
     *
     * For example:
     * PEP.util.removeBeginningSlash('/foo/bar?foo=2&bar=5'); # foo/bar
     * PEP.util.removeBeginningSlash('foobar?foo'); # foobar
     * PEP.util.removeBeginningSlash('?foo'); # ?foo
     * @param string url
     * @return string
     */
    util.stripQueryString = function (url) {
        var urlParts = url.split('?');
        return (urlParts.length >=2) ? urlParts[0] : url;
    };

    /***
     * Normalize a URL based on a set of formatting options
     * NOTE: If no options are passed, or options are not explicitly
     * set to {{true}}, the URL will not be modified. This ensures that
     * any consumers must be explicit about how they want the URL formatted.
     *
     * For example:
     * PEP.util.normalizeUrl('/foo/bar?foo=2&bar=5', {stripQuery: true}); # /foo/bar
     * PEP.util.normalizeUrl('/foo/bar?foo=2&bar=5', {stripBeginningSlash: true}); # foo/bar?foo=2&bar=5
     * PEP.util.normalizeUrl('http://host.com:80/foo/bar', {stripHost: true}); # /foo/bar
     *
     * @param string url
     * @param object options (optional) in format:
     * <code>
     *  {
     *    stripHost : boolean, // defaults to false
     *    stripBeginningSlash : boolean, // defaults to false
     *    stripQuery : boolean //defaults to false
     *  }
     * </code>
     * @return string
     */
    util.normalizeUrl = function (url, options) {
        var defaults = {stripHost: false, stripBeginningSlash: false, stripQuery: false};
        options = options ? options : {};
        var settings = $.extend(true, defaults, options);
        var normalUrl = url;
        normalUrl = (settings.stripHost === true) ? PEP.util.removeHostFromUrl(normalUrl) : normalUrl;
        normalUrl = (settings.stripBeginningSlash === true) ? PEP.util.stripBeginningSlash(normalUrl) : normalUrl;
        normalUrl = (settings.stripQuery === true) ? PEP.util.stripQueryString(normalUrl) : normalUrl;
        return normalUrl;
    };

    /***
     * Guarantee the string Ends in a trailing slash (if needed)
     *
     * For example:
     * PEP.util.endWithTrailingSlash('/foo/bar'); # /foo/bar/
     * PEP.util.endWithTrailingSlash('foobar/'); # foobar/
     * @param string url
     * @return string
     */
    util.endWithTrailingSlash = function (str) {
        if(str.substr(-1) !== '/') {
            str = str + '/';
        }
        return str;
    };

    /**
     * Add a stylesheet link to the head
     */
    util.addStylesheetLink = function (url) {
        if (url) {
            if (document.createStyleSheet) {
                document.createStyleSheet(url);
            } else {
                $('head').append('<link rel="stylesheet" type="text/css" href="' + url + '" async defer>');
            }
        }
    };

    /**
     * Font tracking per license agreement - Don't remove without consulting legal
     */
    $(document).bind('PEP_LOADED', function (e) {
        var loadFontTrackingCss = function () {
            if (PEP.Config) {
                PEP.util.addStylesheetLink(PEP.Config.fontTrackingUrl);
            }
        };
        setTimeout(loadFontTrackingCss, 500);
    });

}(jQuery, PEP.namespace('util')));

/*
  mustache.js — Logic-less templates in JavaScript

  See http://mustache.github.com/ for more info.
*/
var Mustache = function() {
  var Renderer = function() {};

  Renderer.prototype = {
    otag: "{{",
    ctag: "}}",
    pragmas: {},
    buffer: [],
    pragmas_implemented: {
      "IMPLICIT-ITERATOR": true
    },
    context: {},

    render: function(template, context, partials, in_recursion) {
      // reset buffer & set context
      if(!in_recursion) {
        this.context = context;
        this.buffer = []; // TODO: make this non-lazy
      }

      // fail fast
      if(!this.includes("", template)) {
        if(in_recursion) {
          return template;
        } else {
          this.send(template);
          return;
        }
      }

      template = this.render_pragmas(template);
      var html = this.render_section(template, context, partials);
      if(in_recursion) {
        return this.render_tags(html, context, partials, in_recursion);
      }

      this.render_tags(html, context, partials, in_recursion);
    },

    /*
      Sends parsed lines
    */
    send: function(line) {
      if(line != "") {
        this.buffer.push(line);
      }
    },

    /*
      Looks for %PRAGMAS
    */
    render_pragmas: function(template) {
      // no pragmas
      if(!this.includes("%", template)) {
        return template;
      }

      var that = this;
      var regex = new RegExp(this.otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" +
            this.ctag);
      return template.replace(regex, function(match, pragma, options) {
        if(!that.pragmas_implemented[pragma]) {
          throw({message:
            "This implementation of mustache doesn't understand the '" +
            pragma + "' pragma"});
        }
        that.pragmas[pragma] = {};
        if(options) {
          var opts = options.split("=");
          that.pragmas[pragma][opts[0]] = opts[1];
        }
        return "";
        // ignore unknown pragmas silently
      });
    },

    /*
      Tries to find a partial in the curent scope and render it
    */
    render_partial: function(name, context, partials) {
      name = this.trim(name);
      if(!partials || partials[name] === undefined) {
        throw({message: "unknown_partial '" + name + "'"});
      }
      if(typeof(context[name]) != "object") {
        return this.render(partials[name], context, partials, true);
      }
      return this.render(partials[name], context[name], partials, true);
    },

    /*
      Renders inverted (^) and normal (#) sections
    */
    render_section: function(template, context, partials) {
      if(!this.includes("#", template) && !this.includes("^", template)) {
        return template;
      }

      var that = this;
      // CSW - Added "+?" so it finds the tighest bound, not the widest
      var regex = new RegExp(this.otag + "(\\^|\\#)\\s*(.+)\\s*" + this.ctag +
              "\n*([\\s\\S]+?)" + this.otag + "\\/\\s*\\2\\s*" + this.ctag +
              "\\s*", "mg");

      // for each {{#foo}}{{/foo}} section do...
      return template.replace(regex, function(match, type, name, content) {
        var value = that.find(name, context);
        if(type == "^") { // inverted section
          if(!value || that.is_array(value) && value.length === 0) {
            // false or empty list, render it
            return that.render(content, context, partials, true);
          } else {
            return "";
          }
        } else if(type == "#") { // normal section
          if(that.is_array(value)) { // Enumerable, Let's loop!
            return that.map(value, function(row) {
              return that.render(content, that.create_context(row),
                partials, true);
            }).join("");
          } else if(that.is_object(value)) { // Object, Use it as subcontext!
            return that.render(content, that.create_context(value),
              partials, true);
          } else if(typeof value === "function") {
            // higher order section
            return value.call(context, content, function(text) {
              return that.render(text, context, partials, true);
            });
          } else if(value) { // boolean section
            return that.render(content, context, partials, true);
          } else {
            return "";
          }
        }
      });
    },

    /*
      Replace {{foo}} and friends with values from our view
    */
    render_tags: function(template, context, partials, in_recursion) {
      // tit for tat
      var that = this;

      var new_regex = function() {
        return new RegExp(that.otag + "(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?" +
          that.ctag + "+", "g");
      };

      var regex = new_regex();
      var tag_replace_callback = function(match, operator, name) {
        switch(operator) {
        case "!": // ignore comments
          return "";
        case "=": // set new delimiters, rebuild the replace regexp
          that.set_delimiters(name);
          regex = new_regex();
          return "";
        case ">": // render partial
          return that.render_partial(name, context, partials);
        case "{": // the triple mustache is unescaped
          return that.find(name, context);
        default: // escape the value
          return that.escape(that.find(name, context));
        }
      };
      var lines = template.split("\n");
      for(var i = 0; i < lines.length; i++) {
        lines[i] = lines[i].replace(regex, tag_replace_callback, this);
        if(!in_recursion) {
          this.send(lines[i]);
        }
      }

      if(in_recursion) {
        return lines.join("\n");
      }
    },

    set_delimiters: function(delimiters) {
      var dels = delimiters.split(" ");
      this.otag = this.escape_regex(dels[0]);
      this.ctag = this.escape_regex(dels[1]);
    },

    escape_regex: function(text) {
      // thank you Simon Willison
      if(!arguments.callee.sRE) {
        var specials = [
          '/', '.', '*', '+', '?', '|',
          '(', ')', '[', ']', '{', '}', '\\'
        ];
        arguments.callee.sRE = new RegExp(
          '(\\' + specials.join('|\\') + ')', 'g'
        );
      }
      return text.replace(arguments.callee.sRE, '\\$1');
    },

    /*
      find `name` in current `context`. That is find me a value
      from the view object
    */
    find: function(name, context) {
      name = this.trim(name);

      // Checks whether a value is thruthy or false or 0
      function is_kinda_truthy(bool) {
        return bool === false || bool === 0 || bool;
      }

      var value;
      if(is_kinda_truthy(context[name])) {
        value = context[name];
      } else if(is_kinda_truthy(this.context[name])) {
        value = this.context[name];
      }

      if(typeof value === "function") {
        return value.apply(context);
      }
      if(value !== undefined) {
        return value;
      }
      // silently ignore unkown variables
      return "";
    },

    // Utility methods

    /* includes tag */
    includes: function(needle, haystack) {
      return haystack.indexOf(this.otag + needle) != -1;
    },

    /*
      Does away with nasty characters
    */
    escape: function(s) {
      s = String(s === null ? "" : s);
      return s.replace(/&(?!\w+;)|["'<>\\]/g, function(s) {
        switch(s) {
        case "&": return "&amp;";
        case "\\": return "\\\\";
        case '"': return '&quot;';
        case "'": return '&#39;';
        case "<": return "&lt;";
        case ">": return "&gt;";
        default: return s;
        }
      });
    },

    // by @langalex, support for arrays of strings
    create_context: function(_context) {
      if(this.is_object(_context)) {
        return _context;
      } else {
        var iterator = ".";
        if(this.pragmas["IMPLICIT-ITERATOR"]) {
          iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator;
        }
        var ctx = {};
        ctx[iterator] = _context;
        return ctx;
      }
    },

    is_object: function(a) {
      return a && typeof a == "object";
    },

    is_array: function(a) {
      return Object.prototype.toString.call(a) === '[object Array]';
    },

    /*
      Gets rid of leading and trailing whitespace
    */
    trim: function(s) {
      return s.replace(/^\s*|\s*$/g, "");
    },

    /*
      Why, why, why? Because IE. Cry, cry cry.
    */
    map: function(array, fn) {
      if (typeof array.map == "function") {
        return array.map(fn);
      } else {
        var r = [];
        var l = array.length;
        for(var i = 0; i < l; i++) {
          r.push(fn(array[i]));
        }
        return r;
      }
    }
  };

  return({
    name: "mustache.js",
    version: "0.3.1-dev",

    /*
      Turns a template and view into HTML
    */
    to_html: function(template, view, partials, send_fun) {
      var renderer = new Renderer();
      if(send_fun) {
        renderer.send = send_fun;
      }
      renderer.render(template, view, partials);
      if(!send_fun) {
        return renderer.buffer.join("\n");
      }
    }
  });
}();

/*global jQuery*/
/*jslint browser:true, vars:true*/

/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: jpeiffer $
 * - $Change: 1170585 $
 * - $DateTime: 2012/08/28 08:05:39 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #9 $
 */
(function ($) {
    'use strict';

    var FILE = "pep.dependency.js";
    window.start = new Date();
    window.PEP = window.PEP || {};


    /**
     * See below by: window.PEP.Dependency.
     */
    function Dependency() {
        var pvt = {
            vars: {
                log: {
                    "uses": {},
                    "define": {}
                },
                definitions: {},
                initializedObjects: {},
                defineCallbacks: {},
                logFactory: {
                    parseException: function () { return ""; }
                },
                logger: {
                    verbose: function () {},
                    debug: function () {},
                    info: function () {},
                    error: function () {},
                    fatal: function () {}
                }
            },

            uses: function (options) {
                var key = null;
                try {
                    key = options.key || null;
                    var file = options.from || null;
                    var callback = options.callback || null;
                    var context = options.context || this;

                    if (key === null) {
                        throw {
                            exception: "InvalidArgumentException",
                            message: "\"key\" must be defined on the given options",
                            file: FILE,
                            method: "uses"
                        };
                    }
                    if (file === null) {
                        throw {
                            exception: "InvalidArgumentException",
                            message: "\"from\" must be defined on the given options",
                            file: FILE,
                            method: "uses"
                        };
                    }

                    var obj = pvt.vars.initializedObjects[key];
                    if (obj === null || typeof obj === "undefined") {
                        // Only log on first import.  The "listDependencies" can
                        // be used to determine all references.
                        pvt.vars.logger.verbose({
                            file: FILE,
                            title: "Import: " + key + " from: " + file,
                            method: "uses",
                            detail: {
                                key: key,
                                from: file
                            }
                        });

                        var init = pvt.vars.definitions[key];
                        if (init) {
                            try {
                                obj = init.apply(context);
                            } catch (e) {
                                throw {
                                    exception: "RuntimeException",
                                    message: "error in initializer",
                                    FILE: file,
                                    method: "uses",
                                    detail: {
                                        cause: pvt.vars.logFactory.parseException(e)
                                    }
                                };
                            }

                            if (obj === null || typeof obj === "undefined") {
                                throw {
                                    exception: "RuntimeException",
                                    title: "Initializer returned with no object",
                                    file: FILE,
                                    method: "uses",
                                    detail: {
                                        key: key,
                                        from: file
                                    }
                                };
                            }
                        }

                        pvt.vars.initializedObjects[key] = obj;
                    }

                    if (obj === null || typeof obj === "undefined") {
                        var paths = key.split(".");
                        var location = window;
                        var path = null;
                        while (paths.length > 0 && location) {
                            path = paths.shift();
                            location = location[path];
                        }
                        if (location) {
                            obj = location;
                        }
                        pvt.vars.initializedObjects[key] = obj;
                    }

                    if (file) {
                        var log = pvt.vars.log.uses[key];
                        if (log) {
                            log[file] = (obj !== null && typeof obj !== "undefined");
                        } else {
                            pvt.vars.log.uses[key] = {};
                            pvt.vars.log.uses[key][file] = (obj !== null && typeof obj !== "undefined");
                        }
                    }

                    if (callback) {
                        if (obj === null || typeof obj === "undefined") {
                            var callbacks = pvt.vars.defineCallbacks[key];
                            if (callbacks) {
                                callbacks.push(callback);
                            } else {
                                pvt.vars.defineCallbacks[key] = [callback];
                            }
                        } else {
                            try {
                                callback.apply(context, [obj]);
                            } catch (e2) {
                                throw {
                                    exception: "RuntimeException",
                                    message: "error in callback",
                                    FILE: file,
                                    method: "uses",
                                    detail: {
                                        cause: pvt.vars.logFactory.parseException(e2)
                                    }
                                };
                            }
                        }
                    } else if (obj === null || typeof obj === "undefined") {
                        throw {
                            exception: "RuntimeException",
                            message: "Object not found and no callback given.",
                            file: FILE,
                            method: "uses",
                            detail: {
                                key: key,
                                from: file
                            }
                        };
                    }
                    return typeof obj === "undefined" ? null : obj;
                } catch (e3) {
                    var logObj = e3;
                    if (e3.exception && e3.message) {
                        logObj.title = "(" + key + "): " + e3.exception + ": " + e3.message;
                    }
                    pvt.vars.logger.error(logObj);
                    throw e3;
                }
            },

            define: function (options) {
                var key = null;
                try {
                    key = options.key || null;

                    var file = options.provider || null,
                        init = options.init || null,
                        context = options.context || this,
                        len,
                        i;

                    pvt.vars.logger.verbose({
                        file: FILE,
                        title: "Define: " + key + " from: " + file,
                        method: "define",
                        detail: {
                            key: key,
                            provider: file
                        }
                    });

                    if (key === null) {
                        throw {
                            exception: "InvalidArgumentException",
                            message: "\"key\" must be defined on the given options",
                            file: FILE,
                            method: "define"
                        };
                    }

                    if (init === null || typeof init !== "function") {
                        throw {
                            exception: "InvalidArgumentException",
                            message: "\"init\" must be defined as a function on the given options",
                            file: FILE,
                            method: "define"
                        };
                    }

                    if (pvt.vars.definitions[key]) {
                        pvt.vars.logger.info({
                            file: FILE,
                            title: "Redefinition of key detected: " + key + " from: " + file,
                            method: "define",
                            detail: {
                                key: key,
                                provider: file
                            }
                        });
                    }
                    pvt.vars.definitions[key] = init;

                    var callbacks = pvt.vars.defineCallbacks[key];
                    if (callbacks) {
                        pvt.vars.defineCallbacks[key] = null;
                        var obj = null;
                        try {
                            obj = init.apply(context);
                        } catch (e) {
                            throw {
                                exception: "RuntimeException",
                                message: "error in initializer",
                                FILE: file,
                                method: "define",
                                detail: {
                                    cause: pvt.vars.logFactory.parseException(e)
                                }
                            };
                        }

                        for (i = 0, len = callbacks.length; i < len; i += 1) {
                            try {
                                callbacks[i].apply(context, [obj]);
                            } catch (e2) {
                                // Don't let a callback blow up a definition.
                                pvt.vars.logger.fatal({
                                    title: "(" + key + "): RuntimeException: error notifying a callback",
                                    FILE: file,
                                    method: "define",
                                    detail: {
                                        cause: pvt.vars.logFactory.parseException(e2)
                                    }
                                });
                            }
                        }
                    }

                    if (file) {
                        var log = pvt.vars.log.define[key];
                        if (log) {
                            log[file] = true;
                        } else {
                            pvt.vars.log.define[key] = {};
                            pvt.vars.log.define[key][file] = true;
                        }
                    }

                    return context;
                } catch (e3) {
                    var logObj = e3;
                    if (e3.exception && e3.message) {
                        logObj.title = "(" + key + "): " + e3.exception + ": " + e3.message;
                    }

                    pvt.vars.logger.error(logObj);
                    throw e3;
                }
            }

        };

        this.init = function (file) {
            if (!file) {
                throw {
                    exception: "InvalidArgumentException",
                    message: "\"file\" parameter must be set.",
                    file: FILE,
                    method: "init"
                };
            }

            return {
                define: function (key, init) {
                    var self = this;
                    pvt.define({
                        key: key,
                        init: init,
                        provider: file,
                        context: self
                    });
                },
                uses: function (key, callback) {
                    var self = this;
                    return pvt.uses({
                        key: key,
                        callback: callback,
                        from: file,
                        context: self
                    });
                }
            };
        };

        this.listDependencies = function () {
            var deps = {};

            $.each(pvt.vars.log.uses, function (useKey, files) {
                var defined = pvt.vars.log.define[useKey],
                    definedFiles = [],
                    useFiles = [],
                    len,
                    i;

                if (!defined) {
                    defined = {"[unknown]": true};
                }

                $.each(defined, function (file, bool) {
                    definedFiles.push(file);
                });

                $.each(files, function (file, bool) {
                    useFiles.push(file);
                });

                definedFiles.sort();
                useFiles.sort();

                for (i = 0, len = useFiles.length; i < len; i += 1) {
                    var file = useFiles[i];
                    deps[file] = deps[file] || {};
                    deps[file][useKey] = definedFiles;
                }

            });

            return deps;
        };

        this.dependencyTree = function (src) {
            var definitions = {};
            var deps = this.listDependencies();
            var allObjects = {};
            var allFiles = {};
            var obj = {
                source: src,
                definitions: [],
                tree: {},
                files: [],
                objects: []
            };

            var buildTree = function (fileName, node, objects, files) {
                var srcDeps = deps[fileName];
                if (srcDeps) {
                    $.each(srcDeps, function (key, defFiles) {
                        var file = null,
                            myObjects = $.extend({}, objects),
                            myFiles = $.extend({}, files),
                            len,
                            i;

                        node[key] = {
                            files: defFiles
                        };

                        if (myObjects[key]) {
                            node[key].circularReference = true;
                        } else {
                            myObjects[key] = true;

                            if (!allObjects[key]) {
                                allObjects[key] = true;
                                obj.objects.push(key);
                            }

                            for (i = 0, len = defFiles.length; i < len; i += 1) {
                                file = defFiles[i];
                                if (!myFiles[file]) {
                                    myFiles[file] = true;

                                    if (!allFiles[file]) {
                                        allFiles[file] = true;
                                        obj.files.push(file);
                                    }

                                    buildTree(file, node[key], myObjects, myFiles);
                                }
                            }
                        }
                    });
                }

            };

            var srcObjects = pvt.vars.log.define[src];
            if (srcObjects) {
                $.each(srcObjects, function (key, defFiles) {
                    if (!definitions[key]) {
                        definitions[key] = true;
                        obj.definitions.push(key);
                    }
                });
            }

            buildTree(src, obj.tree, {}, {});

            obj.objects.sort();
            obj.files.sort();

            return obj;
        };


        var dependency = this.init(FILE);
        dependency.uses("PEP.Log.Factory", function (factory) {
            if (factory) {
                pvt.vars.logFactory = factory;
                pvt.vars.logger = factory.createLogger("PEP.Dependency");
            }
        });
    }

    /**
     * Defines a global dependency management object that can be used to define
     * and use objects across scopes.  The public API is as follows:
     *
     * public DependencyContainer init(String fileName)
     *   *** Initializes a container for the given file to track dependencies.
     *   * fileName - The meaningful name of the file initializing the
     *                container.
     *   * DependencyContainer - an object that contains the following
     *                           functions:
     *       {
     *           public Object uses(String key, Function callback)
     *             *** Defies a required key that is needed by the caller.  If
     *                 the object is already defined, it will be returned,
     *                 and the optional callback will be called immediately.
     *                 If the object is already defined then if the callback
     *                 is set then the callback will be stored and called when
     *                 the object is defined.  If the object is not defined and
     *                 there is no optional callback then this will throw an
     *                 exception.
     *             * key - The string identifier for the dependency.
     *             * callback - An optional callback function to execute in the
     *                          event that the dependency has not yet been
     *                          defined.  The object will be passed in as a
     *                          parameter to the callback.
     *             * Object - The object representing the dependency; if already
     *                        defined.  Will be null if not defined and a
     *                        callback exists.
     *
     *            public void define(String key, Function init)
     *              *** Defines an available dependency object.  If items have
     *                  requested this dependency with a callback then their
     *                  callbacks will be executed before this is returns.
     *              * key - The string identifier for the dependency.
     *              * init - A no-arg initializer function to execute once the
     *                       dependency has been requested through a "uses"
     *                       call.
     *       }
     *
     * public Map<String, Map<String, List<String>>> listDependencies()
     *   *** Lists the dependencies that have been processed by this.  The
     *       returned object uses the file in the "uses" as the key to the
     *       map, then the identifier for the object requested, then a list
     *       of source files that define the object (ideally, there will only
     *       be one).
     *
     *
     * public Object dependencyTree(String srcFile)
     *   *** Returns an object that describes the dependencies currently
     *       discovered by the given source file.
     */
    window.PEP.Dependency = window.PEP.Dependency || new Dependency();
}(jQuery));
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: weclowney $
 * - $Change: 1173646 $
 * - $DateTime: 2012/08/30 14:05:13 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #4 $
 */
(function($) {
    window.PEP = window.PEP || {};
    window.PEP.Log = window.PEP.Log || {};
    
    window.PEP.Log.Level = {
        NONE: 0,
        FATAL: 1,
        ERROR: 2,
        WARN: 3,
        INFO: 4,
        DEBUG: 5,
        VERBOSE: 6
    };
})(jQuery);/*global console*/
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: rhernande $
 * - $Change: 1228308 $
 * - $DateTime: 2012/11/01 08:28:13 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #19 $
 */
(function($) {
    var FILE = "pep.logger.log.js";
    var dependency = PEP.Dependency.init(FILE);
    
    /**
     * Defines the logger object.  Everything that can be made private to the
     * object is to prevent accidental system-wide tampering of the logging
     * object.  This also allows for efficiencies such as dynamically 
     * constructing the methods to do interesting stuff or be simple no-ops.
     */
    dependency.define("PEP.Log.Logger", function() {
        var Logger = function() {
        };
        
        Logger.prototype.init = function(namespace, settings) {
            var self = this;
    
            // Below is an optimization to reduce the need for "if" statements
            // in the logger itself.  The functions that cannot apply due to the
            // logging level are set to a no-op function so that no processing would
            // ever need to happen for them when called.
            var noop = function() {
                return self;
            };
    
            var createBody = function(json) {
                var body = "{}";
    
                try {
                    body = JSON.stringify(json);
                } catch (e) {
                    try {
                        body = JSON.stringify("JSON.stringify error: " + e);
                    } catch (e2) {
                        body = "JSON.stringify fatal error... no details available.";
                    }
                }
    
                return body;
            };
    
            
            /**
             * Handles the actual logging for the given message.  This is called
             * from any method that applies for the set log level.  This execute
             * the logging regardless of the set level so it is up to the caller to
             * ensure the proper level is set before calling this.
             *
             * This is purposely private so outside objects cannot call it directly.
             *
             * @param String levelName The name of the log level.
             * @param {String | Object} message The message to log.  This message
             *                                  will be converted to a JSON string
             *                                  before being logged.
             */
            var log = function(levelName, message, consoleMethod) {
                var json = {
                    namespace: namespace,
                    level: levelName,
                    timestamp: new Date(),
                    message: message
                };
    
                if (settings.console === true) {
                    if (typeof console !== "undefined" && console) {
                        var timestamp = json.timestamp.getHours() + ":" + json.timestamp.getMinutes() + ":" +
                            json.timestamp.getSeconds() + "." + json.timestamp.getMilliseconds();
                        var title = (typeof message === 'string' ? 
                                message : ((message && message.title) ? message.title : "[no title]"));
                        var header = levelName + 
                            " | " + timestamp + 
                            " | " + json.namespace + 
                            " | " +  title;
                        var details = json;
                        
                        // If the desired console method doesn't exist
                        // Fallback to the default
                        if (!console[consoleMethod] && console.log) {
                            consoleMethod = 'log';
                        } 
                        
                        console[consoleMethod](header + "\n", details);
                    }
                }
    
                if (settings.service === true) {
                    $.ajax({
                        url: "/utils/log",
                        type: "POST",
                        contentType: "application/json",
                        data: createBody(json)
                    });
                }
    
                return self;
            };
    
            this.verbose = function(message, title) { return log("VERBOSE", message, "debug"); };
            this.debug = function(message, title) { return log("DEBUG", message, "debug"); };
            this.info = function(message, title) { return log("INFO", message, "info"); };
            this.warn = function(message, title) { return log("WARN", message, "warn"); };
            this.error = function(message, title) { return log("ERROR", message, "error"); };
            this.fatal = function(message, title) { return log("FATAL", message, "error"); };
            this.isEnabled = function(level) { return settings.level >= level; };
    
            var methods = ["fatal", "error", "warn", "info", "debug", "verbose"];
            for (var i = 0, len = methods.length; i < len; i++) {
                if (settings.level <= i) {
                    this[methods[i]] = noop;
                }
            }
        };
        
        return Logger;
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: jpeiffer $
 * - $Change: 1130483 $
 * - $DateTime: 2012/07/09 10:22:01 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #10 $
 */
(function($) {
    var FILE = "pep.factory.log.js";

    window.PEP = window.PEP || {};
    window.PEP.Log = window.PEP.Log || {};
    window.PEP.Config = window.PEP.Config || {};
    window.PEP.Config.Log = window.PEP.Config.Log || {};
    window.PEP.Config.Log.DefaultLogOptions = window.PEP.Config.Log.DefaultLogOptions || {};
    var Logger = window.PEP.Log.Factory ? window.PEP.Log.Factory.Logger : null;
    
    var dependency = PEP.Dependency.init(FILE);
    /**
     * The static factory object to use when requesting loggers.  For more 
     * details on the logging framework, see the wiki:
     * https://wiki.nge.wdig.com/display/NGE/JS+Error+Logging+Framework+(ELF)
     */
    window.PEP.Log.Factory = {
        Logger: Logger,
            
        /**
         * Creates and returns a new logger for the given namespace using the
         * optional set of options.
         * 
         * @param String namespace The name space for the logger. Used to group
         *                         logging across different parts of the site. 
         *                         Example: "PEP.Mapplication". Also used to 
         *                         trigger different default values.
         * @param LogOptions options (optional: default = null) - The options to
         *                           use for logging information. Any values
         *                           passed in through this object will override
         *                           default values for the application.
         * @return Logger The logger which can be used to log messages.
         */
        createLogger: function(namespace, options) {
            if (this.Logger === null) {
                throw {
                    title: "Unable to initialize Logger",
                    exception: "RuntimeException",
                    file: FILE
                };
            }
            
            // If no namespace is set, use an empty string rather than fail.
            namespace = namespace || "";
            
            var defaults = {
                console: false,
                consoleLogAsString: true,
                level: window.PEP.Log.Level.ERROR,
                service: false,
                format: false
            };
            var systemDefaults = {
                options: defaults,
                namespaces: {}
            };
            
            $.extend(true, systemDefaults, window.PEP.Config.Log.DefaultLogOptions);
            
            var namespaceSettings = systemDefaults.namespaces[namespace] || {};
            
            // The priority is...
            //   1) The passed in options.
            //   2) The defaults for the namespace.
            //   3) The defaults for the system.
            var settings = $.extend(true, {}, systemDefaults.options, namespaceSettings, options);
            
            var logger = new this.Logger();
            logger.init(namespace, settings);
            return logger;
        },
        
        /**
         * Parses a JavaScript exception into a JS Object that can be used for
         * reporting.
         * 
         * @param Object e A JS exception object.  If this is any other type of
         *                 object then it will be returned as is.
         * @return Object a JS object representing the given exception, or if
         *                the given exception is not an object then this will
         *                return the passed in object.
         */
        parseException: function(e) {
            var obj = e;
            
            // HACK!!!  Required to get JSLint to stop complaining.
            var arg = "arguments";
            
            if (e && e.message && e.stack && e.type && e[arg]) {
                var args = e[arg];
                if (args && args.length) {
                    // Convert the arguments into strings.  The reason to do 
                    // this is that one or more may contain circular references
                    // that will fail to convert.  Get rid of those before we
                    // try to log them out and toss an exception in the logger.
                    for (var i = 0, len = args.length; i < len; i++) {
                        try {
                            args[i] = JSON.stringify(args[i]);
                        } catch (ex) {
                            args[i] = "{{string conversion failed}}";
                        }
                    }
                }
                
                obj = {
                    exception: e.type,
                    stackTrace: e.stack,
                    message: e.message,
                    "arguments": args
                };
            }
            
            return obj;
        }
    };
    
    dependency.define("PEP.Log.Factory", function() {
        var Factory = window.PEP.Log.Factory;
        dependency.uses("PEP.Log.Logger", function(Logger) {
            Factory.Logger = Logger;
        });

        return window.PEP.Log.Factory;
    });
    
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #4 $
 */

(function($, PEP) {
    PEP.Config = PEP.Config || {};
    PEP.Config.Toggles = PEP.Config.Toggles || {};

	//Reserving Namespace for Future Helper Functions.
    PEP.Toggles = {
	
		/**
		 *  Use this method to initialize a Toggle Set space.  If the set already exists nothing is changed
		 */
        create: function(name) {
			PEP.Config.Toggles[name] = PEP.Config.Toggles[name] || {};
		}
    };

    PEP.Toggles.create("Flow");
    PEP.Toggles.create("Feature");
    PEP.Toggles.create("Release");
})(jQuery, PEP);(function($) {
    /**
     * A Helper function to create a multi-function jQuery plugin
     *
     * A multi-function plugin is one where the first argument is the name of a
     * function to call, but it's all apart of the same plugin.  Subsequent
     * arguments to the plugin are arguments to the function.
     *
     * This plugin works by delegating those calls to properties of an object.
     * Each function in that object has it's context changed to the jQuery
     * instance.  So when you're using "this", remember that.
     *
     * Because each function in that object is given the context of the jQuery
     * object, if the function isn't returning a value, it should return "this"
     * so that chaining is still possible.
     *
     * Example of Creating a Plugin:
     *
     * > $.pepPlugin('map', {
     * >    init: function(config) {
     * >        ...
     * >        return this;
     * >    },
     * >    zoomIn: function() {
     * >        ...
     * >        return this;
     * >    },
     * >    zoomOut: function() {
     * >        ...
     * >        return this;
     * >    },
     * >    move: function(x, y) {
     * >        ...
     * >        return this;
     * >    }
     * > });
     *
     * Example of Using the Created Plugin:
     *
     * > $('#myMap').map().map('zoomIn').map('move', 100, 100);
     *
     * If you decide to access the original object that is being used behind
     * the scenes of your plugin, you can do so by accessing the plugin
     * property of your plugin function.
     *
     * > $.fn.map.plugin
     *
     * If you need to mock or stub functions, you can do so by replacing
     * functions on that object.
     *
     * > $.fn.map.plugin.zoomOut = function() {
     * >    return "Zoom Out Stub");
     * > };
     * >
     * > $('#myMap').map().map('zoomOut');  // Returns "Zoom Out Stub"
     *
     * @param name {string} The name of jQuery plugin to create
     * @param public {object} The object which contains all of the functions for your
     * plugin.  NOTE:  You MUST include an init property!
     * @param protected {object} The object which contains all the functions/values you would
     * like to make available to your extended plugins.
     *
     */
    $.pepPlugin = function(name, public, protected) {
        var publicApi = public || {};
        var protectedApi = protected || {};
        $.fn[name] = function() {
            if (arguments.length === 0 || typeof arguments[0] === 'object') {
                // make sure this element knows we use this plugin
                this.data(name, 1);

                // make sure this element knows it is using a general pep plugin
                this.data('pepPlugin', 1);

                // make sure this element knows all of the plugins it is using
                this.each(function () {
                    var pluginList = $.data(this, 'pluginList') || {};
                    pluginList[name] = 1;
                    $.data(this, 'pluginList', pluginList);
                });

                if (typeof  $.fn[name].plugin.preInit === 'function') {
                    $.fn[name].plugin.preInit.call(this, $.fn[name].plugin, $.fn[name].protected);
                }

                return $.fn[name].plugin.init.apply(this, arguments);
            } else {
                var args = Array.prototype.slice.call(arguments, 0),
                    fnName = args.shift();
                return $.fn[name].plugin[fnName].apply(this, args);
            }
        };
        publicApi._pluginName = name;
        protectedApi._pluginName = name;
        $.fn[name].plugin = publicApi;
        $.fn[name].protected = protectedApi;

        // create selector for plugin
        $.expr[":"][name] = function(elem) {
            return !!$.data(elem, name);
        };
    };

    /**
     * A helper function used to be able to extend the functionality of a pepPlugin already defined
     * on the page. It was created to allow us to be able to inheret the functionality of a
     * plugin that already exists but will still allow us to override the functionality of the
     * base plugin.
     *
     * @param name {string} The name of the plugin you wish to register.
     * @param basePluginName {string} The name of the plugin you wish to extend.
     * @param public {object} The object you want to extend on top of the basePluginApi object.
     * @param protected {object} The object you want to extend on top of the baseProtectedApi.
     */
    $.pepPlugin.extend = function (name, basePluginName, public, protected) {
        var basePluginApi = $.fn[basePluginName].plugin;
        var extendedPluginApi = Object.create(basePluginApi);
        var baseProtectedApi = $.fn[basePluginName].protected;
        var extendedProtectedApi = Object.create(baseProtectedApi);
        //attach obj methods/properties to the extendedPluginApi
        for (var key in public) {
            if (public.hasOwnProperty(key)) {
                extendedPluginApi[key] = public[key];
            }
        }
        //attach obj methods/properties to the extendedProtectedApi
        for (var key in protected) {
            if (protected.hasOwnProperty(key)) {
                extendedProtectedApi[key] = protected[key];
            }
        }
        //register new plugin
        $.pepPlugin(name, extendedPluginApi, extendedProtectedApi);
    };

    // create selector for all plugin
    $.expr[":"].pepPlugin = function(elem) {
        return !!$.data(elem, 'pepPlugin');
    };
})(jQuery);

(function($) {
    var FILE = "jquery.pepAutoPlugin.js";
    var dependency = PEP.Dependency.init(FILE);

    // Stub out the logger in case the framework wasn't included.
    var logger = {
        error: function() { /* no-op */}
    };

    dependency.uses("PEP.Log.Factory", function(logFactory) {
        logger = logFactory.createLogger("PEP.AutoPlugin");
    });

    $.pepPlugin('pepAutoPlugin', {
        init: function() {
            return this.each(function() {
                var $this = $(this),
                    attrValue = $this.attr('data-plugins'),
                    jsonPluginMagic = $.parseJSON(attrValue);
                /*
                PHP will have converted our incoming params into
                nicely formatted JSON.  Here are some pretty examples
                for you:

                initializing single plugin with no params - single
                string in array ["bar"] // in js, this would have been
                something like: $('#myMap').bar();

                initializing multiple plugins with no params -
                multiple strings in array ["foo", "bar"]

                chaining, which we might have done in JS like this:
                $('#pluginInitTest').foo().foo('fooPop').foo('customFoo',
                'Splat!'); represented by JSON call like this on
                data-plugins attribute of target element: ["foo",
                ["foo", "fooPop"], ["foo","customFoo","Splat!"]]

                mixing and matching above examples ["bar", ["foo",
                "fooPop"], ["foo","customFoo","Splat!"]]
                */

                // now iterate through the array we should have from
                // the parseJSON call.
                if (jsonPluginMagic) {
                    $.each(jsonPluginMagic, function(i, j) {
                        if (typeof j === 'string') {
                            // if string, just make our plain old plugin
                            // init call with no params
                            if ($.isFunction($this[j])) {
                                $this[j]();
                            } else {
                                logger.error({
                                    title: "plugin called but not found:" + j
                                });
                            }

                        } else if ($.isArray(j)) {

                            // if array, then we know we have to do some
                            // chained calls, perhaps w/ params
                            var dynamicArgs = j,
                                pluginName = dynamicArgs.shift();

                            // do our dynamic method call with some jQuery
                            // and Prototype code voodoo.
                            if ($.fn[pluginName]) {
                                $.fn[pluginName].apply($this, dynamicArgs);
                            }
                        }
                    });
                }
            });
        },
        destroy: function() {
            // hopefully, we have a list of all the elements that are
            // using a plugin
            return this.each(function() {

                // get our list of plugins for this element
                var pluginList = $.data(this, 'pluginList') || {},
                    $this = $(this);

                // call destroy on each plugin from our list
                $.each(pluginList, function(pluginName, pluginState) {
                    // Skip this plugin because we are technically
                    // calling delete now.  If you don't you end up
                    // with some awful recursion issues :)
                    if (pluginName === 'pepAutoPlugin') {
                        return;
                    }
                    $this[pluginName]('destroy');
                });

                // delete our list of plugins on this element although
                // technically, his might not be necessary since the
                // element is going to be deleted when our ajax call
                // is made.
                $.data(this, 'pluginList', null);
            });
        }
    });
})(jQuery);
/**
 * This plugin inserts a search and clear button into the Search Box Ui Plus component and adds functionaity
 * to those buttons.  It also has the ability to dynamically change its placeholder by triggering the
 * 'updatePlaceHolder.pepGlobal' event from another plugin and passing it a value for that placeholder.
 * 
 * Possible configuration keys:
 *	allowEmptySearchText: true/false
 *	analyticsLinkId: <string for *analyticslinkid* attribute value>
 *	clearText: <string/translation key> - Clear button text
 * 	preventSubmit: true/false
 *	searchText: <string/translation key> - Submit button text
 *	translateAccessibilityText: true/false; determine if the Text values need to be translated
 */
(function($, PEP) {
    var PLUGIN_NAMESPACE = '.pepUiPlusSearchBox',
        searchBtn,
        clearBtn,
        searchPerformed = false,
        FILE = 'jquery.pepUiPlusSearchBox.js',
        dependency = PEP.Dependency.init(FILE),
        Translator = null;

    $.pepPlugin('pepUiPlusSearchBox', {
        /**
         * Function: init
         * Initializes the PEP Ui Plus Search Box plugin
         *
         * Return:
         *     The jQuery object that the plugin was initialized with
         */
        init: function(config) {
            var elem = $(this),
                $form = elem.parents('form'),
                id = $(this).attr('id'),
                defaultConfig = {
                    preventSubmit: true,
                    allowEmptySearchText: false,
		    analyticsLinkId: '',
                    translateAccessibilityText: true,
                    searchText: 'searchBox.searchButton.text',
                    clearText: 'searchBox.clearButton.text'
                },
                options = $.extend(defaultConfig, config),
                searchText = options.searchText,
                clearText = options.clearText;

            elem.data('pepUiPlusSearchBox_options', options);

            //translate accessible text if needed
            if (options.translateAccessibilityText) {
                Translator = dependency.uses('PEP.translate.Translator');
                Translator.loadTranslations([options.searchText, options.clearText], function() {
                    searchText = Translator.translate(options.searchText);
                    clearText = Translator.translate(options.clearText);
                });
            }

            //insert buttons on page
	    // Analytics-link-id is not using data attribute per WDPROWEBA-193, for IE-compatibility issue
	    var analyticsData = (options.analyticsLinkId === '' ? '' : ' analyticslinkid="' + options.analyticsLinkId + '" ');
            searchBtn = $('<button class="search_button icon-interactive-xs search-default inactive' +
                ' accessibleText hoverable" id="'+ id + '_search_button" ' + analyticsData + 'type="submit">' + searchText + '</button>');
            clearBtn = $('<button class="clear_button icon-interactive-xs close-default inactive' +
                ' hoverable accessible" id="'+ id + '_clear_button" type="button">' + clearText + '</button>');

            searchBtn.insertAfter(elem);
            clearBtn.insertAfter(elem);

            //check for persistant data
            if($(this).val() !== '') {
                clearBtn.show();
            }
            else {
                clearBtn.hide();
            }

            //events
            clearBtn.click(function() {
                elem.pepUiPlusSearchBox('clearButtonClicked');
            });
            elem.bind("change keyup", function() {
                elem.pepUiPlusSearchBox('searchBoxTextChanged');
            });
            $form.bind('submit'+PLUGIN_NAMESPACE, function(event) {
                elem.pepUiPlusSearchBox('submitForm', event, options);
            });
            elem.bind('updateSearchBoxPlaceHolder.pepGlobal'+PLUGIN_NAMESPACE, function(event, value) {
                elem.pepUiPlusSearchBox('updatePlaceHolder', value);
            });
            elem.bind('clearKeywordSearch.pepGlobal' + PLUGIN_NAMESPACE, function () {
                elem.pepUiPlusSearchBox('clearButtonClicked');
            });
            elem.bind('keywordSearchPerformed.pepGlobal', function(e, text) {
                //incase a search was performed on the page without using the search box
                elem.pepUiPlusSearchBox('setSearchText', text);
                searchPerformed = true;
            });

            return this;
        },
        /**
         * Function: submitForm
         * Handles when the form is submitted. Blurs the searchBox and sets the search performed flag.  Also fires
         * the 'performKeywordSearch.pepGlobal' event.
         */
        submitForm: function (event, options) {
            var elem = $(this),
                $searchText = $.trim(elem.val());

            if (options.preventSubmit || (!options.allowEmptySearchText && $searchText.length === 0)) {
                event.preventDefault();
            }
            elem.blur();
            // Only Search if there is non-whitespace text
            if ($searchText.length > 0 && !options.allowEmptySearchText) {
                elem.trigger('performKeywordSearch.pepGlobal', $searchText);
                searchPerformed = true;
            } else if (searchPerformed) {
                elem.pepUiPlusSearchBox('clearButtonClicked');
            }
        },
        /**
         * Function: destroy
         * Destroys the plugin and returns the DOM to it's original state
         *
         * Return:
         *     The jQuery object that the function was called with
         */
        destroy: function() {
            return this.unbind(PLUGIN_NAMESPACE);
        },
        /**
         * Function: clearButtonClicked
         * Handles when the clear button is clicked. Clears the text in the search box and if a
         * search has been done it will trigger the 'keywordSearchCleared' event.
         */
        clearButtonClicked: function(event) {
            var elem = $(this),
                clearButton = $('#'+elem.attr('id')+'_clear_button');
            elem.val('');
            clearButton.hide();
            if(searchPerformed) {
                elem.trigger('keywordSearchCleared.pepGlobal');
                searchPerformed = false;
            }

            // focus the input for accessibility easing
            elem.focus();

            return this;
        },
        /**
         * Function: updatePlaceHolder
         * Updates the search box placeholder based on the value parameter
         *
         * @param: value
         */
        updatePlaceHolder: function(value) {
            value =  (typeof value === 'undefined') ? '' : value;
            $(this).attr('placeholder', value)
                   .blur();                        //need to blur for IE
        },
        /**
         * Function: setSearchText
         * Sets the text in the search box to the parameter passed.
         *
         * @param: text
         */
        setSearchText: function(text) {
            var elem = $(this),
                clearButton = $('#'+elem.attr('id')+'_clear_button');

            elem.val(text).change();
            if(elem.val() !== '') {
                clearButton.show();
            }
            else {
                clearButton.hide();
            }
        },
        /**
         * Function: searchBoxKeyUp
         * Handles when the search box text is changed.  Shows the clear button if their is text else it hides it.
         */
        searchBoxTextChanged: function() {
            var elem = $(this),
                clearButton = $('#'+elem.attr('id')+'_clear_button'),
                $searchText = elem.val();
            if($searchText.length > 0) {
                clearButton.show();
            }
            else {
                clearButton.hide();
            }
            return this;
        }
    });
})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: jawilson $
 * - $Change: 1228210 $
 * - $DateTime: 2012/11/01 07:22:11 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #13 $
 */

/**
 * This plugin adds rich visual styles to IE 7, 8, and 9.  It handles the display of focus images for the text input
 * background-images.  It also adds placeholder functionality since this is not supported by our degraded browser.
 * Lastly, it allows for easy deactivation of the element via JavaScript.  This plugin handles all client-side
 * validation disabling/re-enabling).
 */

(function($) {
    "use strict";

    $.pepPlugin('pepTextInput', {
        init: function() {
            var $this = this;
            var $parent = $this.parent();
            var placeholder;

            if (!Modernizr.input.placeholder) {

                var phAttr = $this.attr('placeholder');

                // create IE placeholder element
                if (typeof phAttr !== "undefined" && phAttr !== null) {
                    placeholder = $('<span />').addClass('textInputPlaceholder').css(
                        {
                            'width': $this.css('width'),
                            'height': $this.css('height'),
                            'padding-top': $this.css('padding-top'),
                            'margin-top': $this.css('margin-top'),
                            'padding-left': $this.css('padding-top'),
                            'display': ($this.val() === '') ? 'block' : 'none'
                        }
                    ).html(phAttr).appendTo($parent);

                    placeholder.bind('click.pepTextInput', function() {
                        $this.focus();
                    });

                    $this.bind('blur.pepTextInput', function() {
                        if ($this.closest('.jsvfElement').hasClass('disabled') === false &&
                            $this.val() === '' && phAttr !== null && phAttr !== undefined) {
                            if (phAttr !== placeholder.text()) {
                                 placeholder.text(phAttr);
                            }
                            placeholder.css('display', 'block');
                        }
                    });

                    $this.bind('focus.pepTextInput', function() {
                        if ($this.closest('.jsvfElement').hasClass('disabled') === false &&
                            phAttr !== null && phAttr !== undefined) {
                            placeholder.css('display', 'none');
                        }
                    });

                    $this.bind('change.pepTextInput', function() {
                        if (phAttr !== null && phAttr !== undefined && $this.val() !== '') {
                            placeholder.css('display', 'none');
                        }
                    });
                }
            } // end placeholder support check

            $this.data('resetValue', $this.val());

            $this.bind('reset-input-to-default.pepTextInput', function() {
                $this.val($this.data('resetValue'));
            });

            // Stop propagation incase text boxes are inside of the radio or element
            // and arrow keys are pressed to avoid radio value changing
            $this.on('keydown.pepTextInput', function(e) {

                switch(e.keyCode) {
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.LEFT:
                        e.stopPropagation();
                        break;
                }
            });

            return this;
        },
        destroy: function() {
            this.find('.textInputPlaceholder').remove();
            this.unbind('.pepTextInput');

            return this;
        }
    });

})(jQuery);
(function ($) {
    var _originalWidth,
        _tempHtmlStorage = null,
        _preferredView,
        _originalScroll,
        _originalDom,
        _isFullSize,
        _repositionTimer,
        _launcher,
        _preventQuickClick = false,
        _hasScrollBar = false,
        _scrollBarWidth;
    //Set Constants
    var PLUGIN_NAME               = 'pepModalUIPlus',
        BUTTON_PARENT_CLASS       = 'subflowDockClass',
        BUTTON_PARENT_ID          = 'modalUIPlusButtonPane',
        BUTTON_PARENT             = '#' + BUTTON_PARENT_ID,
        BUTTONS                   = 'modalUIPlusButtons',
        BUTTONS_CONTAINER         =  BUTTON_PARENT + ' .' + BUTTONS,
        BORDER_RADIUS_DIV         = 'borderRadius',
        MODAL_LOAD_DIV_ID         = 'modalLoaderContainer',
        MODAL_LOAD_DIV            = '#' + MODAL_LOAD_DIV_ID,
        MODAL_OVERLAY             = '.ui-widget-overlay',
        CLOSE_MODAL_SELECTOR      = 'closeModalWindow',
        MODAL_PARENT_ID           = 'modalDialogDivContainer',
        MODAL_PARENT              = '#' + MODAL_PARENT_ID,
        MODAL_CUSTOM_CLASS        = 'pepModalCustomClass',
        MODAL_WRAPPER_CLASS       = '.ui-dialog',
        MODAL_CONTENT_DIV_ID      = 'modalTmpContent',
        MODAL_CONTENT_DIV         = '#' + MODAL_CONTENT_DIV_ID,
        MODAL_BACKGROUND          = 'tmp_overlay_background',
        VIEWPORT_PADDING          = 200,
        FOOTER_TEXT_CONTAINER     = 'modalContainerFooterText',
        MODAL_TITLE               = 'h1#ui-dialog-title-contents',
        MOBILE_UI_CLASS           = 'pepMobileUI',
        FULL_UI_CLASS             = 'fullSize',
        ANALYTICS_PREFIX          = '&lid=',
        COMMON_SETTINGS = {
            dialogLauncher: '',
            draggable: false,
            resizable: false,
            closeOnEscape: true,
            hideCloseButton: true,
            maxWidth: window.innerWidth - VIEWPORT_PADDING,
            minWidth: 550,
            modal: true,
            footerText: null,
            title: null,
            backgroundClose: false,
            dialogClass: MODAL_CUSTOM_CLASS,
            actionButtons: null,
            closeButton: null,
            position: {
                my: "center center",
                at: "center center"
            },
            resize: 'auto',
            zIndex: 1000,
            detachFromDom: false,
            closeButtonBefore: false,
            headerFlag: true,
            customClass: null,
            customOpenEvent: null,
            customCloseEvent: null,
            useAnimations: false,
            openedEvent: 'dialogOpened',
            stopEventPropagation: false,
            skipFocus: false,
            forceOpen: false,
            close : function(e) {
                _preventQuickClick = false;
                $('#' + MODAL_BACKGROUND).remove();
                $(MODAL_PARENT).remove();
                $('.modalGradientBg').remove();

                $(MODAL_OVERLAY).unbind('click', function() {
                    $(MODAL_PARENT).dialog('close');
                });

                $('body').css({'overflow': '', 'margin-right': 0});

                if (_preferredView !== 'mobile') {
                    $('body').bind('click', _bindKeyup);
                }

            },
            // Pass in analytics when you want to track the modal opening
            // as an interactive element
            // See: https://wiki.wdpro.wdig.com/x/hpPAB
            // eg, analytics: {
            //    model : {
            //       linkId : 'someLinkId',
            //       trackingType : 'customLink'
            //    },
            //    elementName : 'someElementName'
            // }
            analytics: null,
            isModalButton: false
        },
        DATA_KEYS = {
            options: PLUGIN_NAME + '.options'
        };

    var _bindKeyup = function () {
        _preventQuickClick = true;
        $(_launcher).focus();
        $('body').unbind('click', _bindKeyup);
        $(document).unbind('keydown');
        window.setTimeout(function(){_preventQuickClick = false;}, 500);
    };

    /**
     * Walk through object and return a string representation of key/value HTML attributes
     *
     * <code>
     *  var input = {
     *      'aria-describedby': 'activity-label',
     *      'id': 'activity-label'
     *  }
     * var output = _objectToHtmlAttrs(input);
     * // result: 'aria-describedby="activity-label" id="activity-label"'
     * </code>
     *
     * @param obj       a one-level object deep to walk
     * @return string   the html attrs representation
     */
    var _objectToHtmlAttrs = function (obj) {
        return $.type(obj) === 'object' && $.map(obj, function(value, key) {
            return key + '="' + value + '"';
        }).join(' ') || '';
    }

    var _closeButtonTemplate  =
            '<span {{{attrsButton}}} class="pillBase {{category}} ' + CLOSE_MODAL_SELECTOR + '">' +
                '<span class="gradient">' +
                    '<span {{#extendsA11y}}{{{attrsLabel}}}{{/extendsA11y}} class="buttonText">{{label}}' +
                    '{{#showAccessibleText}}' +
                        '<span {{#extendsA11y}}{{{attrsDescription}}}{{/extendsA11y}} class="accessibleText" style="left:0">{{accessibleText}}</span>' +
                    '{{/showAccessibleText}}' +
                    '</span>' +
                '</span>' +
            '</span>',
        _horizontalSeparator =
            '<div class="horizontalSeparator"></div>';

    /**
     * @param array options | User Defined Parameters
     * @param boolean noBind | Passed from JS if click event does not need to be binded
     */
    $.pepPlugin(PLUGIN_NAME, {
        init: function(options, noBind) {
            return this.each(function(){
                var $self = $(this);
                _preferredView = $self.pepModalUIPlus('getDevice');

                $self.hide();

                _hasScrollBar = $self.pepModalUIPlus('checkScrollBar');

                options.open = function() {
                    $self.pepModalUIPlus('openModalFunctions');
                };

                options = $.extend({}, COMMON_SETTINGS, options);

                if (options.hideCloseButton) {
                    options.dialogClass += ' ' + "no-close";
                }

                //Checks for forcePreferredView value (See PRO-53403) and forces
                //desktop view if the param is present
                if (typeof(options.forcePreferredView) !== "undefined"
                    && (options.forcePreferredView === 'desktop' || options.forcePreferredView === 'mobile')
                    ) {
                    _preferredView = options.forcePreferredView;
                }

                $self.data(DATA_KEYS.options, options);    // Saves the custom options
                if (options.mobile === true || options.mobile === 'true' || _preferredView === 'mobile') {
                    $self.addClass (MOBILE_UI_CLASS);
                }
                if (options.title !== null && typeof options.title !== "undefined") {
                    if (options.headerFlag) {
                        options.title = '<h1 id="ui-dialog-title-contents" tabindex="-1">' + options.title + '</h1>';
                    }

                    if (typeof options.titleDivider !== "undefined") {
                        options.title += _horizontalSeparator;
                    }
                }

                if (options.customClass) {
                    options.dialogClass += ' ' + options.customClass;
                }

                if (noBind) {
                    $self.pepModalUIPlus('open', options);
                } else if (options.customOpenEvent) {
                    $self.bind(options.customOpenEvent, function(e) {
                        e.preventDefault();
                        $self.pepModalUIPlus('open', options, e.target);
                    });
                } else {
                    // Checks to see if dialogLauncher is not empty or null and then runs the rest
                    options.dialogLauncher && $(options.dialogLauncher).on('click', function(e) {
                        e.preventDefault();
                        $self.pepModalUIPlus('open', options, e.target);
                        if (options.stopEventPropagation === true) {
                            e.stopPropagation();
                            return;
                        }
                    }).on('keyup', function(evt){
                        if(evt.keyCode === 13) {
                            evt.preventDefault();
                            $self.pepModalUIPlus('open', options, evt.target);
                        }
                    });
                }

                if (options.customCloseEvent) {
                    $self.bind(options.customCloseEvent, function(evt) {
                        evt.preventDefault();
                        $self.pepModalUIPlus('close');
                        _bindKeyup();
                    });
                }

                if (options.detachFromDom) {
                    $self.remove();
                }
            });
        },

        toggleMobile: function (isMobile) {
            var $self = $(this);
            if (isMobile) {
                $self.addClass (MOBILE_UI_CLASS);
            } else {
                $self.removeClass (MOBILE_UI_CLASS);
            }
            $self[PLUGIN_NAME]('repositionModal');
        },

        callRepositionModal: function () {
            var $self = $(this);
            clearTimeout(_repositionTimer);
            _repositionTimer = setTimeout (function () {
                $self.pepModalUIPlus('repositionModal');
            }, 400);
        },

        /**
         * Builds the Modal window
         *
         * @param ops | Parameters for building the Modal Window
         * @param $opener | Element that triggered the dialog open. Receives focus when the dialog is closed.
         */
        open : function(ops, $opener) {
            if (_preventQuickClick) {
                _preventQuickClick = false;
                if (!ops.forceOpen) {
                    return;
                }
            }
            _originalScroll = $('body').scrollTop();
            var $self = $(this),
                contentDiv = '<div id="' + MODAL_CONTENT_DIV_ID + '"></div>';

            // Call close modal to clean posible non-unbinded events affecting the modal
            $self[PLUGIN_NAME]('close');

            //Create a temporary container for the contents.  Allows us to use custom button layouts.
            var content = $('<div />', {
                id : MODAL_PARENT_ID,
                html : contentDiv
            }).addClass('uiPlus').appendTo('body');

            if (ops.htmlSourceId) {
                var htmlContent = $(ops.htmlSourceId).html();
                $('#' + MODAL_CONTENT_DIV_ID).empty().append(htmlContent);
            } else {
                $('#' + MODAL_CONTENT_DIV_ID).empty().append($self.html());
            }

            if (ops.isForm === true) {
                // store the html to append back to the original DOM element later
                _tempHtmlStorage = $self.html();
                // remove duplicate html from original DOM element as it will affect form functionality
                $self.html('');

                _originalDom = $self;
            }

            //Removes any loaded Loading Animation
            if ($(MODAL_LOAD_DIV).length > 0 ) {
                $self.pepModalUIPlus('removeLoadingAnimation');
            }

            //If no buttons are required, do not build the button pane
            if (ops.closeButton !== null  || ops.actionButtons !== null) {
                $self.pepModalUIPlus('setupTheButtonPane', ops);
            }

            //Open the Modal
            $(MODAL_PARENT).dialog(ops);

            //Accessbility tags
            //Per SSB Bart (WDW-172989), role=dialog (added by JQuery UI) should be
            //removed from all modals.  "...It traps the arrow keys so that the up and down keys
            //visually scroll content on the page and JAWS remains silent, making it impossible for screen
            //reader users to read the content inside the dialog. Removing role=dialog from all modal
            //dialogs will help fix this issue."
            $(MODAL_WRAPPER_CLASS).attr('role', null)
                .prepend('<span class="accessibleText">Beginning of Dialog Content</span>')
                .append('<span class="accessibleText">End of Dialog Content</span>');

            //PRO-198974 adding aria-hidden to be true when the modal is opened. This prevents the user from
            //reading content in the background using JAWS
            $('#pageContainer').attr('aria-hidden', true);

            if (ops.title === null || typeof ops.title === "undefined") {
                $(".ui-dialog-titlebar").remove();
            }

            $('.' + CLOSE_MODAL_SELECTOR).bind('click.' + PLUGIN_NAME, function(e){
                e.preventDefault();
                $self[PLUGIN_NAME]('close', ops);
                if (_preferredView !== 'mobile') {
                    $opener = $opener || $(ops.dialogLauncher);
                    // (for keyboard users) Timeout so focus will be done after key up event is fired, if not, modal
                    // closes and opens up again because the focus is being assigned to the dialogLauncher element.
                    window.setTimeout(function() {
                        $opener.focus();
                    }, 100);
                }
                $self.trigger('modal-closing');
            });

            $(MODAL_PARENT).find('[data-plugins]').pepAutoPlugin();

            $(window).resize(function(){
                $self.pepModalUIPlus('callRepositionModal');
            });

            if (ops.backgroundClose) {
                $('#modalPaddingLayer').bind('click.' + PLUGIN_NAME, function(e) {
                    if(e.target === this) {
                        $self[PLUGIN_NAME]('close', ops);
                    }
                });
            }

            // remove once IE 10/11 issue is resolved
            if (ops) {
                ops.useAnimations = false;
            }

            if (ops.useAnimations && !Modernizr.touch) {
                $('<div />').addClass('modalGradientBg').appendTo($('.ui-widget-overlay'));
                $('.modalGradientBg').addClass('modalEntryAnimation');
                $('.ui-dialog').addClass('modalEntryAnimation');
            } else {
                $('<div />').addClass('modalGradientBg').appendTo($('.ui-widget-overlay')).show();
                if (Modernizr.cssgradients) {
                    $('.modalGradientBg').css('opacity', '1');
                }
            }

            $.fn.pepModalUIPlus.isOpen = true;
            $self.trigger(ops.openedEvent, $opener);
            $self.pepModalUIPlus('repositionModal');

            _launcher = $opener || ops.dialogLauncher;

            if (ops.skipFocus === false) {
                $(_launcher).focus();
            }

            // Adding classes for Delta modal (User story DLT-7230)
            // this classes only exists in admissions module only
            var $deltaClose = $('.delta-close');
            var $deltaArrow = $('.delta-arrow-left');

            if ($deltaClose.is(':visible') || $deltaArrow.is(':visible')) {
                $('.modalGradientBg').addClass('delta-modal');
            }

            $(MODAL_PARENT).find('[name^="' + ANALYTICS_PREFIX + '"]')
                .on('click', function(evt) {
                var analyticsLinkId = $(evt.target).closest('[name^="' + ANALYTICS_PREFIX + '"]')
                    .attr('name');
                if (analyticsLinkId && analyticsLinkId.indexOf(ANALYTICS_PREFIX) > -1) {
                    analyticsLinkId = analyticsLinkId.substr(ANALYTICS_PREFIX.length);
                    ops.isModalButton = true;
                    ops.analytics = null;
                    ops.analytics = {
                        elementName: analyticsLinkId,
                        model: {
                            linkId: analyticsLinkId,
                            trackingType: 'customLink'
                        }
                    };
                    $self.pepModalUIPlus('sendAnalytics', ops, $opener);
                    ops.analytics = null;
                    ops.isModalButton = false;
                }                                        
            });

            // Send analytics, options check is in the method below
            $self.pepModalUIPlus('sendAnalytics', ops, $opener);
        },
        /**
         * Send analytics attached to the modal in its config
         * See: https://wiki.wdpro.wdig.com/x/hpPAB for the model
         */
        sendAnalytics: function(ops, opener) {
            // If an analytics object was sending to the modalUIPlus plugin
            var analyticsOps = ops.analytics && ops.analytics.elementName && ops.analytics.model;

            // If an analytics object wasn't sending to the modalUIPlus plugin,
            // verify if the opener link brings in its name attribute
            // the value to send to analytics endpoint (if its name contains &lid=)
            var openerNameAttr = opener && opener.attributes &&
                opener.attributes.getNamedItem('name');
            var openerAnalyticsLinkId = openerNameAttr &&
                opener.attributes.getNamedItem('name').value &&
                opener.attributes.getNamedItem('name').value.indexOf(ANALYTICS_PREFIX) > -1 ?
                // remove the &lid= part of the name
                opener.attributes.getNamedItem('name').value.substr(ANALYTICS_PREFIX.length)
                : null;

            if ((analyticsOps || openerAnalyticsLinkId) &&
                WDPRO &&
                WDPRO.Analytics &&
                WDPRO.Analytics.Framework
            ) {
                if (ops.isModalButton && ops.isModalButton === true) {
                    ops.analytics.model.linkId = openerAnalyticsLinkId + ops.analytics.model.linkId;
                }

                var analyticsElement = analyticsOps ?
                    ops.analytics.elementName
                    : openerAnalyticsLinkId;
                var analyticsModel = analyticsOps ?
                    ops.analytics.model
                    : { linkId: openerAnalyticsLinkId, trackingType: 'customLink' };

                WDPRO.Analytics.Framework.trackElement(
                    analyticsElement,
                    analyticsModel
                );
            }
        },
        /**
         * Function checks if window has a scroll bar
         * Works with getScrollbarWidth to set padding while modals are open
        */
        checkScrollBar: function() {
            if ($(document).height() > $(window).height()) {
                return true;
            } else {
                return false;
            }
        },
        /**
         * Function checks scrollbar width
         * Assumption: Scrollbar is same in elements and window
         * If testing proves assumption incorrect them this function will be removed otherwise it works
         * http://stackoverflow.com/questions/13382516/getting-scroll-bar-width-using-javascript
        */
        getScrollbarWidth: function() {
            var outer = document.createElement("div");
            outer.style.visibility = "hidden";
            outer.style.width = "100px";
            outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

            document.body.appendChild(outer);

            var widthNoScroll = outer.offsetWidth;
            // force scrollbars
            outer.style.overflow = "scroll";

            // add innerdiv
            var inner = document.createElement("div");
            inner.style.width = "100%";
            outer.appendChild(inner);

            var widthWithScroll = inner.offsetWidth;

            // remove divs
            outer.parentNode.removeChild(outer);

            return widthNoScroll - widthWithScroll;
        },
        buildScrollWindow: function() {
            $self = $(this);
            var css = {'overflow': 'hidden'};
            if(!Modernizr.touch && _hasScrollBar) {
                if(_scrollBarWidth !== undefined){
                    css['margin-right'] = _scrollBarWidth;
                } else {
                    _scrollBarWidth = $self.pepModalUIPlus('getScrollbarWidth');
                    css['margin-right'] = _scrollBarWidth;
                }
            }
            $('body').css(css);
            $(MODAL_WRAPPER_CLASS).wrap('<div id="' +  MODAL_BACKGROUND + '"><div id="modalPaddingLayer"></div></div>');
        },
        /**
         * Dynamically creates the Button Container and populates with passed in HTML
         * @param btns | Array of Button HTML
         */
        setupTheButtonPane : function(ops) {
            var closeButton,
                defaultSettings = {
                    'accessibleText': '- closes modal',
                    'showAccessibleText': true
                },
                close = $.extend(true, {}, ops.closeButton),
                $self = $(this);

            $('<div />', {
                id : BUTTON_PARENT_ID,
                'class': BUTTON_PARENT_CLASS
            }).appendTo($(MODAL_PARENT));

            $(BUTTON_PARENT).append(_horizontalSeparator);

            $('<div />', {
                'class' : BUTTONS
            }).appendTo($(BUTTON_PARENT));

            if (ops.footerText !== null) {
                $('<span />', {
                    id: FOOTER_TEXT_CONTAINER,
                    html: ops.footerText
                }).appendTo($(BUTTON_PARENT));
            }

            if (!ops.closeButtonBefore) {
                if (ops.actionButtons !== null) {
                    $(BUTTONS_CONTAINER).append(ops.actionButtons);
                }
            }

            if (!$.isEmptyObject(close)) {
                close = $.extend({}, defaultSettings, close);

                if (close.hasOwnProperty('attrsButton')) {
                    close.attrsButton = _objectToHtmlAttrs(close.attrsButton);
                }

                if ($.type(ops.closeButton) === 'object'
                    && $.type(ops.closeButton.extendsA11y) === 'object'
                ) {

                    var extendsA11yOps = ops.closeButton.extendsA11y;

                    if (extendsA11yOps.hasOwnProperty('attrsLabel')) {
                        close.extendsA11y.attrsLabel = _objectToHtmlAttrs(extendsA11yOps.attrsLabel);
                    }

                    if (extendsA11yOps.hasOwnProperty('attrsDescription')) {
                        close.extendsA11y.attrsDescription = _objectToHtmlAttrs(extendsA11yOps.attrsDescription);
                    }
                }

                closeButton = Mustache.to_html(_closeButtonTemplate, close);

                closeButton = $self.hasClass(MOBILE_UI_CLASS)
                    ? '<span class="pillLinkWrapper">' + closeButton + '</span>'
                    : closeButton;

                if (close.position === 'last') {
                    $(BUTTONS_CONTAINER).append(closeButton);
                } else {
                    $(BUTTONS_CONTAINER).prepend(closeButton);
                }
            }

            if (ops.closeButtonBefore) {
                if (ops.actionButtons !== null) {
                    $(BUTTONS_CONTAINER).append(ops.actionButtons);
                }
            }
        },
        /**
         * Adds the Loading Animation Modal Window
         */
        loadingAnimation: function(useAnimation) {
            var $self = this;

            if ($(MODAL_PARENT).length > 0) {
                $self[PLUGIN_NAME]('close');
            }

            $('<div />', {
                id: MODAL_LOAD_DIV_ID
            }).appendTo('body');

            $(MODAL_LOAD_DIV).dialog(COMMON_SETTINGS);
            $(".ui-dialog-titlebar").remove();

            if (useAnimation !== undefined && useAnimation && !Modernizr.touch) {
                $('<div />').addClass('modalGradientBg').appendTo($('.ui-widget-overlay'));
                $('.modalGradientBg').addClass('modalEntryAnimation');
                $('.ui-dialog').addClass('modalEntryAnimation');
            } else {
                $('<div />').addClass('modalGradientBg').appendTo($('.ui-widget-overlay')).show();
                if (Modernizr.cssgradients) {
                    $('.modalGradientBg').css('opacity', '1');
                }
            }
        },
        /**
         * Removes the Loading Modal Window
         */
        removeLoadingAnimation: function() {
            $(this)[PLUGIN_NAME]('close');
            $(MODAL_LOAD_DIV).remove();
        },
        /**
         * Fires when modal window opens up.  Checks the height / width and rebinds elements inside modal
         */
        openModalFunctions: function() {
            $('#pageContainer').addClass('coveredByModal');
            var modalHeight = $(MODAL_WRAPPER_CLASS).height(),
                viewPortHeight = $(window).height(),
                $self = $(this);
            _originalWidth = $(MODAL_WRAPPER_CLASS).css ('width');

            $self.pepModalUIPlus('buildScrollWindow');
            $self.pepModalUIPlus('repositionModal');

            $(MODAL_OVERLAY).css('z-index', 10001);
            $self.pepModalUIPlus('setupTabbableActionButtons', function(){
                window.setTimeout (function () {
                    $self.pepModalUIPlus('setA11y');
                }, 1);
            });


        },
        /**
         * Creates a TabIndex for all Actionable Buttons for Keyboard Navigation
         * @param {function} setup
         */
        setupTabbableActionButtons: function(setup) {
            $(BUTTON_PARENT).find('.modalUIPlusButtons > .pillBase').each(function(){
                $(this).attr('tabindex', 0).attr('role', 'button').keyup(function(evt){
                    if(evt.keyCode === 13) {
                        $(this).click();
                    }
                });
            });

            setup();
        },
        /**
         * Keeps Focus inside the Modal Parent
         */
        setA11y: function() {
            var $firstItem = $(MODAL_PARENT +  ' :tabbable:first'),
                $lastItem = $(MODAL_PARENT +  ' :tabbable:last'),
                $self = this;

            if ($(MODAL_TITLE).length > 0){
                $(MODAL_TITLE).attr("tabindex", -1).focus();
            } else if ($(MODAL_PARENT + ' h1').length > 0) {
                $($(MODAL_PARENT + ' h1')[0]).attr('tabindex', '-1');
                $(MODAL_PARENT + ' h1')[0].focus();
            } else {
                $firstItem.focus();
            }

            $(document).bind('keydown', function(e){
                // close on escape key press
                if (e.keyCode === 27) {
                    $self.trigger('modal-closing').pepModalUIPlus('close');
                    _bindKeyup();
                }
                var $focusedItem = $(':focus');

                // get elements again for when the modal has been updated
                $firstItem = $(MODAL_PARENT +  ' :tabbable:first');
                $lastItem = $(MODAL_PARENT +  ' :tabbable:last');

                // when pressing SHIFT+TAB while the first tabbable modal element is focused, move focus to the last element
                if ($focusedItem.is($firstItem) && (e.shiftKey && e.which === 9)) {
                    $lastItem.focus();
                    e.preventDefault();
                // when pressing TAB while the last tabbable modal element is focused, move focus to the first element
                } else if ($focusedItem.is($lastItem) && (!e.shiftKey && e.which === 9)) {
                    $firstItem.focus();
                    e.preventDefault();
                }
            });
        },
        /**
         * Centers the Modal Dialog in the Center of the Viewport
         */
        repositionModal: function() {
            $self = $(this);

            //add check for mobile - fix for [PRO-101565] missing mobile class
            if (_preferredView === 'mobile') {
                $self.addClass(MOBILE_UI_CLASS)
            }

            var clientWidth = document.documentElement.clientWidth;
            var originalWidthWithOutPixels = _originalWidth.replace('px', '');
            var $modalContainer = $(MODAL_WRAPPER_CLASS);

            if ($(BUTTON_PARENT).css('display') !== 'none') {
                $(BUTTON_PARENT).attr('style', '');
            }
            $(MODAL_WRAPPER_CLASS).css ('width', _originalWidth);
            $(MODAL_WRAPPER_CLASS).css ('border-radius', '');
            $(MODAL_WRAPPER_CLASS).css ('overflow', '');
            $(MODAL_WRAPPER_CLASS).css ('height', '');

            if ($self.hasClass(MOBILE_UI_CLASS)) {
                $('#' + MODAL_BACKGROUND).css ('position', 'static');
                $('#' + MODAL_BACKGROUND).css ('overflow', 'visible');
                $('#pageContainer').css ('display', 'none');
                $('body').css({'overflow': 'auto'});
                $(MODAL_WRAPPER_CLASS).addClass(FULL_UI_CLASS);
                $(MODAL_WRAPPER_CLASS).css({'top': 0, 'left': 0, 'width': '100%', '-webkit-border-radius': 0, '-moz-border-radius': 0, 'border-radius':0});
                // Transfer the default css to screen.modalUIPlus.css
                $(BUTTON_PARENT).addClass(MOBILE_UI_CLASS);
                var currentModalWidth = $(MODAL_WRAPPER_CLASS).width(),
                    adjustPaddingWidth = $(MODAL_WRAPPER_CLASS).outerWidth() - currentModalWidth;

                if (adjustPaddingWidth > 0) {
                    $(MODAL_WRAPPER_CLASS).width(currentModalWidth - adjustPaddingWidth);
                }

                var clientHeight = document.documentElement.clientHeight;
                var modalHeightTarget = $(MODAL_WRAPPER_CLASS).height() > clientHeight ? $(MODAL_WRAPPER_CLASS).height() + $(BUTTON_PARENT).height() : '100%';
                if (modalHeightTarget === '100%') {
                    modalHeightTarget = clientHeight;
                }
                $(MODAL_WRAPPER_CLASS).height(modalHeightTarget);
                $(MODAL_OVERLAY).css ('display', 'none');
                if (!_isFullSize) {
                    $('html, body').scrollTop(0);
                    _isFullSize = true;
                }
            } else {
                _isFullSize = false;
                // Check to adjust the width in case it is wider than client
                if ($modalContainer.width() > clientWidth - 100) {
                    $modalContainer.css('width', clientWidth - 80); // 10px padding on each side
                }
                $('#' + MODAL_BACKGROUND).css ('position', 'fixed');
                $('#' + MODAL_BACKGROUND).css ('overflow', '');
                $('#pageContainer').css ('display', '');
                $(MODAL_WRAPPER_CLASS).removeClass(FULL_UI_CLASS);
                var top = 100,
                    viewportHeight = document.documentElement.clientHeight,
                    modalHeight = $(MODAL_WRAPPER_CLASS).height(),
                    left = (document.documentElement.clientWidth - $(MODAL_WRAPPER_CLASS).width()) / 2,
                    paddingHeight = viewportHeight;

                if (left < 0) {
                    left = 0;
                }

                if (modalHeight < (viewportHeight - VIEWPORT_PADDING)) {
                    top = (viewportHeight - modalHeight) / 2;
                } else {
                    paddingHeight = modalHeight + 200;
                }

                $('#modalPaddingLayer').height(paddingHeight);
                $(MODAL_WRAPPER_CLASS).css({'top': top, 'left': left - 6});
                $(MODAL_OVERLAY).css ('display', '');
            }
        },
        /** Check device profile for preferred view and return device **/
        getDevice: function() {
            if (window.WDPRO_DeviceProfiling) {
                return window.WDPRO_DeviceProfiling.preferredView.device;
            }
        },
        /**
         * Allows For the Direct Access to Modal Close event from outside plugins
         */
        close: function(ops) {
            $('#pageContainer').removeClass('coveredByModal');
            $(window).unbind('resize');

            $self = $(this);
            $('#pageContainer').css ('display', '');
            $('body').scrollTop(_originalScroll);
            // add html content back to the original DOM element
            if (_tempHtmlStorage !== null){
                _originalDom.empty().append(_tempHtmlStorage);
                _tempHtmlStorage = null;
            }

            // remove once IE 10/11 issue is resolved
            if (ops) {
                ops.useAnimations = false;
            }

            // Close and destroy jquery dialog plugin
            if (ops === undefined || !ops.useAnimations || Modernizr.touch) {
                $('.modalGradientBg').remove();
                $(MODAL_PARENT).dialog('close');
                $(MODAL_PARENT).dialog('destroy');

                // Unbind all events added by the plugin
                $(this).unbind('.' + PLUGIN_NAME);
                // Set the modal status flag to close
                $.fn.pepModalUIPlus.isOpen = false;
            } else {
                $('.modalGradientBg').addClass('modalExitAnimation');
                $('.ui-dialog').addClass('modalExitAnimation').one('webkitAnimationEnd animationend', function(){
                    $('.modalGradientBg').remove();
                    $(MODAL_PARENT).dialog('close');
                    $(MODAL_PARENT).dialog('destroy');
                    // Unbind all events added by the plugin
                    $(this).unbind('.' + PLUGIN_NAME);
                    // Set the modal status flag to close
                    $.fn.pepModalUIPlus.isOpen = false;
                });
                if (!Modernizr.csstransitions) {
                    $(MODAL_PARENT).dialog('close');
                    $(MODAL_PARENT).dialog('destroy');
                }
            }

            //PRO-198974 removing aria-hidden that was added when modal was opened.
            $('#pageContainer').attr('aria-hidden', false);
        },
        /**
         * Teardown the plugin
         */
        destroy : function() {
            return this.unbind('.' + PLUGIN_NAME);
        }
    });
})(jQuery);
/*!
 *  jQuery version compare plugin
 *
 *  Usage:
 *    $.versioncompare(version1[, version2 = jQuery.fn.jquery])
 *
 *  Example:
 *    console.log($.versioncompare("1.4", "1.6.4"));
 *
 *  Return:
 *    0 if two params are equal
 *    1 if the second is lower
 *   -1 if the second is higher
 *
 *  Licensed under the MIT:
 *  http://www.opensource.org/licenses/mit-license.php
 *  
 *  Original code and tests: https://github.com/nobuf/jQuery-version-compare-plugin
 *
 *  Copyright (c) 2011, Nobu Funaki @zuzara
 */
(function($) {
    function normalize(version) {
        return $.map(version.split('.'), function(value) {
            return parseInt(value, 10);
        });
    }
    $.versioncompare = function (version1, version2) {
        if ('undefined' === typeof version1 || 'undefined' === typeof version2) {
            throw new Error("$.versioncompare needs two parameters.");
        }

        if (version1 === version2) {
            return 0;
        }

        var v1 = normalize(version1);
        var v2 = normalize(version2);
        var len = Math.max(v1.length, v2.length);

        for (var i = 0; i < len; i++) {
            v1[i] = v1[i] || 0;
            v2[i] = v2[i] || 0;
            if (v1[i] === v2[i]) {
                continue;
            }
            return v1[i] > v2[i] ? 1 : -1;
        }

        return 0;
    };
}(jQuery));
(function($) {
    /**
     * This is a shim to restore HTML in the dialog title
     * jquery.pepModalUIPlus.js sends along html but jquery 1.10+
     * will escape it and render as text. This shim restores that
     * functionality
     * Approach proposed by "Nguyen, Andrew"
     */

    // if jQuery UI version is >= 1.10.0, then execute the code.
    if (typeof $.versioncompare === 'function' && $.versioncompare($.ui.version, '1.10.0') !== -1) {
        $.widget('ui.dialog', $.extend({}, $.ui.dialog.prototype, {
            _title: function(title) {
                if (!this.options.title) {
                    title.html('');
                } else {
                    title.html(this.options.title);
                }
            }
        }));
    }
})(jQuery);
/**
 * Link Generator
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #17 $
 */

(function($) {
    var constants = {
        patterns: {
            protocol: /http{1}s?:\/\/[a-z.0-9\-]+(\/{1}.+)/
        },
        slash : '/'
    };

    PEP = PEP || {};
    PEP.link = PEP.link || {};

    //The Routing and Redirect (Varnish) layer will be responsible for setting
    //a header in the request X-Disney-Internal-BaseUrl which includes the
    //domain and language path element as appropriate.
    //see PEP_Controller_Action_Helper_BaseUrlHeader
    PEP.Config = PEP.Config || {};
    PEP.Config.BaseUrlHeader = PEP.Config.BaseUrlHeader || {};

    PEP.link.Generator = PEP.link.Generator || {

        build: function(urlParam) {

            //PEP.config.baseUrl is set in jsConfig.php (view helper)
            var baseUrl = PEP.Config.BaseUrlHeader;

            //If internationalizationLanguageToggle release toggle is unselected then we return the given url
            if (PEP.util.getOption(PEP, 'Config.Toggles.Release.internationalizationLanguageToggle', false) !== true) {
                return urlParam;
            }

            var absolutePattern = new RegExp(constants.patterns.protocol);

            if (absolutePattern.test(urlParam) || typeof baseUrl !== 'string') {
                return urlParam; // the given url is an absolute URL
            } else { // the given url is a query parameter
                return this.buildURL(baseUrl, urlParam);
            }
        },

        buildURL: function(baseUrl, param) {
            //If baseUrl has a "slash" char in the last position then we remove it
            baseUrl = (baseUrl.substr(baseUrl.length - 1) === constants.slash) ?
                baseUrl.substr(0, baseUrl.length - 1) : baseUrl;

            return baseUrl + param;
        },

        /**
         * This function takes the URL returned by the service and reconstructs it
         * for the environment. This is because some elements are being returned from the
         * service with abosulte urls to production which breaks lower environments.
         *
         * @param urlParam the url as returned by the service for this item
         * @returns {*} the url processed
         */
        buildWithEnvironment: function(urlParam) {
            //PEP.config.baseUrl is set in jsConfig.php (view helper)
            var baseUrl = PEP.Config.BaseUrlHeader,
                absolutePattern = new RegExp(constants.patterns.protocol),
                matches;

            // try to make absolute url to relative by removing base url
            if (absolutePattern.test(urlParam)) {
                if (urlParam.indexOf(baseUrl) === 0) {
                    urlParam = urlParam.replace(baseUrl, '/');
                } else {
                    urlParam = this.languageRemove(urlParam);
                }
            } else {
                urlParam = this.languageRemove(urlParam);
            }

            // try to make absolute url to relative
            matches = absolutePattern.exec(urlParam);
            if (matches && matches.length >= 2 && baseUrl && typeof baseUrl === 'string') {
                return this.buildURL(baseUrl, matches[1]);
            } else if (urlParam) {
                return this.build(urlParam);
            }
        },

        /**
         * This function search for the /lang/ and replace the first part of
         * the url to convert to relative.
         *
         * @param urlParam the url as returned by the service for this item
         * @returns {*} the url processed
         */
        languageRemove: function(urlParam) {
            var urlLocale = PEP.Config.BaseUrlLocale,
                languageParam,
                langPosition;

            if (urlLocale) {
                languageParam = '/' + urlLocale + '/';
                langPosition = urlParam.indexOf(languageParam);
                if (langPosition !== -1) {
                    urlParam = urlParam.replace(urlParam.substring(0, langPosition + languageParam.length), '/');
                }
            }

            return urlParam;
         }
    };

})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #28 $
 */

(function($) {
    PEP = PEP || {};
    PEP.translate = PEP.translate || {};
    
    var dependency = null,
        linkGenerator = null;

    /**
     * Helper for translating text on the JS side
     * Contains classes/functions to ease the process of displaying text in the appropriate language.
     */
    PEP.translate.Translator = PEP.translate.Translator || {
        /**
        * Object store to identify language keys already translated to avoid
        * duplicated lookups to /utils/translate/
        * {Object}
        */
        translations: {},

        /**
        * Constructs the base id to store the translate keys in current PEP.translate namespace
        * and in sessionStorage to avoid collision between brands.
        * Id is contructed using SiteID + Region + Language + Affiliations.
        * {string}
        */
        baseId: 'translate.' +
            (PEP.util.getOption(PEP, 'Config.SiteId', false) ? ('_' + PEP.Config.SiteId) : '') +
            (PEP.util.getOption(PEP, 'Config.Region', false) ?
                ('_' + PEP.Config.Region) : (PEP.util.getOption(PEP, 'Config.CurrentRegion', false) ?
                    ('_' + PEP.Config.CurrentRegion) : 'notset')) +
            (PEP.util.getOption(PEP, 'Config.PreferredLanguage', false) ? ('_' + PEP.Config.PreferredLanguage) : '') +
            (PEP.util.getOption(PEP, 'Config.Affiliations', false) ? ('_' + PEP.Config.Affiliations) : ''), 

        /**
         * Loads translations from the webserver for the given keys and will
         * execute the callback function (if provided).  This will only make
         * calls to load transactions for keys that have not already been
         * loaded.
         *
         * @param Array[String] keys The array of keys to load translations for.
         * @param Function() callback A no-arg callback function to execute when
         *                            the keys are loaded.  The function will be
         *                            called when this function is done
         *                            regardless of whether this needed to
         *                            actually make a service call or whether
         *                            the service call had errors.
         */
        loadTranslations: function(keys, callback) {
            var self = this;
            var missing = [];
            var i, len, key;

            var done = function() {
                if (callback) {
                    callback();
                }
            };

            if (keys) {

                if (!$.isArray(keys)) {
                    keys = [keys];
                }

                for (i = 0, len = keys.length; i < len; i++) {
                    key = keys[i];
                    if (!this.getTranslation(key)) {
                        missing.push(key);
                    }
                }

                if (missing.length > 0) {
                    // prepend the locale to the url to avoid the problem where, for example,
                    // a POST to /en_CA/utils/translate gets redirected to a GET to /utils/translate
                    // @todo remove when/if the redirection logic is fixed
                    var urlString = '/utils/translate';
                    
                    try {
                        /*
                         * I couldn't set this inicialization on top/init of the
                         * script because the most of the time, this plugin is loaded
                         * before of PEP.link.Generator and $.pepAutoPlugin, and if
                         * we change the order on minify-config, a lot of others plugins
                         * are broken.
                         * And this "Try-Catch" is necessary because some Qunit fails
                         * when PEP.Dependency ar not defined, and the script are
                         * including this plugin.
                         * If we get an exception, it will use the old builder.
                         */
                        if (dependency === null) {
                            dependency = PEP.Dependency.init('pep.translate.js');
                            linkGenerator = dependency.uses('PEP.link.Generator');
                        }
                        
                        urlString = linkGenerator.build(urlString);
                        
                    } catch (e) {
                        if (typeof $.cookiejar === 'function') {
                            var cookieJar = $.cookiejar('localeCookie');
                            var locale = cookieJar.getCookie('contentLocale');
                            if (PEP.util.getOption(
                                PEP,
                                'Config.Toggles.Release.internationalizationLanguageToggle',
                                false
                            ) &&
                                locale &&
                                locale !== 'en_US'
                                ) {
                                urlString = '/' + locale + urlString;
                            }
                        }
                    }

                    $.ajax({
                        url: urlString,
                        dataType: 'json',
                        type: 'POST',
                        data: {keys: missing.join(',')},
                        success: function(translations) {
                            if (translations) {
                                self.addTranslations(translations);
                            }

                            done();
                        },
                        error: function() {
                            done();
                        }
                    });
                } else {
                    done();
                }
            } else {
                done();
            }
        },

        getTranslation: function(key) {
            var lookupKey = this.baseId + '.' + key,
                result = this.translations[lookupKey];
            if (!result) {
                if (sessionStorage) {
                    try {
                        result = sessionStorage.getItem(lookupKey);
                    } catch (e) {
                        // Ignore; we will load via AJAX
                    }
                }
            }

            // Sanity check so that null always means no result.
            if (!result) {
                result = null;
            }

            return result;
        },

        /**
         * Function: addTranslations
         * Adds translations to the translation map. Will overwrite any keys that are the same
         * with the new values provided in the "translations" parameter.
         *
         * Parameters:
         *     translations - (Object) Key/value pair of translation keys and the copy that should be used for the key
         */
        addTranslations: function(translations) {
            var self = this,
                loadedTranslations = {};
            
            $.each(translations, function(key, value) {
                key = self.baseId + '.' + key;
                loadedTranslations[key] = value;
                if (sessionStorage) {
                    try {
                        sessionStorage.setItem(key, value);
                    } catch (e) {
                        // ignore; we simply cannot store it for the session.
                    }
                }
            });
            $.extend(this.translations, loadedTranslations);
        },

        /**
         * Function: translate
         * Translates a key into the proper text from the translations collection.
         *
         * Replacements expect the translated string to have the replacement
         * key directly preceeded and proceeded by a '%' character.  Example:
         *   -- Translated String: "See %name% %verb%.  %Verb% %name% %verb%."
         *   -- Replacements: {
         *                      "verb": "code",
         *                      "Verb": "Code",
         *                      "name": "Bob"
         *                    }
         *   -- Returns: "See Bob code.  Code Bob code."
         *
         * Parameters:
         *     key - (String) Key to look up from the translation table
         *     replacements - (Optional: Object) JSON Object map that defines the
         *                    key / value pair to replace from the resulting
         *                    translation.
         *
         * Returns:
         *     The translated copy to use in place of the key
         */
        translate: function(key, replacements) {
            var translation = this.getTranslation(key) || key;

            if (replacements) {
                $.each(replacements, function(name, value) {
                    var result = translation;
                    var replaced = true;
                    var temp;

                    // Use a sanity check to avoid an infinite loop in case some
                    // fool replaces a token with itself.
                    var heartbeat = 0;
                    while (replaced && heartbeat++ < 100) {
                        temp = result.replace("%" + name + "%", value);

                        replaced = result !== temp;
                        result = temp;
                    }

                    translation = result;
                });
            }

            return translation;
        },
        
        /**
         * Function: simpleTranslate
         * Translates a key into the proper text from the translations collection.
         * Iterates over the replacements IN ORDER, replacing the %s macro for the value
         * in the replacements JSON object
         * This method tries to resolve the compatibility issue caused by loc strings
         * shared with PHP
         * 
         * Parameters:
         *     key - (String) Key to look up from the translation table
         *     replacements - (Optional: Object) JSON Object map that defines the
         *                    key / value pair to replace from the resulting
         *                    translation, 
         *                    Not
         *
         * Returns:
         *     The translated copy to use in place of the key
         */
        simpleTranslate: function(key, replacements) {
            var result = this.getTranslation(key) || key;
            if (replacements) {
                $.each(replacements, function(name, value) {          
                    result = result.replace("%s", value);
                });
            }
            
            return result;
        }
    };
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #18 $
 */

/**
 * JS utility to open an interstitial modal when a guest clicks on a link or submits a form that
 * would take them off-site.
 */
(function($) {
    if (PEP.interstitial === undefined) {
        PEP.interstitial = {};
    }
    var self = PEP.interstitial,
        TRIGGER_CLASS = 'triggerInterstitialModal',
        MODAL_CONTENT_ELEMENT = '#interstitialModalContent',
        PEP_MODAL_ELEMENT = '#modalDialogDivContainer',
        MODAL_CLOSE_ACTION = 'close',
        FORM_SUBMIT_ACTION = 'submit',

        interstitialTypeMap = [
            {
                triggerClassname: 'interstitialModalLanguage',
                contentClassname: 'languageInterstitialContent',
                titleType: 'interstitialLanguageTitle'
            },
            {
                triggerClassname: 'interstitialModalThirdParty',
                contentClassname: 'thirdPartyInterstitialContent',
                titleType: 'interstitialThirdPartyTitle'
            },
            {
                triggerClassname: 'interstitialModalThirdPartyTickets',
                contentClassname: 'thirdPartyTicketsInterstitialContent',
                titleType: 'interstitialThirdPartyTicketsTitle'
            },
            {
                triggerClassname: 'interstitialModalThirdPartyHotels',
                contentClassname: 'thirdPartyHotelsInterstitialContent',
                titleType: 'interstitialThirdPartyHotelsTitle'
            },
            {
                triggerClassname: 'interstitialModalTermsAndConditions',
                contentClassname: 'termsAndConditionsInterstitialContent',
                titleType: 'interstitialTermsAndConditionsTitle'
            },
            {
                triggerClassname: 'interstitialNewWindowConfirmation',
                contentClassname: 'newWindowConfirmationInterstitialContent',
                titleType: 'interstitialNewWindowConfirmationTitle'
            }
        ],
        _repositionTimer;

    /**
     * Initializes event handlers for links/forms that require an interstitial modal to be displayed
     */
    self.init = function () {
        // Bind any elements with trigger class (Delegate)
        $('body').delegate('a.' + TRIGGER_CLASS + ', a.' + TRIGGER_CLASS.toLowerCase(), 'click', function (e) {

            var $link = $(this),
                continueCallback;

            // If the link is supposed to open a new window or a modal, have the continue button
            // trigger a jquery click event, instead of going to the URL directly
            if ($link.hasClass('jsLink')) {
                continueCallback = function(e) {
                    $link.trigger('click', true);
                    $(MODAL_CONTENT_ELEMENT).pepModalUIPlus('close');
                    e.preventDefault();
                };
            }

            self.openInterstitial(this, continueCallback);
            e.preventDefault();
            return false;
        })
        .delegate('form.' + TRIGGER_CLASS + ', form.' + TRIGGER_CLASS.toLowerCase(), 'submit', function (e) {
            var $form = $(this),
                isFormInsideAModal = $form.closest(PEP_MODAL_ELEMENT).length !== 0,
                continueCallback = function(e) {
                    // Remove trigger class from the form to prevent us from re-opening the interstitial
                    $form.removeClass(TRIGGER_CLASS)
                        .removeClass(TRIGGER_CLASS.toLowerCase())
                        .trigger(FORM_SUBMIT_ACTION, true)
                        .addClass(TRIGGER_CLASS);
                    $(MODAL_CONTENT_ELEMENT).pepModalUIPlus(MODAL_CLOSE_ACTION);
                    e.preventDefault();
                };

            self.openInterstitial(this, continueCallback);

            // If the form is owned by a modal that's currently being displayed,
            // remove it from the DOM, so that the modal's close() function doesn't
            // purge events associated with the form
            // ... and attach the form to the interstitial modal,
            // so the form gets purged when that modal is closed.
            if (isFormInsideAModal) {
                $form.detach();
                $('#modalDialogDivContainer').append($form.hide().removeClass(TRIGGER_CLASS));
            }

            e.preventDefault();
            return false;
        });
    };

    /**
     * Opens the interstitial modal to inform guests that they are leaving a disney-controlled site
     * @param targetElement - Element that triggered the modal
     * @param continueCallback [optional] - Callback to execute if the guest clicks the continue button.
     */
    self.openInterstitial = function(targetElement, continueCallback) {
        var $this = $(targetElement),
            href = $this.attr("href") || "#",
            target = $this.attr("target") || "",
            $interstitialObj = $(MODAL_CONTENT_ELEMENT),
            translations = $.parseJSON(PEP.util.base64Decode($interstitialObj.data('translations'))),
            title = '',
            classesTargetElement = $(targetElement).attr('class').split(' '),
            classKeyContent = '',
            buttonText = translations.interstitialLinkText,
            buttonClose = translations.interstitialCloseText;

        classesTargetElement.forEach(function(element) {
            if (element.indexOf('interstitial_') !== -1) {
                // it will be used as content key for the triggered modal
                classKeyContent = element;
            }
        });

        // Check for target attribute
        if (target !== "") {
            target = ' target="' + target + '"';
        }
        // Create Pill Button
        var continueButton = $('<a class="pillLink" id="interstitialModalContent-continue"' +
            target +
            ' href="' + href + '" data-plugins="[&quot;pepActiveStyleSupport&quot;]">' +
            '<span class="pillBase primary ">' +
            '<span class="gradient">' +
            '<span class="buttonText">' + buttonText + '</span>' +
            '</span>' +
            '</span></a>');

        if (continueCallback) {
            continueButton.bind('click', continueCallback);
        }
        if (target !== "") {
            continueButton.bind('click', function(e) {
                $(e.target).closest(".modalUIPlusButtons").find(".closeModalWindow").trigger("click");
            });
        }

        var createModal = function (title) {
            var modalSettings = {
                closeButton: {
                    'label': buttonClose,
                    'category': 'secondary'
                },
                title: title,
                actionButtons: continueButton,
                closeButtonBefore: true,
                customClass: 'interstitialModal'
            };
            $interstitialObj.pepModalUIPlus(modalSettings, true);
            self.repositionModal($interstitialObj);
            $(window).resize(function () {
                clearTimeout(_repositionTimer);
                _repositionTimer = setTimeout(function () {
                    self.repositionModal($interstitialObj);
                }, 400);
            });
        };

        if (classKeyContent !== '') {
            var interstitialKeysObject = {
                    'title': 'interstitial.' + classKeyContent + '.title',
                    'message': 'interstitial.' + classKeyContent + '.message'
                },
                translator = PEP.translate.Translator;

            //remove to not increase the custom interstitial elements in the DOM
            $(MODAL_CONTENT_ELEMENT + ' .dynamicInterstitial').remove();
            $(MODAL_CONTENT_ELEMENT + ' div').hide();

            //load translations for the triggered interstitial
            translator.loadTranslations([interstitialKeysObject.title, interstitialKeysObject.message],
                function () {
                    var message =  translator.translate(interstitialKeysObject.message),
                        title =  translator.translate(interstitialKeysObject.title),
                        customModal = '<div class="' + classKeyContent + 'Content dynamicInterstitial">' +
                            message + '</div>';
                    $interstitialObj.append(customModal);
                    createModal(title);
                });
        } else {
            // Check type of modal message to show based on link class
            for (var i = 0; i < interstitialTypeMap.length; i++) {
                if ($this.hasClass(interstitialTypeMap[i].triggerClassname) ||
                    $this.hasClass(interstitialTypeMap[i].triggerClassname.toLowerCase())) {
                    $('.' + interstitialTypeMap[i].contentClassname).show();
                        title = translations[interstitialTypeMap[i].titleType];
                } else {
                    $('.' + interstitialTypeMap[i].contentClassname).hide();
                }
            }
            $('.dynamicInterstitial').hide();
            createModal(title);
        }
    };


    self.repositionModal = function(interstitialObj) {
        interstitialObj.pepModalUIPlus('repositionModal');
        if (Modernizr.touch === true) {
            $('#tmp_overlay_background').css({
                'position': 'fixed'
            });
        }
    };

    self.init();
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * File: disney.categoryAutocomplete.js
 * Widget extended from jquery.ui.autocomplete
 *
 * http://jqueryui.com/demos/autocomplete/
 */
/*global Mustache*/
(function($) {

    if ($.ui && $.ui.menu && !!$.ui.menu.prototype) {
        /*
         * Slightly modify $.ui.menu functionality to check for onlyMoveUIMenuItems option.
         * If the option is falsy just run the original function
         * If true run the modified version with this change:
         * - next = this.activeMenu.find( this.options.items )[ filter ]();
         * + next = this.activeMenu.find( ".ui-menu-item" )[ filter ]();
         */
        var origUIMenu_move = $.ui.menu.prototype._move;

        $.ui.menu.prototype._move = function( direction, filter, event ) {

            if (!this.options.onlyMoveUIMenuItems) {
                origUIMenu_move.apply(this, arguments);
                return;
            }

            var next;
            if (this.active) {
                if (direction === "first" || direction === "last" ) {
                    next = this.active
                        [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                        .eq( -1 );
                } else {
                    next = this.active
                        [ direction + "All" ]( ".ui-menu-item" )
                        .eq( 0 );
                }
            }
            if (!next || !next.length || !this.active ) {
                next = this.activeMenu.find( ".ui-menu-item" )[ filter ]();
            }

            this.focus( event, next );
        };

        // widget
        $.widget("disney.categoryAutocomplete", $.ui.autocomplete, {
            options: {
               quickLinksCategoryTitle : '',
               suggestedTermsCategoryTitle : '',
               formClass : 'searchForm',
               preventClose : false,
               slideToggleSpeed : 100,
               useWebFontIcon : false,
               useAnalyticId : false
            },

            _suggest: function( items ) {
                var self = this;
                if (self.options.isSyndication && self.options.isResponsiveSyndicated) {
                    $('#pageContainerSyndicated').append(this.menu.element.detach());
                } else {
                    $('#pageContainer').append(this.menu.element.detach());
                }
                var ul = this.menu.element.empty();
                this._renderMenu( ul, items );
                this.isNewMenu = true;
                this.menu.option("onlyMoveUIMenuItems", true );
                this.menu.refresh();

                // deactivate category headers
                this.menu.element
                    .find('li.ui-autocomplete-category')
                    .removeClass('ui-menu-item');

                //Overrides the role of the list items
                this._refreshRole();

                // size and position menu
                ul.slideDown(this.options.slideToggleSpeed);
                this._resizeMenu();
                ul.position( $.extend({
                    of: this.element
                }, this.options.position ));

                if (this.options.autoFocus ) {
                    this.menu.next();
                }
            },

            _renderMenu: function(ul, items) {
                var self = this,
                    currentCategory = '',
                    categoryName = '',
                    html = '';

                //Add a class for custom styling
                ul.addClass(self.options.formClass);

                $.each(items, function(index, item) {
                    if (item.category !== currentCategory) {
                        if (item.category === 'suggestedTerm') {
                            categoryName = self.options.suggestedTermsCategoryTitle;
                        } else if (item.category === 'quickLinks') {
                            categoryName = self.options.quickLinksCategoryTitle;
                        }

                        html = '<li class="ui-autocomplete-category ui-state-disabled' + item.className + '">' +
                               categoryName +
                               '</li>';
                        ul.append(html);
                        currentCategory = item.category;
                    }
                    html = '';
                    if (item.icon || item.desc) {
                        self._renderCustomItem(ul, item);
                    } else {
                        self._renderItem(ul, item);
                    }
                });
            },

            _renderCustomItem: function(ul, item) {
                var elementClass = '',
                    centerTop = '',
                    data = {
                        url : item.url || '#',
                        icon : item.icon || '',
                        label : item.label || '',
                        desc : item.desc || '',
                        fontCode: item.webFontCode || ''
                    };

                if (!data.desc || data.desc === 'Null') {
                    data.desc = '';
                    centerTop = ' centerVertically';
                }

                var html = '<a href="' + data.url + '">';

                if (this.options.useWebFontIcon) {
                    html += '<span class="webfont-char ' + data.icon + '">'+ data.fontCode +'</span>';
                } else {
                    html += '<span class="icon ' + data.icon + '"></span>';
                }
                    html += '<div class="details">' +
                            '<div class="label' + centerTop + '">' + data.label + '</div>' +
                            '<div class="description">' + data.desc + '</div>' +
                        '</div>' +
                    '</a>';

                if (item.className) {
                    elementClass = item.className;
                }

                return $('<li></li>')
                        .addClass(elementClass)
                        .data('ui-autocomplete-item', item)
                        .append(html)
                        .appendTo(ul);
            },

            _renderItem: function(ul, item) {
                var elementClass = '';

                if (item.className) {
                    elementClass = item.className;
                }

                var $element = $('<li></li>')
                        .addClass(elementClass)
                        .data('ui-autocomplete-item', item)
                        .addClass(item.category)
                        .append($("<a></a>").html(item.label))
                        .appendTo(ul);

                //add analyticsLinkId attribute to populate c9 on the landing result page when click autosuggested terms
                if (this.options.useAnalyticId) {
                    if (item.analyticsLinkId) {
                        var linkId = item.analyticsLinkId.replace(/[^a-zA-Z0-9_]+/g,'');
                        $element
                            .find('a, span')
                            .attr('analyticsLinkId', linkId);
                    }
                }

                return $element;

            },

            _close: function( event ) {
                if (this.options.preventClose === false &&
                    this.menu.element.is(":visible")
                ) {
                    this.menu.element.slideUp(this.options.slideToggleSpeed);
                    this.menu.blur();
                    this.isNewMenu = true;
                    this._trigger( "close", event );
                }
            },

            _move: function( direction, event) {
                if (!this.menu.element.is(":visible") ) {
                    this.search( null, event );
                    return;
                }
                if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                        this.menu.isLastItem() && /^next/.test(direction) ) {

                    if (!this.isMultiLine ) {
                        this._value( this.term );
                    }

                    this.menu.blur();
                    return;
                }
                this.menu[ direction ]( event );

                //Strip the HTML tags when scrolling
                var text = this.element.val();
                var key = "<quicklink>";

                text = text.replace(/<span class=\"matchingText\">/g, "").replace(/<\/span>/g, "")
                           .replace(/<(\/)?quicklink>/g, "");
                this.element.val(text);
            },

            _refreshRole: function() {
                this.menu.element.children("li.ui-menu-item:has(a)").attr("role", "presentation");
                $("li > a", this.menu.element).attr("role", "option");
            }
        });
        // End widget
    }
    else {
        // widget
        $.widget("disney.categoryAutocomplete", $.ui.autocomplete, {
            options: {
               quickLinksCategoryTitle : '',
               suggestedTermsCategoryTitle : '',
               formClass : 'searchForm',
               preventClose : false,
               slideToggleSpeed : 100,
               useWebFontIcon : false,
               useAnalyticId : false
            },

            _suggest: function( items ) {
                var ul = this.menu.element
                    .empty()
                    .zIndex( this.element.zIndex() + 1 );
                this._renderMenu( ul, items );
                this.menu.deactivate();
                this.menu.refresh();
                //Overrides the role of the list items
                this._refreshRole();

                // size and position menu
                ul.slideDown(this.options.slideToggleSpeed);
                this._resizeMenu();
                ul.position( $.extend({
                    of: this.element
                }, this.options.position ));

                if (this.options.autoFocus ) {
                    this.menu.next( new $.Event("mouseover") );
                }
            },

            _renderMenu: function(ul, items) {
                var self = this,
                    currentCategory = '',
                    categoryName = '',
                    html = '';

                //Add a class for custom styling
                ul.addClass(self.options.formClass);

                $.each(items, function(index, item) {
                    if (item.category !== currentCategory) {
                        if (item.category === 'suggestedTerm') {
                            categoryName = self.options.suggestedTermsCategoryTitle;
                        } else if (item.category === 'quickLinks') {
                            categoryName = self.options.quickLinksCategoryTitle;
                        }

                        html = '<li class="ui-autocomplete-category ' + item.className + '">' +
                               categoryName +
                               '</li>';
                        ul.append(html);
                        currentCategory = item.category;
                    }
                    html = '';
                    if (item.icon || item.desc) {
                        self._renderCustomItem(ul, item);
                    } else {
                        self._renderItem(ul, item);
                    }
                });
            },

            _renderCustomItem: function(ul, item) {
                var elementClass = '', centerTop = '',
                    data = {
                        url : item.url || '#',
                        icon : item.icon || '',
                        label : item.label || '',
                        desc : item.desc || '',
                        fontCode: item.webFontCode || ''
                    };

                if (data.desc === '') {
                    centerTop = ' centerVertically';
                }

                var html = '<a href="' + data.url + '">';

                if (this.options.useWebFontIcon) {
                    html += '<span class="webfont-char ' + data.icon + '">'+ data.fontCode +'</span>';
                } else {
                    html += '<span class="icon ' + data.icon + '"></span>';
                }
                    html += '<div class="details">' +
                                '<div class="label' + centerTop + '">' + data.label + '</div>' +
                                '<div class="description">' + data.desc + '</div>' +
                            '</div>' +
                        '</a>';

                if (item.className) {
                    elementClass = item.className;
                }

                return $('<li></li>')
                    .addClass(elementClass)
                    .data('item.autocomplete', item)
                    .append(html)
                    .appendTo(ul);
            },

            _renderItem: function(ul, item) {
                var elementClass = '';

                if (item.className) {
                    elementClass = item.className;
                }

                var $element = $('<li></li>')
                        .addClass(elementClass)
                        .data('item.autocomplete', item)
                        .addClass(item.category)
                        .append($("<a></a>").html(item.label))
                        .appendTo(ul);

                //add analyticsLinkId attribute to populate c9 on the landing result page when click autosuggested terms
                if (this.options.useAnalyticId) {
                    if (item.analyticsLinkId) {
                        var linkId = item.analyticsLinkId.replace(/[^a-zA-Z0-9_]+/g,'');
                        $element
                            .find('a, span')
                            .attr('analyticsLinkId', linkId);
                    }
                }

                return $element;

            },

            close: function( event ) {
                clearTimeout( this.closing );
                if (this.options.preventClose === false &&
                    this.menu.element.is(":visible")
                ) {
                    this.menu.element.slideUp(this.options.slideToggleSpeed);
                    this.menu.deactivate();
                    this._trigger( "close", event );
                }
            },

            _move: function( direction, event) {
                if (!this.menu.element.is(":visible") ) {
                    this.search( null, event );
                    return;
                }
                if (this.menu.first() && /^previous/.test(direction) ||
                        this.menu.last() && /^next/.test(direction) ) {
                    this.element.val( this.term );
                    this.menu.deactivate();
                    return;
                }
                this.menu[ direction ]( event );

                //Strip the HTML tags when scrolling
                var text = this.element.val();
                var key = "<quicklink>";

                text = text.replace(/<span class=\"matchingText\">/g, "").replace(/<\/span>/g, "")
                           .replace(/<(\/)?quicklink>/g, "");
                this.element.val(text);
            },

            _refreshRole: function() {
                this.menu.element.children("li:(.ui-menu-item):has(a)").attr("role", "presentation");
                $("li > a", this.menu.element).attr("role", "option");
            }
        });
        // End widget
    }
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

/**
 * A plugin to show auto suggestions on a text input using an ajax call.
 * The plugin has to be set on the search box input for it to work properly
 */
(function ($) {
    /*global console: true */
    var pluginName = 'pepSearchAutoSuggestions',
        dependency = PEP.Dependency.init('jquery.pepSearchAutoSuggestions.js'),
        linkGenerator = dependency.uses('PEP.link.Generator'),
        defaultOptions = {
            appendTo : 'body',
            quickLinksCategoryTitle : '',
            suggestedTermsCategoryTitle : '',
            facetsFormSelector : '#searchFacetsForm',
            leftCapSelector : '.leftCap',
            xOffset : 1,
            yOffset : 4,
            minLength : 0,
            modalTempAnchorId : 'answerEngineModalTempAnchor',
            modalWidth : 540,
            modalHeight : 'auto',
            modalClass : 'pepModalCustomClass searchModalWidget',
            modalClassSelector : '.pepModalCustomClass.searchModalWidget',
            modalDialogDivContainer : '#modalDialogDivContainer',
            modalDialogCloseButton : '#modalDialogDivContainer .closeModalWindow',
            modalCloseButtonText : 'Close',
            pageName : 'homepage',
            showQuickLinksFlag : 1,
            quickLinksSearchResultNumber : 1,
            analyticsLinkTypes : {
                "default" : "User",
                "quickLinks" : "QuickLink",
                "suggestedTerm" : "Suggested"
            },
            answerEngineContainerSelector : '#modalDialogDivContainer .resultItemContainer',
            isSyndication : false,
            isResponsiveSyndicated: false,
            logTime : true,
            useWebFontIcon : true,
            useAnalyticId : true,
            categoryValue : '',
            userType : 'GUEST'
        },
        globalId = 'globalSearchQuery',
        searchClassButton = 'search_button',
        globalAnalyticPosition = 'Global',
        secondaryAnalyticPosition = 'Results',
        autosuggestAjaxRequest = null,
        responses = {},
        answerEngineLoading = false,
        WDPRO = window.WDPRO,
        codeMapConfiguration = {
            WDW : {
                patterns : [
                    {
                        pattern : '^([0-9]{10,15}$)',
                        replacement : 'reservation number',
                        excludeUpcomingYears : false
                    }
                ]
            },
            DLR : {
                patterns : [
                    {
                        pattern : '^([0-9]{11,13}$|^[a-z,A-Z]{1}[0-9]{7}$)',
                        replacement : 'reservation number',
                        excludeUpcomingYears : false
                    }
                ]
            },
            DCL: {
                patterns : [
                    {
                        pattern : '^([0-9]{7,16}$)',
                        replacement : 'reservation number',
                        excludeUpcomingYears : false
                    },
                    {
                        pattern : '^([0-9]{4,5}$)',
                        replacement : 'stateroom number',
                        excludeUpcomingYears : true
                    }
                ]
            }
        },
        /**
         * Truncates a string to a maximum of 30 characters leaving words complete.
         * @param {String} str String to be truncated
         * @param {Integer} length Max string length
         */
        truncateString = function(str, length) {

            // The default value cannot be defined in the function definition.
            length = length || 30;

            if (str.length <= length) return str;

            str = str.substr(0, str.lastIndexOf(' ', length));
            return str.concat('...');
        },
        /**
         * Get Widget Options
         * @param options Plugin options.
         */
        getWidgetOptions = function(options) {
            return {
                isSyndication : options.isSyndication,
                useAnalyticId : options.useAnalyticId,
                useWebFontIcon : options.useWebFontIcon,
                isResponsiveSyndicated: options.isResponsiveSyndicated,
                quickLinksCategoryTitle : options.quickLinksCategoryTitle,
                suggestedTermsCategoryTitle : options.suggestedTermsCategoryTitle
            }
        },
        /**
         * Get Search Form Data
         * @param options Plugin options.
         * @param $this Plugin reference.
         */
        getFormData =  function(options, $this) {
            /*
             * Since the search can be made from different pages and platforms (Pepcom, Nemo)
             * we build the pageName request param using the URL. Example
             * Input: /attractions/disneyland/mickeys-house/
             * Output: attractions_disneyland_mickeys-house
             */
            var segments = window.location.pathname.split('/');
            var filteredSegments = segments.filter(function(segment) {
                return segment.length > 0;
            });
            // If there are no segments, that means the SAYT is being made from the home page.
            var pageName = filteredSegments.join('_') || options.pageName;
            var searchCategory = options.categoryValue ?
                    options.categoryValue :
                    $(options.categorySelector).val();

            var formData = {
                'userType' : options.userType,
                'searchQuery': $this.val().trim(),
                'searchCategory': searchCategory,
                'pageName': pageName
            };

            return formData;
        };

    $.pepPlugin(pluginName, {
        init: function (options) {
            options = $.extend(true, {}, defaultOptions, options);
            // For non-Finder pages such as the HomePage we need to add the locale
            // to the search-service endpoint to get the right translated content.
            // See: GIT-31790.
            var searchUrl = '/search/search-service';
            var preferredLanguage = PEP.util.getOption(PEP.Config, 'PreferredLanguage', 'en-us');
            var addLanguagePrefix = !PEP.Config.Finder && preferredLanguage !== 'en-us';
            if (addLanguagePrefix) {
                searchUrl = '/' + PEP.Config.PreferredLanguage + searchUrl;
            }
            // If the siteId was not passed, fallback to the JS-based PEP.Config object
            var siteId = options.siteId || PEP.Config.SiteId,
                sitePrefix = siteId.toUpperCase(),
                serviceUrl = linkGenerator.build(searchUrl),
                isAutosuggestionOnSameDomain = serviceUrl.indexOf(document.domain) !== -1;

            return this.each(function () {
                // set autosuggestions available only on same domain
                if (!options.isSyndication ||
                    (options.isSyndication && options.isResponsiveSyndicated) ||
                    isAutosuggestionOnSameDomain
                ) {
                    var $this = $(this);
                    var widgetOptions = getWidgetOptions(options);
                    var autoCompleteOptions = {
                        appendTo : options.appendTo,
                        minLength : options.minLength,
                        source : function(request, response) {
                            if (autosuggestAjaxRequest !== null) {
                                autosuggestAjaxRequest.abort();
                            }

                            var formData = getFormData(options, $this);
                            var dataParams = $.param(formData);

                            // Make autosuggestions trigger on 3-chars
                            if (formData.searchQuery.trim() !== '' && formData.searchQuery.length > 2) {
                                if (!responses[dataParams]) {
                                    autosuggestAjaxRequest = $.ajax({
                                        url: serviceUrl,
                                        type: 'POST',
                                        dataType: 'json',
                                        data: dataParams,
                                        success: function(data) {
                                            response($.map(data.links, function(item, index) {
                                                /**
                                                 * For WDW, we get the whole description from SS
                                                 * so that T.COM can intercept the request and translate the response,
                                                 * then we truncate the description to display in the dropdown.
                                                 */
                                                if (siteId == 'wdw') {
                                                    item.desc = truncateString(item.desc);
                                                }
                                                // Save item index, it's needed for SS history purposes.
                                                item.position = index;
                                                item.searchId = data.searchId;

                                                return item;
                                            }));
                                            autosuggestAjaxRequest = null;
                                            // Cache response data.
                                            responses[dataParams] = data.links;
                                        }
                                    });
                                } else {
                                    // If data already exists in cache don't make call.
                                    var $data = responses[dataParams];
                                    response($.map($data, function(item) {
                                        return item;
                                    }));
                                }
                            }
                        },
                        position : {
                            offset : options.xOffset + ' ' + options.yOffset
                        },
                        select: function(event, ui) {
                            event.preventDefault();
                            var params = [];
                            params.completedEventName = 'searchAnalyticsTrackingCompleted';
                            params.typeOfEvent = 'autosuggestionsClickTracking';

                            // prevent autosuggestions from closing
                            if (ui.item.subType === 'answerEngineModal') {
                                // if an answer engine modal is already loading, prevent another triggering
                                if (answerEngineLoading) {
                                    return false;
                                } else {
                                    answerEngineLoading = true;
                                }
                                $this.categoryAutocomplete('option', 'preventClose', true);
                            }

                            //stop the slideshow autoplay, otherwise the
                            //autoplay would replace the search event to populate c9.
                            if (typeof PEP.MoxiePlayer !== "undefined" &&
                                typeof PEP.MoxiePlayer.stop !== "undefined") {
                                PEP.MoxiePlayer.stop();
                            }

                            // Handle the click after analytics is completed
                            $(document).unbind(params.completedEventName);
                            $(document).bind(params.completedEventName, function() {
                                $this[pluginName]('handleSelection', ui, options);
                            });

                            // Get correct analytics link type
                            var linkType = options.analyticsLinkTypes[ui.item.category];
                            if (null === linkType) {
                                linkType = options.analyticsLinkTypes['default'];
                            }
                            params.linkType = linkType;
                            params.linkId = ui.item.analyticsLinkId;
                            params.events = 'pageView,internalSearch';
                            params.keywords = $this.val();
                            params.searchType = sitePrefix + ':Site:Search:' + linkType;
                            params.contentId = ui.item.id;

                            $this[pluginName]('handleSearchSelection', ui.item);
                            $this[pluginName]('handleAnalytic', params, options);

                            // When set to false the values of the input are not updated.
                            return false;
                        }
                    };

                    //abort last ajax call to end after releasing a key
                    $this.bind('keyup.' + pluginName, function(evt) {

                        // abort last ajax call to end after releasing a key
                        if ($this.val() === '') {
                            $this.categoryAutocomplete('close');

                            if (autosuggestAjaxRequest !== null) {
                                autosuggestAjaxRequest.abort();
                            }
                        }
                    });

                    //update the submit button's attribute 'analyticsLinkId'
                    //to fill slot 'c9' on the result landing page tracking call
                    //when user hit enter in search box or click the icon

                    //click the search icon or press the enter to search
                    //this button(or icon) is generated lazily, so it should use delegate to bind the event
                    $("#globalSearchForm,#searchForm").undelegate('button.' + searchClassButton, 'click.' + pluginName);
                    $("#globalSearchForm,#searchForm").delegate('button.' + searchClassButton, 'click.' + pluginName,
                    function(evt) {
                        var $submitBtn = $(evt.target);
                        var $form = $submitBtn.parents('form');
                        var $searchbox = $form.find("input[type='text']");
                        // PRO-339328 remove trailling whitespace
                        $searchbox.val($searchbox.val().trim());
                        var searchBoxVal = $searchbox.val();
                        var linkIdSuffix = searchBoxVal.toLowerCase().replace(/\b[a-z]/g, function(letter) {
                            return letter.toUpperCase();
                        }).replace(/[^a-zA-Z0-9]+/g,'');
                        var boxLocation = globalAnalyticPosition;
                        if($submitBtn.attr('id') !== globalId + '_' + searchClassButton) {
                            boxLocation = secondaryAnalyticPosition;
                        }
                        var customLinkId = sitePrefix + '_Search_Submitted_' + boxLocation + '_' + linkIdSuffix;

                        $this[pluginName]('handleResRoomCodes', $searchbox, sitePrefix);

                        //stop the slideshow autoplay, otherwise
                        // the  autoplay would replace the search event to populate c9.
                        if (typeof PEP.MoxiePlayer !== "undefined" &&
                           typeof PEP.MoxiePlayer.stop !== "undefined") {
                            PEP.MoxiePlayer.stop();
                        }

                        $submitBtn.attr("analyticsLinkId", customLinkId);
                    });

                    // call autocomplete plugin
                    $this.categoryAutocomplete(
                        widgetOptions,
                        autoCompleteOptions
                    );
                    $this.data(pluginName + '_options', options);
                }
            });
        },
        /**
         * Send Selection information to Search Service.
         * @param {object} item Dropdown search result
         */
        handleSearchSelection: function (item) {
            $.ajax({
                url: linkGenerator.build('/search/search-history'),
                async: true,
                type: 'POST',
                dataType: 'json',
                data: {
                    title: item.fullTitle,
                    position: item.position,
                    documentId: item.id,
                    searchId: item.searchId
                }
            });
        },
        /**
         * handleAnalytic
         * Handles Analytic on different types of links that may appear on the auto suggestion,
         * including the keyword user input in search box
         *
         * @param array params - This params contains all data from the selection
         *
         */
        handleAnalytic: function (params, options) {
            // If analytics model is present we want to wait for the
            // analytics call to come back before the user goes
            // forward.
            // if WDPRO.Analytics.Framework.analyticsModel exist we
            // know that the analytics framework is present
            if (
                !!WDPRO &&
                !!WDPRO.Analytics &&
                !!WDPRO.Analytics.Framework &&
                !!WDPRO.Analytics.Framework.analyticsModel
            ) {
                //only fire the link call when user click the quick link
                //always set c8 as 1 when user click quick links
                if (params.linkType === options.analyticsLinkTypes.quickLinks) {
                    if (!options.isElasticSearchEnabled) {
                        var trackingModel = {
                            'events': params.events,
                            'internalSearchKeywords': params.keywords,
                            'internalSearchType': params.searchType,
                            'internalSearchNumResults' : options.quickLinksSearchResultNumber,
                            'contentId': params.contentId
                        };
                        // Update the analytics framework
                        var analyticsModel = {
                            'interactiveElements': [{
                                'linkId': params.linkId,
                                'trackingModel': trackingModel,
                                'triggerEvents': [
                                    {
                                        'type': params.typeOfEvent,
                                        'elementSelectors': options.appendTo,
                                        'onCompleteEventName': params.completedEventName
                                    }
                                ]
                            }]
                        };
                        WDPRO.Analytics.Framework.update(analyticsModel);
                    } else {
                        WDPRO.Analytics.Framework.trackElement('Click_Quicklink', {
                            internalSearchKeywords: params.keywords,
                            internalSearchType: params.searchType,
                            internalSearchNumResults: options.quickLinksSearchResultNumber,
                            linkId: params.linkId
                        });
                    }

                    //If analytic interactive model doesn't work, make sure the handleSelection event can be fired.
                    var $elem = $(options.appendTo);
                    if ($elem.data('events') &&
                          $elem.data('events')[params.typeOfEvent])
                    {
                        // Trigger the tracking and unbind the event
                        $elem.trigger(params.typeOfEvent);
                        $elem.unbind(params.typeOfEvent);
                        return;
                    }
                }
                $(document).trigger(params.completedEventName);
            } else {
                // Fake link tracking completed if framework is not
                // present
                $(document).trigger(params.completedEventName);
            }
        },
        /**
         * handleSelection
         * Handles the different types of links that may appear on the autosuggestions
         * @param object ui.- ui object from autosuggestion plugin. This object
         * contains all data from the search controller
         * @param object options.- Options of the plugin
         */
        handleSelection: function(ui, options) {
            var $this = $(this),
                $form = $this.parents('form:first');

            // Add an input to the search form with the type of link clicked
            $('<input />').attr('type', 'hidden')
                    .attr('name', 'typeOfLink')
                    .attr('value', ui.item.category)
                    .appendTo($form);

            // Assign the value of the query string to the hidden inputs with ids
            // #autoSuggestedQuery and #globalAutoSuggestedQuery
            $('#autoSuggestedQuery').val(ui.item.searchText);
            $('#globalAutoSuggestedQuery').val(ui.item.searchText);

            if (ui.item.category === 'suggestedTerm') {
                // early set the selected text in the text field; autocomplete plugin is too slow
                if ($this.data('pepUiPlusSearchBox') && $this.data('pepUiPlusSearchBox_options').preventSubmit) {
                    // if the search box is a UI+ element, trigger its event with the search text
                    $this.trigger('performKeywordSearch.pepGlobal', ui.item.value.replace(/<\/?[^>]+(>|$)/g, ""));
                } else {
                    $this.val(ui.item.searchText);
                    $form.submit();
                }
                return;
            }

            // check subtype to see if the quick link is an answer engine widget
            if (ui.item.subType === 'answerEngineModal') {
                // get modal content
                $.ajax({
                    type: "POST",
                    url: linkGenerator.build(ui.item.url),
                    dataType: 'json',
                    data: {
                        'record': ui.item.id,
                        'type': ui.item.icon,
                        'value': ui.item.value
                    },
                    success: function(data) {
                        var settings = {
                            'width': options.modalWidth,
                            'height': options.modalHeight,
                            'noBind': true,
                            'dialogClass': options.modalClass + " " + data.widgetType + "ModalWidgetWrap",
                            'closeButton': {
                                'label': options.modalCloseButtonText,
                                'category': 'primary'
                            },
                            'beforeClose' : function(event, ui) {
                                // allow autosuggestions to be closed since closing is prevented
                                $this.categoryAutocomplete('option', 'preventClose', false);
                                $(options.answerEngineContainerSelector).pepSearchAnswerEngineSchedule('destroy');
                            }
                        };

                        // Hide Autosuggest
                        $('.ui-autocomplete').hide('none');

                        /*** DISPLAY MODAL ***/
                        // verify the temporary anchor doesn't exist
                        var $tempAnchor = $('#' + options.modalTempAnchorId);
                        if ($tempAnchor.length !== 0 ) {
                            $tempAnchor.remove();
                            $tempAnchor.pepModalUIPlus('close');
                        }

                        // create temporary anchor and append to the body
                        $('<span />', {
                            id : options.modalTempAnchorId
                        }).appendTo('body');

                        // add modal via anchor
                        $('#' + options.modalTempAnchorId).pepModalUIPlus(settings, true);

                        // adjust to modal location
                        $(options.modalDialogDivContainer)
                            .append(data.html)
                            .css('height', 'auto');
                        $(options.modalDialogCloseButton).bind('click', function() {
                            setTimeout(function() { $this.focus(); }, 1);
                            // to fix modal datepicker z-index issue, remove big z-index when hidden
                            // related ticket PRO-66731
                            $('#ui-datepicker-div').removeClass("modalDatepicker");
                        });
                        $("[data-plugins]", $(options.modalDialogDivContainer)).pepAutoPlugin();

                        // to fix modal datepicker z-index issue, add big z-index when shown
                        // related ticket PRO-66731
                        $('#ui-datepicker-div').addClass("modalDatepicker");
                    },
                    complete: function() {
                        answerEngineLoading = false;
                    }
                });
            } else if (ui.item.subType === 'answerEngineInline') {
                // add the recordId to the form to search for that specific record
                $('<input />').attr('type', 'hidden')
                    .attr('name', 'recordId')
                    .attr('value', ui.item.id)
                    .appendTo($form);
                // add the keyword in order to show it in the inline result
                $('<input />').attr('type', 'hidden')
                    .attr('name', 'keyword')
                    .attr('value', ui.item.keyword)
                    .appendTo($form);
                $form.submit();
            } else if (ui.item.subType === 'fallBack') {
                window.location.href = linkGenerator.build(ui.item.url);
            } else {
                window.location.href = ui.item.url;
            }
        },
        /**
         * handleResRoomCodes
         * Handles the transformation from reservation numbers digit and state room digit to text,
         * "reservation number" and "stateroom number"
         *
         * @$inputObject input text jquery object to update
         * @sitePrefix string with site id
         */
        handleResRoomCodes: function($inputObject, sitePrefix) {

            if (undefined !== codeMapConfiguration[sitePrefix]) {
                var $this = $(this),
                    strSearchTerm = $inputObject.val(),
                    i = 0;

                for (i = 0; i < codeMapConfiguration[sitePrefix].patterns.length; i++) {
                    var pattern = codeMapConfiguration[sitePrefix].patterns[i].pattern,
                        regex = new RegExp(pattern),
                        patternComply = (strSearchTerm.match(regex) !== null),
                        calendarYearHolderCondition = true;

                    if (codeMapConfiguration[sitePrefix].patterns[i].excludeUpcomingYears) {
                        var calendarYearHolderArray = $this[pluginName]('getYearsInArray', 5),
                            yearPattern = '^(' + calendarYearHolderArray.join('|') + ')',
                            yearRegex = new RegExp(yearPattern),
                            calendarYearHolder = strSearchTerm.match(yearRegex);

                        calendarYearHolderCondition = (calendarYearHolder === null);
                    }

                    if (patternComply && calendarYearHolderCondition) {
                        $inputObject.val(codeMapConfiguration[sitePrefix].patterns[i].replacement);
                        return;
                    }

                }
            }
        },
        /**
         * getYearsInArray helps to retireve an array of years from this year + 1 to
         * this year +  numberOfYears
         * @numberOfYears int for how many years from now
         */
        getYearsInArray: function(numberOfYears) {
            var result = [],
                dteCurrent = new Date();

            for (var i = 0; i < numberOfYears; i++) {
                result[i] = dteCurrent.getFullYear() + i;
            }
            return result;

        },
        destroy: function () {
            return this.each(function () {
                var $this = $(this);

                $this.unbind('.' + pluginName);
            });
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

// A plugin to hit Elasticsearch directly
(function ($) {
    /*global WDPRO: true */
    var pluginName = 'pepGlobalElasticsearch',
        dependency = PEP.Dependency.init('jquery.pepSearchAutoSuggestions.js'),
        linkGenerator = dependency.uses('PEP.link.Generator'),
        analyticsIdText = '_Search_QuickLinks_',
        resultListIndex = 'resultList',
        boostResultIndex = 'boost',
        marketedLinkIndex = 'marketedLinks',
        siteId = '',
        options = {},
        defaultOptions = {
            appendTo: 'body',
            inputId: '#globalSearchQuery',
            from: 0,
            minLength: 0,
            resultsToDisplay: 10,
            useWebFontIcon: true,
            modalWidth: 540,
            modalHeight: 'auto',
            modalClass: 'pepModalCustomClass searchModalWidget',
            modalClassSelector: '.pepModalCustomClass.searchModalWidget',
            modalDialogDivContainer: '#modalDialogDivContainer',
            modalDialogCloseButton: '#modalDialogDivContainer .closeModalWindow',
            modalCloseButtonText: 'Close',
            modalTempAnchorId: 'answerEngineModalTempAnchor'
        },
        responses = {},
        answerEngineLoading = false;

    var defaultFontMap = {
            'All': '&#57664;',
            'Attraction': '&#57665;',
            'Calendar': '&#57929;',
            'Destination': '&#57420;',
            'Dining': '&#57728;',
            'Entertainment': '&#57667;',
            'Event': '&#57668;',
            'Events And Tours': '&#57668;',
            'EventTimes': '&#57929;',
            'FAQ': '&#57922;',
            'Widget': '&#57922;',
            'Generic': '&#57420;',
            'Guest Services': '&#57857;',
            'Help': '&#57936;',
            'Marketed Link': '&#57420;',
            'Other': '&#57667;',
            'Other-destination': '&#57420;',
            'Recreation': '&#57810;',
            'Shopping': '&#57669;',
            'Spa': '&#57670;',
            'Sports And Recreation': '&#57792;',
            'Time': '&#57929;',
            'Resort': '&#57417;'
        },
        DCL = {
            'Cruise And Destinations': '&#57474;',
            'Cruise Itineraries': '&#57474;',
            'Deck Parties': '&#57481;',
            'Deck Plans': '&#57481;',
            'Live Shows And Entertainment': '&#57667;',
            'Guest Services': '&#57857;',
            'Shop': '&#57669;',
            'Nightclubs And Lounges': '&#57490;',
            'Pools': '&#57543;',
            'Port Adventure': '&#57477;',
            'Port': '&#57477;',
            'Ship': '&#57473;',
            'Spa And Salon': '&#57670;',
            'Youth Clubs': '&#57491;'
        },
        DLP = {
            'Park': '&#58388;',
            'Resort': '&#58387;'
        },
        DLR = {
            'Park': '&#57408;',
            'Resort': '&#57417;',
            'Good Neighbor Hotels': '&#57417;'
        },
        HKDL = {
            'Tour': '&#57676;',
            'Park': '&#57349;',
            'Resort': '&#57417;'
        },
        WDW = {
            'Tour': '&#57676;'
        },
        fontMap = {
            'dcl': $.extend(true, {}, defaultFontMap, DCL),
            'dlp': $.extend(true, {}, defaultFontMap, DLP),
            'dlr': $.extend(true, {}, defaultFontMap, DLR),
            'hkdl': $.extend(true, {}, defaultFontMap, HKDL),
            'wdw': $.extend(true, {}, defaultFontMap, WDW)
        },
        webLinks = {
            'dcl': 'Common.WebDetail',
            'dlp': 'Common.dlpdetail',
            'dlr': 'Common.dlrdetail',
            'hkdl': 'Common.WebDetail',
            'wdw': 'Common.wdwdetail'
        },
        hosts = {
            'dlp': [
                'disneylandparis.disney.go.com',
                'idf.disneylandparis.fr',
                'www.disneylandparis.fr',
                'www.disneylandparis.com',
                'www.disneylandparis.be',
                'www.disneylandparis.ch',
                'www.disneylandparis.co.uk',
                'www.disneylandparis.ie',
                'www.disneylandparis.ru',
                'www.disneylandparis.pt',
                'www.disneylandparis.dk',
                'www.disneylandparis.es',
                'www.disneylandparis.it',
                'www.disneylandparis.at',
                'www.disneylandparis.de',
                'www.disneylandparis.nl'
            ],
            'dcl': ['disneycruise.disney.go.com'],
            'dlr': ['disneyland.disney.go.com'],
            'hkdl': ['www.hongkongdisneyland.com'],
            'wdw': ['disneyworld.disney.go.com']
        },
        // These are locales that appear on the site's URL
        supportedLocales = {
            'dlp': [
                'en',
                'en-us',
                'fr',
                'de',
                'nl'
            ],
            'dcl': [],
            'dlr': [
                'es-us'
            ],
            'shdr': [
                'en'
            ],
            'hkdl': [
                'zh-cn',
                'zh-hk',
                'ja',
                'ko',
                'th',
                'id',
                'ms'
            ],
            'wdw': [
                'es-us',
                'es-ar',
                'es-mx',
                'es-pe',
                'es-co',
                'es-cl',
                'en-eu',
                'en_CA',
                'en_GB',
                'fr-ca',
                'pt-br'
            ]
        };
    var searchClassButton = 'search_button';

    $.pepPlugin(pluginName, {
        init: function(options) {
            options = $.extend(true, {}, defaultOptions, options);
            siteId = options.siteId || PEP.Config.SiteId;
            var $searchInput = $(this),
                previousQueryString = '',
                autoCompleteOptions = {},
                $this = $(this),
                widgetOptions = {
                    quickLinksCategoryTitle: options.quickLinksCategoryTitle,
                    useWebFontIcon: options.useWebFontIcon,
                    isSyndication : options.isSyndicated,
                    isResponsiveSyndicated: options.isResponsiveSyndicated
                };

            autoCompleteOptions = {
                appendTo: options.appendTo,
                minLength:  options.minLength,
                source: function(request, response) {
                    // PRO-339328 remove trailling whitespace
                    var queryString = $searchInput.val().trim(),
                        body = options.body.replace(/queryString/g, queryString),
                        cacheKey = queryString + $searchInput.attr('id');

                    //PRO-325365 Make autosuggestions trigger on 2-chars
                    if (!responses[cacheKey] && queryString.length > 1) {
                        $.ajax({
                            method: 'POST',
                            url: options.endpoint,
                            data: body,
                            success: function(data) {
                                var resultsCartridges = $this.pepGlobalElasticsearch(
                                        'getResultsCartridges',
                                        data.responses,
                                        options.multisearchItemsOrder
                                    ),
                                    recordsToProcess = [],
                                    records = [];

                                if (marketedLinkIndex in resultsCartridges &&
                                    resultsCartridges[marketedLinkIndex].length) {
                                    recordsToProcess.push(resultsCartridges[marketedLinkIndex][0]);
                                }

                                if (boostResultIndex in resultsCartridges &&
                                    resultsCartridges[boostResultIndex].length) {
                                    recordsToProcess = $.merge(recordsToProcess, resultsCartridges[boostResultIndex]);
                                }

                                if (resultsCartridges[resultListIndex].length) {
                                    recordsToProcess = $.merge(recordsToProcess, resultsCartridges[resultListIndex]);
                                }

                                if (recordsToProcess.length > options.resultsToDisplay) {
                                    recordsToProcess = recordsToProcess.splice(0, options.resultsToDisplay);
                                }

                                records = $.map(recordsToProcess, function(record) {
                                    return $this.pepGlobalElasticsearch('mapData', record, queryString);
                                });
                                response(records);
                                responses[cacheKey] = records;
                            }
                        });
                    } else {
                        response(responses[cacheKey]);
                    }
                },
                select: function(event, ui) {
                    event.preventDefault();

                    // prevent autosuggestions from closing
                    if (ui.item.subType === 'answerEngineModal') {
                        // if an answer engine modal is already loading, prevent another triggering
                        if (answerEngineLoading) {
                            return false;
                        } else {
                            answerEngineLoading = true;
                        }
                        $this.categoryAutocomplete('option', 'preventClose', true);
                    }
                    $this[pluginName]('handleSelection', ui, options);

                    return false;
                }
            };

            // PRO-339328 remove trailling whitespace
            $("#globalSearchForm,#searchForm").undelegate('button.' + searchClassButton, 'click.' + pluginName);
            $("#globalSearchForm,#searchForm").delegate('button.' + searchClassButton, 'click.' + pluginName,
                function(evt) {
                    var $submitBtn = $(evt.target);
                    var $form = $submitBtn.parents('form');
                    var $searchbox = $form.find("input[type='text']");
                    $searchbox.val($searchbox.val().trim());
                }
            );

            $this.categoryAutocomplete(
                widgetOptions,
                autoCompleteOptions
            );
        },

        getResultsCartridges: function(responses, multisearchItemsOrder) {
            var resultsCartdridge = [];

            resultsCartdridge[resultListIndex] = responses[0].hits.hits;

            if (multisearchItemsOrder.length > 0) {
                responses.shift();
                $.each(responses, function(index, resultSet) {
                    // Just in case a shard comes with an error
                    if (!resultSet.error) {
                        resultsCartdridge[multisearchItemsOrder[index]] = resultSet.hits.hits;
                    }
                });
            }

            return resultsCartdridge;
        },

        mapData: function(record, queryString) {
            var toggleScope = $(this).pepGlobalElasticsearch,
                isFaqOrWidget = record._source.RecordType[0] === 'FAQ' || record._source.RecordType[0] === 'Widget',
                title = toggleScope('_setTitle', record, isFaqOrWidget),
                url = isFaqOrWidget ? '/search/modal-widget' : toggleScope('_setUrl', record);
            return {
                id: record._id,
                className: 'quickLink',
                desc: toggleScope('_setDescription', record, isFaqOrWidget, toggleScope),
                keyword: queryString,
                label: '<quicklink>' + toggleScope('truncateString', title) + '</quicklink>',
                url: url,
                icon: toggleScope('_setIcon', record, isFaqOrWidget),
                webFontCode: fontMap[siteId][record._source.RecordType],
                category: 'quickLinks',
                urlType: 'relative',
                subType: toggleScope('_setSubType', record, isFaqOrWidget),
                analyticsId: siteId.toUpperCase() + analyticsIdText + title.split(' ').join('')
            };
        },

        _setSubType: function(record, isFaqOrWidget) {
            var subType = 'fallBack';

            if (isFaqOrWidget) {
                subType = window.location.href.indexOf('search') === -1 ?
                    'answerEngineModal' :
                    'answerEngineInline';
            }
            return subType;
        },

        _setDescription: function(record, isFaqOrWidget, toggleScope) {
            var desc = "";

            if (isFaqOrWidget) {
                desc = record._source['FAQ.Question'][0];
            } else if (record._source.hasOwnProperty('Common.BriefDescription')) {
                desc = record._source['Common.BriefDescription'][0];
            }

            // need to do this for cleaning the description from html tags
            desc = $('<div>' + desc + '</div>').text();
            return toggleScope('truncateString', desc);
        },

        _setIcon: function (record, isFaqOrWidget) {
            return isFaqOrWidget ? 'faq' : record._source.RecordType[0];
        },

        _setTitle: function(record, isFaqOrWidget) {
            var topicParts = [],
                title = record._source.hasOwnProperty('Common.Title') ?
                    record._source['Common.Title'][0] :
                    '';

            if (isFaqOrWidget) {
                var topic = record._source.hasOwnProperty('FAQ.TopicCategoryDisplay') ?
                    record._source['FAQ.TopicCategoryDisplay'][0] :
                    '';
                topicParts = topic.split('|');
                title = topicParts[0];
            }
            return title;
        },

        _setUrl: function(record) {
            var a = document.createElement('a'),
                currentLang;

            a.href = record._source[webLinks[siteId]];

            // Taking the lang from the URL
            currentLang = a.pathname.split('/')[1];

            // On locale-enabled sites the url already includes the locale
            // we are removing it so it doesn't get duplicated on the link
            // generator method. EXAMPLE - disneyworld.disney.go.com/es-us/destinations/epcot
            if (supportedLocales[siteId].indexOf(currentLang) !== -1) {
                a.pathname = a.pathname.replace('/' + currentLang, '');
            }

            // Some records redirects the user to a different site, we need to make sure,
            // we don't override the url's host by using the linkGenerator
            return hosts[siteId].indexOf(a.host) === -1 ?
                a.href :
                linkGenerator.build(a.pathname);
        },

        truncateString: function(string) {
            var length = 30;

            if (string.length > length) {
                var chunks = string.split(' '),
                    resultString = chunks[0],
                    i = 1;
                while ((resultString + ' ' + chunks[i]).length < length) {
                    resultString += ' ' + chunks[i++];
                }
                return resultString + '...';
            }

            return string;
        },

        handleSelection: function(ui, options) {
            var $this = $(this),
                $form = $this.parents('form:first'),
                analyticsFramework = window.WDPRO && WDPRO.Analytics && WDPRO.Analytics.Framework;

            if (analyticsFramework) {
                WDPRO.Analytics.Framework.trackElement('Click_Quicklink', {
                    internalSearchKeywords: ui.item.keyword,
                    internalSearchType: siteId.toUpperCase() + ':Site:Search:QuickLink',
                    linkId: ui.item.analyticsId
                });
            }

            // Add an input to the search form with the type of link clicked
            $('<input />').attr('type', 'hidden')
                    .attr('name', 'typeOfLink')
                    .attr('value', ui.item.category)
                    .appendTo($form);

            // Assign the value of the query string to the hidden inputs with ids
            // #autoSuggestedQuery and #globalAutoSuggestedQuery
            $('#autoSuggestedQuery').val(ui.item.searchText);
            $('#globalAutoSuggestedQuery').val(ui.item.searchText);

            if (ui.item.category === 'suggestedTerm') {
                // early set the selected text in the text field; autocomplete plugin is too slow
                if ($this.data('pepUiPlusSearchBox') && $this.data('pepUiPlusSearchBox_options').preventSubmit) {
                    // if the search box is a UI+ element, trigger its event with the search text
                    $this.trigger('performKeywordSearch.pepGlobal', ui.item.value.replace(/<\/?[^>]+(>|$)/g, ""));
                } else {
                    $this.val(ui.item.searchText);
                    $form.submit();
                }
                return;
            }

            // check subtype to see if the quick link is an answer engine widget
            if (ui.item.subType === 'answerEngineModal') {
                $.ajax({
                    type: "POST",
                    url: linkGenerator.build(ui.item.url),
                    dataType: 'json',
                    data: {
                        'record': ui.item.id,
                        'type': ui.item.icon,
                        'value': ui.item.value
                    },
                    success: function(data) {
                        var settings = {
                            'width': options.modalWidth,
                            'height': options.modalHeight,
                            'noBind': true,
                            'dialogClass': options.modalClass + " " + data.widgetType + "ModalWidgetWrap",
                            'closeButton': {
                                'label': options.modalCloseButtonText,
                                'category': 'primary'
                            },
                            'beforeClose': function(event, ui) {
                                // allow autosuggestions to be closed since closing is prevented
                                $this.categoryAutocomplete('option', 'preventClose', false);
                                $(options.answerEngineContainerSelector).pepSearchAnswerEngineSchedule('destroy');
                            }
                        };

                        // Hide Autosuggest
                        $('.ui-autocomplete').hide('none');

                        /*** DISPLAY MODAL ***/
                        // verify the temporary anchor doesn't exist
                        var $tempAnchor = $('#' + options.modalTempAnchorId);
                        if ($tempAnchor.length !== 0 ) {
                            $tempAnchor.remove();
                            $tempAnchor.pepModalUIPlus('close');
                        }

                        // create temporary anchor and append to the body
                        $('<span />', {
                            id: options.modalTempAnchorId
                        }).appendTo('body');

                        // add modal via anchor
                        $('#' + options.modalTempAnchorId).pepModalUIPlus(settings, true);

                        // adjust to modal location
                        $(options.modalDialogDivContainer)
                            .append(data.html)
                            .css('height', 'auto');
                        $(options.modalDialogCloseButton).bind('click', function() {
                            setTimeout(function() { $this.focus(); }, 1);
                            // to fix modal datepicker z-index issue, remove big z-index when hidden
                            // related ticket PRO-66731
                            $('#ui-datepicker-div').removeClass("modalDatepicker");
                        });
                        $("[data-plugins]", $(options.modalDialogDivContainer)).pepAutoPlugin();

                        // to fix modal datepicker z-index issue, add big z-index when shown
                        // related ticket PRO-66731
                        $('#ui-datepicker-div').addClass("modalDatepicker");
                    },
                    complete: function() {
                        answerEngineLoading = false;
                    }
                });
            } else if (ui.item.subType === 'answerEngineInline') {
                // add the recordId to the form to search for that specific record
                $('<input />').attr('type', 'hidden')
                    .attr('name', 'recordId')
                    .attr('value', ui.item.id)
                    .appendTo($form);
                // add the keyword in order to show it in the inline result
                $('<input />').attr('type', 'hidden')
                    .attr('name', 'keyword')
                    .attr('value', ui.item.keyword)
                    .appendTo($form);
                $form.submit();
            } else if (ui.item.subType === 'fallBack') {
                window.location.href = linkGenerator.build(ui.item.url);
            } else {
                window.location.href = ui.item.url;
            }
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #15 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation object
 */
(function($, PEP) {

    /**
     * -----------------
     * Validation object
     * -----------------
     * Singleton object which acts as namespace for the PEP JS Validation Framework.
     */
    PEP.Validation = {
        STATUS_VALID: 1,
        STATUS_NOTVALIDATED: 0,
        STATUS_INVALID: -1,
        STATUS_WAITING: -2,
        STATUS_TIMEOUT: -3,
        EVENT_VALIDATED: 'Validated.jsvf',
        VALIDATOR_VALIDATE_TIMEOUT: 3000,
        VALIDATION_QUEUE_VALIDATE_TIMEOUT: 3000,
        JSVF_ELEMENT_SELECTOR: '.jsvfElement',
        JSVF_FORM_SELECTOR: '.jsvfForm',
        ERROR_ANIMATION_COMPLETE: 'errorAnimationComplete',
        ERROR_RENDER_COMPLETE: 'errorRenderComplete'
    };


    /**
     * ----------------------------
     * Backward Compatibility Layer
     * ----------------------------
     * This code snippet adds to this new Framework implementation some hard-coded properties to keep backward
     * compatibility.
     * IMPORTANT: This implementation doesn't support asyncronous validation.
     * If you are using this layer, Asynch Features are disabled and won't work.
     */
    (function($, Validation) {
        var BackwardCompatibilityHelper = null;

        $.fn.validationComplete = false;

        Validation.isValid = function($element) {
            var $jsvfElement = $element.closest(Validation.JSVF_ELEMENT_SELECTOR),
                $jsvfForm = $jsvfElement.closest(Validation.JSVF_FORM_SELECTOR),
                jsvfElement = $jsvfElement.data('jsvfElement'),
                isValid = false;

            if ($jsvfForm.size() && !BackwardCompatibilityHelper) {
                BackwardCompatibilityHelper = {};
                BackwardCompatibilityHelper.jsvfForm = new Validation.JsvfForm($jsvfForm);
                BackwardCompatibilityHelper.elementQueue = new Validation.QueueElements();
                BackwardCompatibilityHelper.jsvfForm.errorReporter.listen(BackwardCompatibilityHelper.elementQueue);
                BackwardCompatibilityHelper.elements = {};
            }
            if (null !== BackwardCompatibilityHelper) {
                if (!BackwardCompatibilityHelper.elements.hasOwnProperty(jsvfElement.name)) {
                    BackwardCompatibilityHelper.elements[jsvfElement.name] = true;
                    BackwardCompatibilityHelper.elementQueue.add(jsvfElement.validatorQueue);
                }
                BackwardCompatibilityHelper.elementQueue.validate();
            }
            jsvfElement.validatorQueue.validate();
            return jsvfElement.validatorQueue.isValid();
        };

        $('form.jsvfForm').bind('clearUpValidationErrors.jsValidation', function() {
            if (BackwardCompatibilityHelper) {
                var formErrorContainersSelector = $(this).attr('data-errorSummaryContainerCssSelector');
                $(formErrorContainersSelector).html('');
                BackwardCompatibilityHelper.elements = {};
                BackwardCompatibilityHelper.jsvfForm.errorReporter.clear();
                BackwardCompatibilityHelper = null;
            }
        });

    })($, PEP.Validation);

})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576944 $
 * - $DateTime: 2015/05/26 00:30:13 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #66 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.ValidatorCommands object (Singleton)
 * Validation.ValidatorCommands.EmailAddress object
 * Validation.ValidatorCommands.EmailAddressUnique object
 * Validation.ValidatorCommands.NotEmpty object
 * Validation.ValidatorCommands.StringLength object
 * Validation.ValidatorCommands.Identical object
 * Validation.ValidatorCommands.NotIdentical object
 * Validation.ValidatorCommands.NotIdenticalInArray object
 * Validation.ValidatorCommands.PairDependency object
 * Validation.ValidatorCommands.PhoneNumber object
 * Validation.ValidatorCommands.Regex object
 * Validation.ValidatorCommands.Between object
 * Validation.ValidatorCommands.GreaterThan object
 * Validation.ValidatorCommands.Float object
 * Validation.ValidatorCommands.Date object
 * Validation.ValidatorCommands.DateBetween object
 * Validation.ValidatorCommands.ConditionalRegex object
 * Validation.ValidatorCommands.NotInArray object
 * Validation.ValidatorCommands.ValidationTrigger object
 */
(function($, Validation) {

    /**
     * ------------------------
     * ValidatorCommands object
     * ------------------------
     * Singleton object that stores all ValidatorCommand objects.
     *
     *      ------------------------
     *      ValidatorCommand object
     *      ------------------------
     *      In JSVF a ValidatorCommand is an object that implements a Strategy pattern for the execute() method.
     *      This method performs the validation inside, it could be for example, from a simple regex validation, a
     *      string comparisson to a web service call.
     *      Methods:
     *       + execute()
     *       + isValid()
     */

    /**
     * replacing parseFloat by this, allows every valid number format
     * like 1115.40 - 1,115.40 - 1115,40 - 1.115,40
     * @param string
     * @return number
     */
    function getFloatFromString(stringValue) {
        var regDot = /^[0-9]+(\.[0-9]{1,2})?$/;
        var regDotComma = /^([1-9]\,[0-9]{3}|[1-9][0-9]{1,2}?\,[0-9]{3})(\.[0-9]{1,2})?$/;
        var regComma = /^[0-9]+(\,[0-9]{1,2})?$/;
        var regCommaDot = /^([1-9]\.[0-9]{3}|[1-9][0-9]{1,2}?\.[0-9]{3})(\,[0-9]{1,2})?$/;

        if (regDot.test(stringValue)) {
            // decimal dot only
            return parseFloat(stringValue);
        } else {
            if (regDotComma.test(stringValue)) {
                // decimal dot and thousands comma
                return parseFloat(stringValue.replace(',', ''));
            } else {
                if (regComma.test(stringValue)) {
                    //decimal comma only
                    return parseFloat(stringValue.replace(',', '.'));
                } else {
                    if (regCommaDot.test(stringValue)) {
                        // decimal comma and thousands dot
                        var v1 = stringValue.replace('.', '');
                        var v2 = v1.replace(',', '.');
                        return parseFloat(v2);
                    } else {
                        // invalid string
                        return false;
                    }
                }
            }
        }
    }

    function isAccordionEnabled() {
        return !!PEP.Config.Toggles.Release.expressCheckoutConsumerTicketsAccordionDlr;
    }

    /**
     * Check if standAlone field or concatenated (of two fields) value is in CareGiverFilter
     * and must show error
     * @param string standAlone field
     * @param string concatenated (of two fields) value
     * @param array arrFilter with the list of words not allowed
     * @return boolean
     */
    function careGiverExists(standAlone, concatenated, arrFilter) {
        var result = false;
        arrFilter.forEach(function(filter) {
            if (standAlone.indexOf(filter) > -1 || concatenated.indexOf(filter) > -1) {
                result = true;
            }
        });

        return result;
    }

    Validation.ValidatorCommands = {
        ContextDependency: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var validators = options.contextDependencyValidators,
                    validatorQueue = new Validation.QueueValidators(jsvfElement),
                    subFormName = options.subFormName,
                    preconditions = options.preconditions,
                    anyPreconditions = options.anyPreconditions ? options.anyPreconditions : false,
                    preconditionsMet = true,
                    fieldValue = null;

                var preconditionEqualsFunc = function () {
                    if ($(this).prop('checked') && $(this).val() === fieldValue) {
                        preconditionsMet = true;
                        return false;
                    }
                };

                var preconditionNotEqualsFunc = function () {
                    if ($(this).prop('checked') && $(this).val() !== fieldValue) {
                        preconditionsMet = true;
                        return false;
                    }
                };

                var preconditionEmptyFunc = function () {
                    var elementValue = $(this).val().trim();
                    preconditionsMet = preconditionsMet && elementValue === '';
                    return preconditionsMet;
                };

                var preconditionNotEmptyFunc = function () {
                    var elementValue = $(this).val().trim();
                    preconditionsMet = preconditionsMet && elementValue !== '';
                    return preconditionsMet;
                };

                for (var i = 0; i < preconditions.length; i++) {
                    var precondition = preconditions[i],
                        fieldName = precondition.fieldName,
                        $formElement;

                    if (subFormName) {
                        fieldName = subFormName + '[' + fieldName + ']';
                    }

                    if (typeof precondition.emptyDate === 'boolean') {
                        $formElement = $(
                            'select[name=\'' + fieldName + '[month]\'], select[name=\'' + fieldName +
                            '[day]\'], input[name=\'' + fieldName + '[year]\']'
                        );
                    } else {
                        $formElement = $('input[name=\'' + fieldName + '\'], select[name=\'' + fieldName + '\']');
                    }

                    if ($formElement !== undefined) {
                        if (precondition.equals !== undefined) {
                            if ($formElement.length > 1) {
                                fieldValue = precondition.equals;
                                preconditionsMet = false;
                                $formElement.each(preconditionEqualsFunc);
                            } else {
                                preconditionsMet = $formElement.val() === precondition.equals;
                            }
                        } else if (precondition.notEquals !== undefined) {
                            if ($formElement.length > 1) {
                                fieldValue = precondition.notEquals;
                                preconditionsMet = false;
                                $formElement.each(preconditionNotEqualsFunc);
                            } else {
                                preconditionsMet = $formElement.val() !== precondition.notEquals;
                            }
                        } else if (typeof precondition.empty === 'boolean') {
                            if (precondition.empty) {
                                preconditionsMet = $formElement.val() === '';
                            } else {
                                preconditionsMet = $formElement.val() !== '';
                            }
                        } else if (typeof precondition.emptyDate === 'boolean') {
                            if ($formElement.length > 1) {
                                preconditionsMet = true;
                                if (precondition.emptyDate) {
                                    $formElement.each(preconditionEmptyFunc);
                                } else {
                                    $formElement.each(preconditionNotEmptyFunc);
                                }
                            }
                        }

                        if ((preconditionsMet && anyPreconditions) || (!preconditionsMet && !anyPreconditions)) {
                            break;
                        }
                    }
                }

                if (preconditionsMet) {
                    for (i = validators.length-1; i >= 0; i--) {
                        var validatorConfig = validators[i].validator;
                        validatorConfig.errorMessages = validatorConfig.options.messages;
                            var validator = new Validation.Validator(validatorConfig, jsvfElement);
                            validatorQueue.add(validator);
                    }

                    $(validatorQueue).bind(Validation.EVENT_VALIDATED,
                            function(e, responseValidationToken, status, errorMessage) {
                            if (Validation.STATUS_VALID === status) {
                                callback(validationToken, Validation.STATUS_VALID);
                            } else if (Validation.STATUS_INVALID === status) {
                                callback(validationToken, Validation.STATUS_INVALID, 'errorMsg',
                                        {errorMsg: errorMessage});
                            }
                        });

                    validatorQueue.validate();
               } else {
                   callback(validationToken, Validation.STATUS_VALID);
               }
            }
        },
        EmailAddress: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var regEmail = new RegExp(
                    "^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)" +
                    "*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:" +
                    "(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\\-](?!\\.)){0,61}[a-zA-Z0-9_-]?\\.)+[a" +
                    "-zA-Z0-9_](?:[a-zA-Z0-9_\\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\\[(?:(?:[" +
                    "01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[" +
                    "0-5])\\]))$"
                );
                if (!regEmail.test(jsvfElement.getValue())) {
                    callback(validationToken, Validation.STATUS_INVALID, 'emailAddressInvalidFormat');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        EmailAddressUnique: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                if (this._cache.hasOwnProperty(value)) {
                    if (this._cache[value]) {
                        callback(validationToken, Validation.STATUS_VALID);
                    } else {
                        callback(validationToken, Validation.STATUS_INVALID, 'alreadyExists');
                    }
                } else {
                    document.location.origin = document.location.origin ||
                        document.location.protocol + '//' + document.location.host;
                    var iregUri = options.useProxy ? document.location.origin + '/jsonp/ireg-api/' : options.iregUri,
                        instance = this;

                    $.ajax({
                        dataType: 'jsonp',
                        data: '&appId=WDW&email=' + value,
                        url: iregUri + 'ProfileService/guest/registration/exists',
                        success: function (response) {
                            if (
                                response.hasOwnProperty('Response') &&
                                response.Response.hasOwnProperty('AccountExistsResult') &&
                                true === response.Response.AccountExistsResult.exists
                            ) {
                                instance._cache[value] = false;
                                callback(validationToken, Validation.STATUS_INVALID, 'alreadyExists');
                            } else {
                                instance._cache[value] = true;
                                callback(validationToken, Validation.STATUS_VALID);
                            }
                        }
                    });
                }
            },
            _cache: {}
        },
        NotEmpty: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                if ($(jsvfElement.$node).find('.pepRichCheckbox').length > 0) {
                    if ($(jsvfElement.$node).find('.pepRichCheckbox').not('.disabled').length === 0) {
                        // if the only pepRichCheckboxes are disabled, their validators should not fire
                        callback(validationToken, Validation.STATUS_VALID);
                    } else if ($(jsvfElement.$node).find('.pepRichCheckbox .rich-checkbox.selected').length === 0) {
                        callback(validationToken, Validation.STATUS_INVALID, 'isEmpty');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else if ($(jsvfElement.$node).find('.configurableCheckbox').length > 0) {
                    if ($(jsvfElement.$node).find('label.checked').length > 0) {
                        callback(validationToken, Validation.STATUS_VALID);
                    } else {
                        callback(validationToken, Validation.STATUS_INVALID, 'isEmpty');
                    }
                } else {
                    if (this._trim(value).length < 1) {
                        callback(validationToken, Validation.STATUS_INVALID, 'isEmpty');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                }
            },
            _trim: function(string) {
                if (typeof string === 'object') {
                    string = string.join('').trim();
                }
                return string.replace(/(^[\s\t\r\n]+|[\s\t\r\n]+$)/g,'');
            }
        },
        StringLength: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var elementLength = this._trim(value).length,
                    min = parseInt(options.min, 10) || undefined,
                    max = parseInt(options.max, 10) || undefined;

                if (min && elementLength < min) {
                    callback(validationToken, Validation.STATUS_INVALID, 'stringLengthTooShort');
                } else if (max && elementLength > max) {
                    callback(validationToken, Validation.STATUS_INVALID, 'stringLengthTooLong');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }

            },
            _trim: function(string) {
                return string.replace(/(^[\s\t\r\n]+|[\s\t\r\n]+$)/g,'');
            }
        },
        Identical: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var identityElementValue = jsvfElement.$node.closest('form').find(
                        '[name="'+ options.primaryElementName +'"]'
                    ).val();
                if (!options.caseSensitive) {
                    value = value.toLowerCase();
                    identityElementValue = identityElementValue.toLowerCase();
                }
                if (value === identityElementValue) {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    callback(validationToken, Validation.STATUS_INVALID, 'notSame');
                }
            }
        },
        NotIdentical: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var identityElementValue = jsvfElement.$node.closest('form').find(
                        '[name="'+ options.primaryElementName +'"]'
                    ).val();
                if (!options.caseSensitive) {
                    value = value.toLowerCase();
                    identityElementValue = identityElementValue.toLowerCase();
                }
                if (value !== identityElementValue) {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    callback(validationToken, Validation.STATUS_INVALID, 'same');
                }
            }
        },
        NotIdenticalInArray: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var $form = jsvfElement.$node.closest('form'),
                    elementSelector = '[name^="' + options.fieldName + '"]',
                    $elements = $form.find(elementSelector),
                    $originalElement = jsvfElement.$node.find(elementSelector),
                    allValues = [];

                $elements.each(function(index, element) {
                    var $element = $(element),
                        elementValue = $element.val();

                    if (!$element.is($originalElement)) {
                        allValues.push(elementValue);
                    }
                });

                if ($.inArray(value, allValues) === -1) {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    callback(validationToken, Validation.STATUS_INVALID, 'duplicate');
                }
            }
        },
        PairDependency: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                if (value) {
                    var $pairElement = jsvfElement.$node.closest('form')
                            .find('[name="' + options.pairElementName + '"]').closest('.jsvfElement'),
                        pairJsvfElement = new Validation.JsvfElement($pairElement),
                        validators = options.pairValidators,
                        validatorQueue = new Validation.QueueValidators(pairJsvfElement);

                    for (var i = validators.length-1; i >= 0; i--) {
                        var validatorConfig = validators[i].validator,
                            pairValidator = new Validation.Validator(validatorConfig, pairJsvfElement);
                            validatorQueue.add(pairValidator);
                    }

                    $(validatorQueue).bind(Validation.EVENT_VALIDATED,
                        function(e, responseValidationToken, status, errorMessage) {
                        if (Validation.STATUS_VALID === status) {
                            callback(validationToken, Validation.STATUS_VALID);
                        } else if (Validation.STATUS_INVALID === status) {
                            callback(validationToken, Validation.STATUS_INVALID, 'unmetDependency',
                                {pairLabel: pairJsvfElement.label});
                        }
                    });
                    validatorQueue.validate();
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        PhoneNumber: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var regPhone = /^[0-9]{10}$/;

                if (!regPhone.test(value)) {
                    callback(validationToken, Validation.STATUS_INVALID, 'regexNotMatch');  // TODO bad errorKey
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        Regex: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                /**
                 * There are two Regex filters below this comment. Both take care of
                 * sanitizing the Regex pattern coming from PHP-side.
                 *
                 * The first filter has 4 sections:
                 *   1st    /^\/?        -> a forward slash at the beginning (opening delimiter)
                 *   2nd    (.+?)         -> one or more characters (non greedy)
                 *   3rd    (?:\/?)      -> the closing forward slash (closing delimiter)
                 *   4th    ([a-z]*)$/   -> an optional modifier that comes after the closing delimiter
                 *
                 * In brief, it just gets rid of forward slashes used as delimiters
                 * preserving the remaining characters.
                 *
                 * The second filter removes Unicode expressions from the pattern as
                 * they are not supported by Javascript's Regex implementation.
                 */
                var patternData = options.pattern.match(/^\/?(.+?)(?:\/?)([a-z]*)$/);
                // For a unicode character range we need to replace \x with \u for the 4 character unicode codes.
                patternData[1] = patternData[1].replace(/\\x\{([\d\w]{4})\}/g,'\\u$1');
                var pattern = patternData[2] ?
                    new RegExp(patternData[1], patternData[2]) :
                    new RegExp(patternData[1]);

                if (!pattern.test(value)) {
                    callback(validationToken, Validation.STATUS_INVALID, 'regexNotMatch');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        Between: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                value = parseInt(value, 10);

                if (options.inclusive) {
                    if (options.min > value || value > options.max) {
                        callback(validationToken, Validation.STATUS_INVALID, 'notBetween');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else {
                    if (options.min >= value || value >= options.max) {
                        callback(validationToken, Validation.STATUS_INVALID, 'notBetweenStrict');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                }
            }
        },
        MultiCheckboxValueCount: {
            execute: function(value, jsvfElement, options, validationToken, callback) {

                var totalSelected = $('.configurableCheckbox.' + options.groupName + ' .checked').length;

                if (options.min && options.max && options.min === options.max) {
                    if (totalSelected !== options.min) {
                        callback(validationToken, Validation.STATUS_INVALID, 'notExact');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else if (options.min) {
                    if (options.min > totalSelected) {
                        callback(validationToken, Validation.STATUS_INVALID, 'tooFew');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else if (options.max) {
                    if (options.max < totalSelected) {
                        callback(validationToken, Validation.STATUS_INVALID, 'tooMany');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        GreaterThan: {
            execute: function(value, jsvfElement, options, validationToken, callback) {

                value = getFloatFromString(value);

                if (options.min > value) {
                    callback(validationToken, Validation.STATUS_INVALID, 'notGreaterThan');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        LessThan: {
            execute: function(value, jsvfElement, options, validationToken, callback) {

                value = getFloatFromString(value);

                if (options.max < value) {
                    callback(validationToken, Validation.STATUS_INVALID, 'notLessThan');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        Float: {
            execute: function(value, jsvfElement, options, validationToken, callback) {

                var valid;
                if (getFloatFromString(value)) {
                    value = getFloatFromString(value);
                    valid = true;
                } else {
                    valid = false;
                }

                if (valid) {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    callback(validationToken, Validation.STATUS_INVALID, 'notFloat');
                }
            }
        },
        Date: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var validationOrder;
                if (jsvfElement.$jsvfElement !== undefined) {
                    validationOrder = jsvfElement.$jsvfElement.find('.formFieldDate').attr('data-validationOrder');
                }
                var dateValues = [];

                if (validationOrder !== undefined) {
                    dateValues = validationOrder.split(' ');
                } else {
                    dateValues = ['Month', 'Day', 'Year'];
                }

                if (typeof value === 'string') {
                    value = value.split('/');
                }

                var yearInArray = $.inArray('Year', dateValues),
                    dayInArray = $.inArray('Day', dateValues),
                    monthInArray = $.inArray('Month', dateValues),
                    year = '',
                    day = '',
                    month = '',
                    validDigits = true,
                    patternDayMonth = new RegExp('^[0-9]+$'),
                    patternYear = new RegExp('^[0-9]{4}$');

                // Year may come in as a zero-length string, when a value is not entered
                if (yearInArray !== -1 && value[yearInArray] !== undefined && value[yearInArray] !== null) {
                    year = value[yearInArray].trim();
                    validDigits &= patternYear.test(year);
                }

                // Day may come in as a zero-length string, when a value is not entered
                if (dayInArray !== -1 && value[dayInArray] !== undefined && value[dayInArray] !== null) {
                    day = value[dayInArray].trim();
                    validDigits &= patternDayMonth.test(day);
                }

                // Month may come in as a zero-length string, when a value is not entered
                if (monthInArray !== -1 && value[monthInArray] !== undefined && value[monthInArray] !== null) {
                    month = value[monthInArray].trim();
                    validDigits &= patternDayMonth.test(month);
                }

                var givenDate = [month, day, year].join('-'),
                    date = moment(givenDate, 'MM-DD-YYYY');

                // If allowEmpty and no date is given
                if (options && options.allowEmpty && givenDate === '--') {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    if (!date.isValid() || !validDigits) {
                        callback(validationToken, Validation.STATUS_INVALID, 'invalidDate', {displayDate: givenDate});
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                }
            }
        },
        DateBetween: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                if (typeof value === 'string') {
                    value = value.split('/');
                }
                var validationOrder,
                    dateValues = [],
                    dateToday = this._startOfDayToday();

                if (jsvfElement.$jsvfElement !== undefined) {
                    validationOrder = jsvfElement.$jsvfElement.find('.formFieldDate').attr('data-validationOrder');
                }

                if (validationOrder !== undefined) {
                    dateValues = validationOrder.split(' ');
                } else {
                    dateValues = ['Month', 'Day', 'Year'];
                }

                var yearInArray = $.inArray('Year', dateValues),
                    dayInArray = $.inArray('Day', dateValues),
                    monthInArray = $.inArray('Month', dateValues),
                    y = dateToday.getFullYear(),
                    d = dateToday.getDate(),
                    m = dateToday.getMonth() + 1;
                if (yearInArray !== -1) {
                    y = parseInt(value[yearInArray] || 0, 10);
                }
                if (dayInArray !== -1) {
                    d = parseInt(value[dayInArray] || 0, 10);
                }
                if (monthInArray !== -1) {
                    m = parseInt(value[monthInArray] || 0, 10);
                }
                var arrMin = (options.min || '0000-00-00').split('-'),
                    arrMax = (options.max || '0000-00-00').split('-'),
                    min = 'today' === options.min ? this._startOfDayToday() :
                        new Date(arrMin[0], arrMin[1] - 1, arrMin[2]),
                    max = 'today' === options.max ? this._startOfDayToday() :
                        new Date(arrMax[0], arrMax[1] - 1, arrMax[2]);

                value = new Date(y, m-1, d);
                if (options.inclusive) {
                    if (min > value || value > max) {
                        callback(validationToken, Validation.STATUS_INVALID, 'notBetween');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else {
                    if (min >= value || value >= max) {
                        callback(validationToken, Validation.STATUS_INVALID, 'notBetweenStrict');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                }
            },
            _startOfDayToday:function() {
                var startOfDayToday = new Date();
                startOfDayToday.setHours(0);
                startOfDayToday.setMinutes(0);
                startOfDayToday.setSeconds(0);
                startOfDayToday.setMilliseconds(0);
                return startOfDayToday;
            }
        },
        DateEarlier: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                var $targetJsvfElement = jsvfElement.$node.closest('form')
                        .find('[id$="'+ options.targetElement +'"]').closest('.jsvfElement'),
                    targetJsvfElement = new Validation.JsvfElement($targetJsvfElement),
                    targetValue = targetJsvfElement.getValue(),
                    sourceDate = new Date(value),
                    targetDate = new Date(targetValue);

                if (typeof options.reverse !== undefined && options.reverse === '1') {
                    sourceDate = new Date(targetValue);
                    targetDate = new Date(value);
                }

                if (sourceDate > targetDate) {
                    callback(validationToken, Validation.STATUS_INVALID, 'isLater');
                } else {
                    // The given Date is Earlier
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        ConditionalRegex : {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                var $targetJsvfElement = jsvfElement.$node.closest(options.targetContainer)
                        .find("[id$=" + options.targetElement + "]").closest('.jsvfElement'),
                    targetJsvfElement = new Validation.JsvfElement($targetJsvfElement),
                    targetValue = targetJsvfElement.getValue(),
                    key = null;

                if (options.bindingRules.hasOwnProperty(targetValue)) {
                    key = targetValue;
                } else if (options.bindingRules['default'] !== undefined) {
                    key = 'default';
                }

                if (null !== key) {
                    var regexValidator = new Validation.Validator(
                        {
                            name: 'Regex',
                            breakChainOnFailure: false,
                            options: {pattern: options.bindingRules[key]}
                        },
                        jsvfElement
                    );

                    $(regexValidator).bind(Validation.EVENT_VALIDATED,
                        function(e, responseValidationToken, status, errorMessage) {
                            if (Validation.STATUS_VALID === status) {
                                callback(validationToken, Validation.STATUS_VALID);
                            } else if (Validation.STATUS_INVALID === status) {
                                callback(validationToken, Validation.STATUS_INVALID, key);
                            }
                        }
                    );
                    regexValidator.validate();
                }
            }
        },
        NonSequential: {
            execute : function(value, jsvfElement, options, validationToken, callback) {

                var MAX_SEQUENCE_NUMBER = 9,
                    MIN_SEQUENCE_NUMBER = 0,
                    MIN_SEQUENCE_LENGTH = 1,
                    NEGATIVE_INCREMENT = -1,
                    POSITIVE_INCREMENT = 1,
                    NO_INCREMENT = 0;

                /**
                 * Calculates the sequence increment
                 *
                 * @param string Sequence string
                 * @return int Increment
                 */
                var _calculateSequenceIncrement = function(sequence) {
                    // Determines whether the sequence is decreasing or increasing
                    var delta = sequence[1] - sequence[0];
                    return delta > MIN_SEQUENCE_NUMBER ? POSITIVE_INCREMENT : (
                        delta < MIN_SEQUENCE_NUMBER ? NEGATIVE_INCREMENT : NO_INCREMENT
                    );
                };

                /**
                 * Get the next or previous number of a sequence
                 *
                 * If "item" is the maximum of the sequence and increase,
                 * the next item will be the minimum sequence number.
                 *
                 * If "item" is the minimum of the sequence and decreases,
                 * the next item will be the maximum sequence number.
                 *
                 * @param int item
                 * @param int increment
                 * @return int
                 */
                var _getNext = function(item, increment) {
                    var next;

                    if (item === MAX_SEQUENCE_NUMBER && increment > 0) {
                        next = MIN_SEQUENCE_NUMBER;
                    } else if (item === MIN_SEQUENCE_NUMBER && increment < 0) {
                        next = MAX_SEQUENCE_NUMBER;
                    } else {
                        next = item + increment;
                    }

                    return next;
                };

                /**
                 * Validate if the value is nonsequential
                 *
                 * @param string the value we want to check.
                 * @return bool
                 */
                var _validateIsNotSequential = function(sequence) {
                    var elements = sequence.split('').map(function(e) { return parseInt(e, 10); }),
                        sequenceLength = elements.length,
                        isNotSequential = false,
                        i,
                        iMax = sequenceLength - 1,
                        // Calculate if the sequence is incremental or decremental
                        increment = _calculateSequenceIncrement(elements);

                    // there is two or more numbers in the sequence
                    if (sequenceLength > MIN_SEQUENCE_LENGTH) {
                        for (i = 0; i < iMax; ++i) {
                            if (elements[i + 1] !== _getNext(elements[i], increment)) {
                                isNotSequential = true;
                            }
                        }
                    }

                    return isNotSequential;
                };

                // If nonSequential is true return valid
                if (_validateIsNotSequential(value)) {
                    callback(validationToken, Validation.STATUS_VALID);
                } else {
                    callback(validationToken, Validation.STATUS_INVALID, 'isSequential');
                }
            }
        },
        NotInArray : {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                if ($.inArray(value, options.haystack) !== -1) {
                    callback(validationToken, Validation.STATUS_INVALID, 'notInArray');
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        NotDirtyWord: {
            execute: function(value, jsvfElement, options, validationToken, callback) {
                if (isAccordionEnabled()) {
                        callback(validationToken, Validation.STATUS_VALID);
                } else {
                    if (this._cache.hasOwnProperty(value)) {
                        if (this._cache[value]) {
                            callback(validationToken, Validation.STATUS_VALID);
                        } else {
                            callback(validationToken, Validation.STATUS_INVALID, 'isDirtyWord');
                        }
                    } else {
                        var instance = this;
                        var type = options.type || 'default';
                        PEP.dirtyWord.totalRequestsInProgress++;

                        PEP.dirtyWord.filter(value, type, function(dirtyWordFound, ajaxError) {
                            if (dirtyWordFound) {
                                instance._cache[value] = false;
                                callback(validationToken, Validation.STATUS_INVALID, 'isDirtyWord');
                            } else if (ajaxError) {
                                // If true, this will callback and display the error message like the
                                // standard behavior
                                if (options.showServiceErrorAsMessage) {
                                    callback(validationToken, Validation.STATUS_INVALID, 'DirtyWordServiceFailure');
                                }
                                jsvfElement.$elements.trigger('dirtyWordServiceError');
                            } else {
                                instance._cache[value] = true;
                                callback(validationToken, Validation.STATUS_VALID);
                            }
                            PEP.dirtyWord.totalRequestsInProgress--;
                            if (PEP.dirtyWord.totalRequestsInProgress <= 0) {
                                jsvfElement.$elements.trigger('dirtyWordFilterDone');
                            }
                        }, !!options.failOnFailure);
                    }
                }
            },
            _cache: {}
        },
        ValidPassholderId: {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                // @todo -- these should be coming from the server somehow
                var VISUAL_ID_LENGTH = 12,
                    BARCODE_LENGTH = 17,
                    PREMIER_LENGTH = 20;

                if (value.length === VISUAL_ID_LENGTH) {

                    var $element = jsvfElement.$elements;

                    // skip the async validation if 'validateVisualIdSkip' is set -- used when
                    // a form is being submitted
                    if ($element.data('validateVisualIdSkip')) {
                        $element.data('validateVisualIdSkip', null);
                        callback(validationToken, Validation.STATUS_VALID);

                    // just a regular blur on the field, so continue with the async validation
                    } else {
                        var successCallback = function(data) {
                            if (typeof data.errors !== 'undefined') {
                                callback(validationToken, Validation.STATUS_INVALID, 'InvalidVisualId');
                            } else {
                                callback(validationToken, Validation.STATUS_VALID);
                            }
                        };

                        var errorCallback = function(jqXHR, status, error, extra) {
                            // if the ajax request completely fails (or is cancelled), mark the field as valid;
                            // the server side validation will still take place, so this won't
                            // hurt anything
                            callback(validationToken, Validation.STATUS_VALID);
                        };

                        PEP.serviceClient.services.validatePass.validateVisualId(
                            value,
                            {
                                success: successCallback,
                                error: errorCallback
                            }
                        );
                    }

                } else if (value.length === BARCODE_LENGTH || value.length === PREMIER_LENGTH) {
                    // No need to validate barcodes beyond the length; Validation PASSED
                    callback(validationToken, Validation.STATUS_VALID);

                } else {
                    // Invalid length; Validation FAILED
                    callback(validationToken, Validation.STATUS_INVALID, 'InvalidLength');
                }
            }
        },
        ValidMep: {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                // the 'mepInvalid' data value is set elsewhere, as it is reliant on an ajax response
                if (jsvfElement.$node.data('mepInvalid')) {
                    callback(validationToken, Validation.STATUS_INVALID, 'InvalidMep');
                } else if (jsvfElement.$node.data('notClaimable')) {
                    callback(validationToken, Validation.STATUS_INVALID, 'NotClaimable');
                }else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        },
        ValidationTrigger : {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                var $targetJsvfElement = jsvfElement.$node.closest('form').find(options.targetElement),
                    targetJsvfElement = new Validation.JsvfElement($targetJsvfElement.closest('.jsvfElement')),
                    cancelValidation = false;
                if (options.cancelOnEmptyValue && $targetJsvfElement.val().length  === 0) {
                    cancelValidation = true;
                }
                if (!cancelValidation) {
                    targetJsvfElement.validate();
                } else if (options.applyOnSelf) {
                    jsvfElement.enableValidators(false, true);
                } else {
                    jsvfElement.enableValidators(true);
                }

                callback(validationToken, Validation.STATUS_VALID);
            }
        },
        CareGiverFilter: {
            execute : function(value, jsvfElement, options, validationToken, callback) {
                if (PEP.Config.Toggles.Release.CareGiverFilter && PEP.Config.SiteId === 'dlr') {
                    //check if has preConcat or postConcat options for validate the CareGiver Filter
                    var wordsNotAllowed = options.arrNotAllowed,
                        $fieldForConcat = null,
                        fieldForConcat = '',
                        fieldObj = null,
                        result = false,
                        fullName = '';
                    value = value.trim().toLowerCase();


                    if (options.preConcatWith !== null) {
                        $fieldForConcat = $('#' + options.preConcatWith);
                        fieldForConcat = $fieldForConcat.length ? $fieldForConcat.val().trim() : '';
                        fullName = (fieldForConcat + value).toLowerCase();
                    }

                    if (options.postConcatWith !== null) {
                        $fieldForConcat = $('#' + options.postConcatWith);
                        fieldForConcat = $fieldForConcat.length ? $fieldForConcat.val().trim() : '';
                        fullName = (value + fieldForConcat).toLowerCase();
                    }

                    result = careGiverExists(value, fullName, wordsNotAllowed.careGiverFilter);
                    if (result) {
                        callback(validationToken, Validation.STATUS_INVALID, 'isCareGiver');
                    } else {
                        callback(validationToken, Validation.STATUS_VALID);
                    }
                } else {
                    callback(validationToken, Validation.STATUS_VALID);
                }
            }
        }
    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #12 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.Validator class
 */
(function($, Validation) {

    /**
     * ---------------
     * Validator class
     * ---------------
     * A Validator object performs validations over a JsvfElement object.
     * Acts as an interface between ValidatorCommands and the rest of the framework making validations Event Based.
     * Allows you to validate using different commands (a sort of mixture between Command and Strategy patterns) all
     * of them belongs to the ValidatorCommands Singleton object.
     * A Validator::validate() method doesn't returns anything, all validations works based on events.
     *
     * Methods:
     *  + validate()
     *  + isValid()
     */
    Validation.Validator = function(config, jsvfElement)
    {
        var instance = this,
            settings = {},
            validatorStatus = Validation.STATUS_NOTVALIDATED;

        if ('string' === typeof config) {
            settings.name = config;
            settings.jsvfElement = jsvfElement;
        } else if ($.isArray(config)) {
            settings = {
                name: config.shift(),
                breakChainOnFailure: config.shift(),
                options: config.shift(),
                errorMessages: config.shift(),
                jsvfElement: jsvfElement
            };
        } else if ('object' === typeof config) {
            $.extend(settings, {jsvfElement: jsvfElement, errorMessages: {}}, config);
        }
        $.extend(this, settings);

        var createErrorMessage = function(errorKey, errorTokens) {
            var message = settings.errorMessages[errorKey] || '';
            for (var token in errorTokens) {
                if (errorTokens.hasOwnProperty(token)) {
                    message = message.replace(new RegExp('%' + token + '%',"g"), errorTokens[token]);
                }
            }
            return message;
        };

        this.validate = function(validationToken) {
            var callback = function(validationToken, status, errorKey, appendErrorMessageTokens) {
                var errorMessage = null;
                validatorStatus = status;
                if (Validation.STATUS_INVALID === status) {
                    var defaultErrorMessageTokens = {
                        label: jsvfElement.label,
                        value: jsvfElement.getValue()
                    };
                    $.extend(defaultErrorMessageTokens, this.options, appendErrorMessageTokens);
                    errorMessage = createErrorMessage(errorKey, defaultErrorMessageTokens);
                }
                $(instance).trigger(Validation.EVENT_VALIDATED, [validationToken, status, errorMessage]);
            };
            if (Validation.ValidatorCommands[settings.name]) {
                Validation.ValidatorCommands[settings.name].execute(
                    instance.jsvfElement.getValue(), instance.jsvfElement, instance.options, validationToken, callback);
            }
        };
        this.isValid = function() {
            return Validation.STATUS_VALID === validatorStatus ? true : false;
        };
    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576944 $
 * - $DateTime: 2015/05/26 00:30:13 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #14 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.QueueValidators class
 * Validation.QueueElements class
 */
(function($, Validation) {

    /**
     * ---------------------
     * QueueValidators class
     * ---------------------
     * A Queue of Validator objects.
     * Allows you to validate a sorted set of validators with the breakChainOnFailure feature.
     *
     * Methods:
     *  + add(Validator)
     *  + validate()
     *  + isValid()
     *  + each(callback)
     */
    Validation.QueueValidators = function(jsvfElement)
    {
        var queue = [], // [validatorName, ..]
            validators = {}, // {validatorName : [validator, status, errorMessage]}
            eventResponsesCounter = -1,
            queueStatus = Validation.STATUS_NOTVALIDATED,
            instance = this,
            tokenMap = {}, // {instanceValidationToken: callbackValidationToken}
            instanceValidationToken = 0; // token id for a specific validate() call.  We need to check event responses
                                         // for if they belongs to the last validate() call of the queue.

        this.jsvfElement = jsvfElement;
        this.errorMessage = null;

        this.add = function(validator) {
            queue.push(validator.name);
            validators[validator.name] = [validator, Validation.STATUS_NOTVALIDATED, null];
            $(validator).bind(Validation.EVENT_VALIDATED,
                function(e, responseValidationToken, status, errorMessage) {
                    if (responseValidationToken === instanceValidationToken) {
                        eventResponsesCounter--;
                    }
                    if (Validation.STATUS_INVALID === queueStatus ||
                        responseValidationToken !== instanceValidationToken) {
                            // ignore after break chain or if the event doesn't belong to the last validate() call
                            return false;
                    }
                    validators[this.name][1] = status;
                    validators[this.name][2] = errorMessage;
                    if (Validation.STATUS_INVALID === status && this.breakChainOnFailure) {
                        eventResponsesCounter = 0;
                        queueStatus = Validation.STATUS_INVALID;
                        instance.errorMessage = errorMessage;
                        $(instance).trigger(Validation.EVENT_VALIDATED,
                            [tokenMap[responseValidationToken], queueStatus, errorMessage]);
                    } else if (0 === eventResponsesCounter) {
                        queueStatus = Validation.STATUS_VALID;
                        var queueLength = queue.length;
                        for (var i = 0; i < queueLength; i++) {
                            if (Validation.STATUS_INVALID === validators[queue[i]][1]) {
                                queueStatus = Validation.STATUS_INVALID;
                                instance.errorMessage = (errorMessage === null) ?
                                        validators[queue[i]][2] : errorMessage;
                                break;
                            }
                        }
                        $(instance).trigger(Validation.EVENT_VALIDATED,
                            [tokenMap[responseValidationToken], queueStatus, instance.errorMessage]);
                    }
            });
        };

        this.getValidator = function(validatorName) {
            return typeof validators[validatorName] === "undefined" ? null : validators[validatorName][0];
        };

        this.remove = function(validatorName) {
            if (typeof validators[validatorName] === "undefined") {
                return;
            }

            //remove from queue
            var queueLength = queue.length,
                tempQueue = [];
            for (var i = 0; i < queueLength; i++) {
                if (queue[i] !== validatorName) {
                    tempQueue.push(queue[i]);
                }
            }
            queue = tempQueue;

            // unbind
            $(validators[validatorName][0]).unbind();

            // remove from validators
            var tempValidators = {},
                validatorsLength = validators.length;
            for (var name in validators) {
                if (name !== validatorName) {
                    tempValidators[name] = validators[name];
                }
            }
            validators = tempValidators;
        };

        this.validate = function(validationToken, mustValidate) {
            if (typeof(mustValidate) === 'undefined') {
                mustValidate = true;
            }

            if (!mustValidate) {
                $(instance).trigger(Validation.EVENT_VALIDATED,
                    [validationToken, Validation.STATUS_VALID, instance.errorMessage]);
                return;
            }

            tokenMap[++instanceValidationToken] = validationToken;
            queueStatus = Validation.STATUS_WAITING;
            this.errorMessage = null;
            var queueLength = queue.length;
            if (0 === queueLength) {
                queueStatus = Validation.STATUS_VALID;
                $(instance).trigger(Validation.EVENT_VALIDATED,
                    [validationToken, queueStatus, instance.errorMessage]);
                return;
            }
            eventResponsesCounter = queueLength;
            for (var i = 0; i < queueLength; i++) {
                if (this.jsvfElement.mustValidate()) {
                    validators[queue[i]][0].validate(instanceValidationToken);
                }
            }
            this.jsvfElement.resetNoValidate();

            setTimeout(function() {
                if (0 !== eventResponsesCounter && Validation.STATUS_WAITING === queueStatus) {
                    queueStatus = Validation.STATUS_TIMEOUT;
                }
            }, Validation.VALIDATOR_VALIDATE_TIMEOUT);
        };

        this.isValid = function() {
            return Validation.STATUS_VALID === queueStatus;
        };

        this.each = function(callback) {
            var queueLength = queue.length;
            for (var i = 0; i < queueLength; i++) {
                // params: [validator, status, errorMessage]}
                callback.apply(validators[queue[i]][0], validators[queue[i]]);
            }
        };
    };


    /**
     * ---------------------
     * QueueElements class
     * ---------------------
     * A Queue of Elements objects.
     * Allows you to validate an unsorted set of QueueValidators.
     *  + add(QueueValidators)
     *  + validate(validationToken)
     *  + isValid()
     *  + hasInvalids()
     *  + each(callback)
     */
    Validation.QueueElements = function()
    {
        var queue = [], // [elementName, ...]
            validatorQueues = {}, // {element.name : [validatorQueue, status, errorMessage]}
            eventResponsesCounter = -1,
            queueStatus = Validation.STATUS_NOTVALIDATED,
            instance = this,
            tokenMap = {},
            instanceValidationToken = 0; // token id for a specific validate() call.  We need to check event responses
                                         // for if they belongs to the last validate() call of the queue.

        this.add = function(validatorQueue) {
            var queueKey = validatorQueue.jsvfElement.name;
            queue.push(queueKey);
            validatorQueues[queueKey] = [validatorQueue, Validation.STATUS_NOTVALIDATED, null];
            $(validatorQueue).bind(Validation.EVENT_VALIDATED,
                function(e, responseValidationToken, status, errorMessage) {
                    var queueKey = this.jsvfElement.name;
                    validatorQueues[queueKey][1] = status;
                    validatorQueues[queueKey][2] = errorMessage;
                    if (responseValidationToken !== instanceValidationToken) {
                        $(instance).trigger(Validation.EVENT_VALIDATED,
                            [tokenMap[responseValidationToken], queueStatus]);
                    } else {
                        if (0 === --eventResponsesCounter) {
                            queueStatus = Validation.STATUS_VALID;
                            var queueLength = queue.length;
                            for (var i = 0; i < queueLength; i++) {
                                if (Validation.STATUS_INVALID === validatorQueues[queue[i]][1]) {
                                    queueStatus = Validation.STATUS_INVALID;
                                    break;
                                }
                            }
                            $(instance).trigger(Validation.EVENT_VALIDATED,
                                [tokenMap[responseValidationToken], queueStatus]);
                        }
                    }
            });
        };

        this.validate = function(validationToken) {
            tokenMap[++instanceValidationToken] = validationToken || 1;
            queueStatus = Validation.STATUS_WAITING;
            var queueLength = queue.length;
            if (0 === queueLength) {
                queueStatus = Validation.STATUS_VALID;
                $(instance).trigger(Validation.EVENT_VALIDATED, [validationToken, queueStatus, instance.errorMessage]);
                return;
            }
            eventResponsesCounter = queueLength;
            for (var i = 0; i < queueLength; i++) {
                validatorQueues[queue[i]][0].validate(
                    instanceValidationToken, 
                    validatorQueues[queue[i]][0].jsvfElement.mustValidate()
                );
            }
            setTimeout(function() {
                if (0 !== eventResponsesCounter && Validation.STATUS_WAITING === queueStatus) {
                    queueStatus = Validation.STATUS_TIMEOUT;
                }
            }, Validation.VALIDATION_QUEUE_VALIDATE_TIMEOUT);
        };

        this.isValid = function() {
            return Validation.STATUS_VALID === queueStatus;
        };

        this.hasInvalids = function() {
            var queueLength = queue.length;
            for (var i = 0; i < queueLength; i++) {
                if (Validation.STATUS_INVALID === validatorQueues[queue[i]][1]) {
                    return true;
                }
            }
            return false;
        };

        this.each = function(callback) {
            var queueLength = queue.length;
            for (var i = 0; i < queueLength; i++) {
                // params: [validatorQueue, status, errorMessage]}
                callback.apply(validatorQueues[queue[i]][0], validatorQueues[queue[i]]);
            }
        };
    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #52 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.ErrorReporterInline class
 * Validation.ErrorReporterAlert class
 * Validation.ErrorReporterFormSummary class
 */
(function($, Validation) {

    /**
     * Determines if a DOM element is visible in the current viewport
     *
     * @param jQuery|selector $element
     * @param jQuery|selector $currentWindow
     *
     * @return boolean
     */
    function isElementInViewport($element, $currentWindow) {
        $element = $($element);

        var offset = $element.offset();

        if (offset) {
            var elementTop = offset.top,
            elementBottom = offset.top + $element.height(),
            windowTop = $currentWindow.scrollTop(),
            windowBottom = windowTop + $currentWindow.height();
            return (elementTop > windowTop && elementBottom < windowBottom);
        } else {
            return true;
        }
    }

    /**
     * -------------------------
     * ErrorReporterInline class
     * -------------------------
     * A JsvfElement's level error reporter.
     * Shows an errors list below the JsvfElement just like the Zend's Error Decorator.
     * There is a relation one to one between JsvfElement and ErrorReporterInline.  As the rest of error reporters,
     * once instantiated it can listen a QueueValidators object like with the Observer pattern.
     * Each time the QueueValidators is validated, the error reporter will update its status.  You are able to change
     * the QueueValidators object in runtime when you desire.
     * Example:
     *      var myReporter = new Validation.ErrorReporterInline(),
     *          myJsvfElement = new Validation.JsvfElement($('.jsvfElement'));
     *      myReporter.listen(myJsvfElement.validatorQueue);
     *      myJsvfElement.validate();
     *  Will result in:
     *      <div class="jsvfElement jsvfError">
     *          <label for="someField">Some Field</label>
     *          <input type="text" name="someField" id="someField">
     *          <ul class="errors">
     *              <li id="someField-validationError">Some Field is required.</li>
     *          </ul>
     *      </div>
     *
     * Methods:
     *  + listen(QueueValidators)
     *  + render()
     *  + clear()
     */
    Validation.ErrorReporterInline = function()
    {
        this.queue = null;
        this.CONTAINER_CLASS = 'inlineErrors';
    };

    Validation.ErrorReporterInline.prototype = {
        _triggerRenderAnimationComplete: function() {
            var $jsvfElement = this.queue.jsvfElement.$jsvfElement;
            if ($jsvfElement) {
                $jsvfElement.trigger(PEP.Validation.ERROR_ANIMATION_COMPLETE);
            }
        },
        _triggerRenderComplete: function() {
            var $jsvfElement = this.queue.jsvfElement.$jsvfElement;
            if ($jsvfElement) {
                $jsvfElement.trigger(PEP.Validation.ERROR_RENDER_COMPLETE);
            }
        },
        listen: function(validationQueue) {
            var that = this;
            $(validationQueue).bind(Validation.EVENT_VALIDATED + '.ErrorReporterInline',
                function(e, validationToken, queueStatus) {
                    if (this instanceof Validation.QueueValidators) {
                        that.queue = this;
                        that.render();
                    }
            });
        },
        render: function() {
            var that = this,
                errorsHtml = [],
                jsvfElement = this.queue.jsvfElement;
            this.queue.each(function(validatorQueue, status, errorMessage) {
                //  The whole code is intended to be executed when the queue status is invalid, and the status
                //  should never come as invalid when the jsvfElement is set as validate. However, it seems
                //  that in some cases it can get to this point with an invalid status and the jsvfElement set
                //  as no-validate. An example is given in the pull request for the added condition
                if (Validation.STATUS_INVALID === status && jsvfElement.mustValidate()) {
                    if (typeof validatorQueue.breakChainOnFailure !== "undefined" &&
                        validatorQueue.breakChainOnFailure === 'true' &&
                        errorsHtml.length > 0
                    ) {
                        return false;
                    }

                    // collect all the error types
                    var errorTypeString = "";
                    if (typeof validatorQueue.errorMessages !== "undefined") {
                        for (var errorType in validatorQueue.errorMessages) {
                            if (typeof errorType !== "undefined" && errorType !== "") {
                                errorTypeString = errorTypeString + errorType + " ";
                            }
                        }
                    }

                    // add aria-describedby attribute for accessibility
                    var errorId = jsvfElement.getErrorId();
                    var errorLabelId = errorId.replace(/.*\[(.*)\]/,"$1");
                    $(errorId).attr('aria-describedby', errorLabelId);

                    var alertIconToggle = PEP.Config.Toggles.Release.expressCheckoutEnableAlertIcon;
                    var alertIconHtml = alertIconToggle ? '<span role="alert" aria-label="error" class="alertIcon"></span>' : '';
                    var alertClass = !alertIconToggle ? 'pseudo-element-icon ' : '';

                    var errorLabel = '<li id="' + errorLabelId +
                        '" class="' + alertClass + errorTypeString + '">' + alertIconHtml + errorMessage + '</li>';

                    errorsHtml.push(errorLabel);
                }
            });
            jsvfElement.markAsCorrect();

            // if current elemet is a radio with conditioanl items inside
            // remove only the top level errors
            if (jsvfElement.$node.find('.radioConditional').length > 0) {
                jsvfElement.$node.find('.inlineErrors').each(function() {
                    var parentJsvfElement = $(this).closest('.jsvfElement');
                    if (
                        !(
                            parentJsvfElement.hasClass('childElement') &&
                            parentJsvfElement !== jsvfElement.$node
                        )
                    ) {
                        this.remove();
                    }
                });
            } else {
                jsvfElement.$node.find('ul.' + this.CONTAINER_CLASS).remove();
            }

            var inputRow = jsvfElement.$node.parents('.inputRow'),
                jsvfElementName,
                fieldsetSearch;
            var $validationContents = $('.validationContents', inputRow);
            var serverSideErrorSelectorString = '';
            if (errorsHtml.length > 0) {

                /* Handle error style for a row of inline elements */
                if (inputRow.length === 1) {
                    /* Form elements comprised of multiple inputs (like dates) tag their error messages in
                    a unique way (not by individual input name).  Adjust variables to account for fieldsets. */
                    fieldsetSearch = jsvfElement.$node.find('fieldset');
                    if (fieldsetSearch.length > 0) {
                        jsvfElementName = fieldsetSearch.attr('id');
                    } else {
                        jsvfElementName = jsvfElement.$node.find('.inputElement').attr('name')
                            .replace(/.*\[(.*)\]/,"$1");
                    }
                    var errorClass = $.trim($(errorsHtml[0]).attr('class')).replace(/ /g, '.');
                    var selectorString = '#' + jsvfElementName + '-validationError.' + errorClass;
                    var existingError = $validationContents.find(selectorString);
                    serverSideErrorSelectorString = '.' + jsvfElementName + '-validationError';
                    var $serverSideErrors = $validationContents.find(serverSideErrorSelectorString);
                    // remove any server side validation for this field
                    if ($serverSideErrors.length !== 0) {
                        // set the last error to have an id matching this field, then fadeOut/slideUp the rest
                        var $serverSideSiblings = $serverSideErrors.eq(0)
                            .attr('id', jsvfElementName + '-validationError')
                            .siblings(serverSideErrorSelectorString);
                        if ($('html').hasClass('opacity')) {
                            $serverSideSiblings.fadeTo(
                                100, 0, function() {
                                    $(this).slideUp(200, 'swing', function() {
                                        $(this).remove();
                                    });
                                }
                            );
                        } else {
                            $serverSideSiblings.slideUp(200, 'swing', function() {
                                $(this).remove();
                            });
                        }
                    }

                    /* Only perform an action if a new or different error has occurred.  If the discovered error
                       is already displayed to the user, do nothing. */
                    if (existingError.length === 0) {

                        var removePreviousFieldError = $validationContents
                            .find('#' + jsvfElementName + '-validationError');

                        /* if a different error has occurred on the same field, swap out the error messages */
                        if ($('html').hasClass('opacity')) {
                            // @TODO - make this use CSS3 transitions instead of jQuery animation
                            removePreviousFieldError.fadeTo(
                                100, 0, function() {
                                    var newError = $(errorsHtml[0]).css('opacity', '0');
                                    $(this).replaceWith(newError);
                                    newError.fadeTo(100, 1);
                                }
                            );
                        } else {
                            var newError = $(errorsHtml[0]);
                            removePreviousFieldError.replaceWith(newError);
                        }

                        /* If the error is brand new for a field, append the new error and trigger slide animation */
                        if (removePreviousFieldError.length === 0) {
                            // @TODO - make this use CSS3 transitions instead of jQuery animation
                            if ($('html').hasClass('opacity')) {
                                $(errorsHtml[0])
                                    .css({'display': 'none', 'opacity': 0})
                                    .appendTo($validationContents)
                                    .slideDown(150, 'swing')
                                    .fadeTo(100, 1);
                            } else {
                                $(errorsHtml[0])
                                    .css({'display': 'none'})
                                    .appendTo($validationContents)
                                    .slideDown(150, 'swing');
                            }

                            $(errorsHtml[0]).promise().done(function(){
                                that._triggerRenderAnimationComplete();
                            });

                        }
                    }


                /* Handle error placement when the element has defined where to append the error */
                } else if (jsvfElement.$node.find('input').attr('data-errorAppendSelector') !== undefined &&
                    inputRow.length === 0) {
                    jsvfElement.$node.find(jsvfElement.$node.find('input').attr('data-errorAppendSelector')).append(
                        $('<ul class="' + this.CONTAINER_CLASS + '"></ul>').html(errorsHtml.join(''))
                    );

                /* Handle the generic case where an element has not indicated how to display error messages */
                } else if (inputRow.length === 0) {
                    jsvfElement.$node.append(
                        $('<ul class="' + this.CONTAINER_CLASS + '"></ul>').html(errorsHtml.join(''))
                    );
                }
                jsvfElement.markAsErroneous();
            } else {
                /* if the error was fixed for an inline row field, slide up and remove the bullet point */
                if (inputRow.length === 1) {
                    jsvfElementName = jsvfElement.$node.find('.inputElement')
                        .removeAttr('aria-describedby')
                        .attr('name').replace(/.*\[(.*)\]/,"$1");

                    /* Adjust variables to account for the removal of fieldset errors. */
                    fieldsetSearch = jsvfElement.$node.find('fieldset');
                    if (fieldsetSearch.length > 0) {
                        jsvfElementName = fieldsetSearch.attr('id');
                    }

                    // server side errors
                    serverSideErrorSelectorString = '.' + jsvfElementName + '-validationError';

                    if ($('html').hasClass('opacity')) {
                        $validationContents
                            .find('#' + jsvfElementName + '-validationError,' + serverSideErrorSelectorString)
                            .fadeTo(
                                100, 0, function() {
                                    $(this).slideUp(200, 'swing', function() {
                                        $(this).remove();
                                        that._triggerRenderAnimationComplete();
                                    });
                                }
                            );
                    } else {
                        $validationContents
                            .find('#' + jsvfElementName + '-validationError, ' + serverSideErrorSelectorString)
                            .slideUp(200, 'swing', function() {
                                $(this).remove();
                                that._triggerRenderAnimationComplete();
                            });
                    }
                }
            }

            that._triggerRenderComplete();
        },
        clear: function() {
            if (null !== this.queue) {
                var jsvfElement = this.queue.jsvfElement;
                jsvfElement.markAsCorrect();
                jsvfElement.$node.find('ul.' + this.CONTAINER_CLASS).remove();
            }
        }
    };


    /**
     * ------------------------
     * ErrorReporterAlert class
     * ------------------------
     * A JsvfElementSet's level error reporter, commonly used along with ErrorReporterInline reporters.
     * Displays a custom HTML content if there is an error in a JsvfElementSet.
     * There is a relation one to one between JsvfElementSet and ErrorReporterAlert.  As the rest of error reporters,
     * once instantiated it can listen a QueueElements object like with the Observer pattern.
     * Each time the QueueElements is validated, the error reporter will update its status.  You are able to change
     * the QueueElements object in runtime when you desire.
     * Example:
     *      var myReporter = new Validation.ErrorReporterAlert(
     *          $('.pageErrorsContainer'),
     *          '<div class="message">Errors were detected in your submission</div>',
     *          ),
     *          myJsvfElementSet = new Validation.JsvfElementSet($('fieldset'));
     *      myReporter.listen(myJsvfElementSet.elementQueue);
     *      myJsvfElementSet.validate();
     *  Will result in:
     *      <div class="formErrorsContainer">
     *          <div class="message">Errors were detected in your submission</div>
     *      </div>
     * NOTE: $('.formErrorsContainer') can be a jQuery collection of containers, so the error message will be placed
     *       on each one.
     *
     * Methods:
     *  + listen(QueueElements)
     *  + render()
     *  + clear()
     */
    Validation.ErrorReporterAlert = function($container, pageLevelErrorsHTML, forceRefresh)
    {
        this.queue = null;
        this.$container = $container;
        this.pageLevelErrorsHTML = pageLevelErrorsHTML;
        this.forceRefresh = forceRefresh || false;
    };

    Validation.ErrorReporterAlert.prototype = {
        listen: function(validationQueue) {
            var that = this;
            $(validationQueue).bind(Validation.EVENT_VALIDATED + '.ErrorReporterAlert',
                function(e, validationToken, queueStatus) {
                    // validationToken is undefined unless the form is being submitted
                    if (typeof validationToken !== 'undefined' && this instanceof Validation.QueueElements) {
                        that.queue = this;
                        that.render();
                    }
            });
        },
        render: function() {
            var that = this,
                $form = that.$container.parents('form');

            if ($form.length === 0) {
                /* $form = $('form');
                @todo - this must be improved. search for all the forms in the
                document brokes when trying to access $form.attr('data-pageLevelA11yMessage')
                in cases when the first form finded does not have this attribute
                */
                $form = $('form[data-pageLevelA11yMessage]');
            }

            // see, !hasInvalids() is not the same as isValid()
            if (!that.queue.hasInvalids()) {
                that.$container.stop(true, true).slideUp('fast', function(){ that.$container.html(''); });
            } else if (that.$container.html() === '' || this.forceRefresh) {
                that.$container.hide().html(that.pageLevelErrorsHTML).stop(true, true).slideDown('fast');
                $('<span />').addClass('accessibleText errorAnnouncements')
                    .attr('aria-live', 'assertive')
                    .html($form.attr('data-pageLevelA11yMessage'))
                    .appendTo(that.$container.find('.message'));

                that.addA11yText();
                that.scrollToFirstError();

                if (that.hasError) {
                    // @todo - the JSVF should not be used with the Errors Summary Box helper.  This should be
                    // removed when all pages are moved over to the Page Level Input Warning helper
                    $('.errorsSummaryBox .message').focus();
                }
            } else {
                $('.errorAnnouncements')
                    .removeAttr('aria-live')
                    .attr('aria-live', 'assertive')
                    .html($form.attr('data-pageLevelA11yMessage'));

                that.addA11yText();
                that.scrollToFirstError();
            }
        },
        addA11yText: function() {
            var errorList = $('.errorAnnouncements');
            $('.jsvfElement.hasErrors').each(function(index, value) {
                var errorListEntry = '';
                if (index !== 0) {
                    errorListEntry = ', ';
                }
                errorListEntry += $(value).find('.labelValue').text();
                errorList.append($('<span />').html(errorListEntry));
            });

            $('.pageLevelError .message').attr('role', 'alert');
        },
        scrollToFirstError: function() {
            var $errorMessage = $('.pageLevelError .message'),
                $inlineErrorMessages = $('ul.validationContents li, ul.inlineErrors li'),
                $firstInlineError = $inlineErrorMessages.length > 0 ? $inlineErrorMessages.eq(0) : null,
                $scrollTarget = $errorMessage,
                $viewportTarget = $errorMessage,
                threshold = 0,
                $modalWindow = $('#tmp_overlay_background'),
                $isFullModalWindow = $('.fullSize.ui-dialog').length !== 0,
                $currentWindow = $isFullModalWindow ? $modalWindow : $(window) ;

            if ($firstInlineError) {
                $viewportTarget = $firstInlineError;
                if (
                    ($firstInlineError.offset().top + $firstInlineError.height() > $currentWindow.height()) ||
                    $errorMessage.length === 0
                ) {
                    threshold = 100;
                    $scrollTarget = $firstInlineError;
                }
            }

            if (isElementInViewport($viewportTarget, $currentWindow)) {
                $viewportTarget.focus();

            } else {

                var $scrollElement = $('html, body'),
                    scrollTopValue = 0;

                if ($scrollTarget.length === 0) {
                    $scrollTarget = $inlineErrorMessages;
                    threshold = 100;
                }

                // if current view is full size modal (for mobil) always scroll to top
                // @todo - check to see how scrolling should be resolved on modal as it kills the scroll on body.
                if ($isFullModalWindow) {
                    $scrollElement = $modalWindow;
                    scrollTopValue = 0;
                } else {
                    scrollTopValue = $scrollTarget.offset().top - threshold;
                }

                if ($('.disableErrorScroll').length === 0) {
                    $scrollElement.animate(
                        {
                            scrollTop: scrollTopValue
                        },
                        1000,
                        'swing',
                        function() {
                            $scrollTarget.focus();
                        }
                    );
                }
            }
        },
        clear: function() {
            this.$container.html('');
        }
    };


    /**
     * ------------------------------
     * ErrorReporterFormSummary class
     * ------------------------------
     * A JsvfElementSet's level error reporter.
     * Displays a custom HTML content with an unsorted list of errors if there is are errors in the JsvfElementSet.
     * There is a relation one to one between JsvfElementSet and ErrorReporterFormSummary.  As the rest of error
     * reporters, once instantiated it can listen a QueueElements object like with the Observer pattern.
     * Each time the QueueElements is validated, the error reporter will update its status.  You are able to change
     * the QueueElements object in runtime when you desire.
     * Example:
     *      var myReporter = new Validation.ErrorReporterFormSummary(
     *              $('.formErrorsContainer'),
     *              '<div class="message">There is an error: <ul></ul></div>',
     *              '<div class="message">There are multiple errors: <ul></ul></div>'
     *          ),
     *          myJsvfElementSet = new Validation.JsvfElementSet($('fieldset'), false, true);
     *      myReporter.listen(myJsvfElementSet.elementQueue);
     *      myJsvfElementSet.validate();
     *  Will result in:
     *      // if there is only one error
     *      <div class="formErrorsContainer">
     *          <div class="message">There is an error: <ul><li>Some Field is required.</li></ul></div>
     *      </div>
     *      // if there are more than one error
     *      <div class="formErrorsContainer">
     *          <div class="message">There are multiple errors:
     *              <ul>
     *                  <li id="someField-validationError">Some Field is required.</li>
     *              </ul>
     *          </div>
     *      </div>
     * This error reporter will find for the UL element and will place the error items inside it.
     * In this way you can create custom error messages for one and multiple errors separately.
     * NOTE: $('.formErrorsContainer') can be a jQuery collection of containers, so the error message will be placed
     *       on each one.
     *
     * Methods:
     *  + listen(QueueElements)
     *  + render()
     *  + clear()
     */
    Validation.ErrorReporterFormSummary = function($container, singleHtml, multipleHtml)
    {
        this.queue = null;
        this.$container = $container;
        this.singleHtml = singleHtml;
        this.multipleHtml = multipleHtml;
    };

    Validation.ErrorReporterFormSummary.prototype = {
        hasError: false,
        listen: function(validationQueue) {
            var that = this;
            $(validationQueue).bind(Validation.EVENT_VALIDATED + '.ErrorReporterFormSummary',
                function(e, validationToken, queueStatus) {
                    if (this instanceof Validation.QueueElements) {
                        that.queue = this;
                        that.render();
                    }
            });
        },
        render: function() {
            var that = this,
                errorsHtml = [];
            that.queue.each(function(validatorQueue, status, errorMessage) {
                if (Validation.STATUS_INVALID === status) {
                    errorsHtml.push('<li id="' + this.jsvfElement.getErrorId().replace('[', '').replace(']', '') +
                        '">' + errorMessage + '</li>');
                    this.jsvfElement.markAsErroneous();
                } else {
                    this.jsvfElement.markAsCorrect();
                }
            });
            that.$container.html(
                0 === errorsHtml.length ? ''
                    : 1 === errorsHtml.length ?
                        $(that.singleHtml).find('ul').html(errorsHtml.join('')).end()
                        : $(that.multipleHtml).find('ul').html(errorsHtml.join('')).end()
            );

            if(errorsHtml.length > 0) {
                that.hasError = true;
            } else {
                that.hasError = false;
            }
        },
        clear: function() {
            this.queue.each(function(validatorQueue, status, errorMessage) {
                this.jsvfElement.markAsCorrect();
            });
            this.$container.html('');
            this.hasError = false;
        }
    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576944 $
 * - $DateTime: 2015/05/26 00:30:13 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #15 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.JsvfForm class
 */
(function($, Validation) {

    /**
     * --------------
     * JsvfForm class
     * --------------
     * Acts as an intermediary between the validation core logic and the DOM forms.
     * A JsvfForm is tied to a DOM form node.
     * This class extends of JsvfElementSet, and works in the same way of it but with another particular features.
     * JsvfForms initializes all its JsvfElements and ErrorReporters based in the DOM tag properties passed as
     * configuration.
     * Allows you to validate a Form just like with Zend Forms.
     */
    Validation.JsvfForm = function($jsvfForm)
    {
        // do not reinstantiate for the same DOM JsvfForm
        if ($jsvfForm.data('jsvfForm') instanceof Validation.JsvfForm) {
            return $jsvfForm.data('jsvfForm');
        }

        // Persist jsvfForm inside the DOMform
        $jsvfForm.data('jsvfForm', this);

        var instance = this,
            noAutoValidate = false,
            noDefaultErrorReporter = false;
        this.$node = $jsvfForm;

        // disable the HTML5 default validation
        this.$node.attr('novalidate', 'novalidate');

        // gets the form-level error reporter
        var getErrorReporterInstance = function() {
            var formLevelErrorReporterName = $jsvfForm.attr('data-errorReporter');
            if ('' === formLevelErrorReporterName) {
                var $alertContainer = $($jsvfForm.attr('data-pageLevelErrorSelector')),
                    errorMessage = $jsvfForm.attr('data-content-ErrorReporterAlert'),
                    forceRefresh = $jsvfForm.attr('data-forceRefresh-ErrorReporterAlert');
                return new Validation.ErrorReporterAlert($alertContainer, errorMessage, forceRefresh);
            } else if ('ErrorReporterFormSummary' === formLevelErrorReporterName) {
                var $summaryContainer = $jsvfForm
                        .find($jsvfForm.attr('data-container-selector-ErrorReporterFormSummary')),
                    singleHtml = $jsvfForm.attr('data-content-simple-ErrorReporterFormSummary'),
                    multipleHtml = $jsvfForm.attr('data-content-multiple-ErrorReporterFormSummary');
                    noAutoValidate = true;
                return new Validation.ErrorReporterFormSummary($summaryContainer, singleHtml, multipleHtml);
            } else {
                this.errorReporter = Validation.hasOwnProperty(formLevelErrorReporterName) ?
                    new Validation[formLevelErrorReporterName]($jsvfForm) : null;
            }
        };

        // create and initialize an error reporter
        this.errorReporter = getErrorReporterInstance();
        noDefaultErrorReporter = this.errorReporter instanceof Validation.ErrorReporterFormSummary;
        $.extend(this, new Validation.JsvfElementSet($jsvfForm, noAutoValidate, noDefaultErrorReporter));
        if (this.errorReporter) {
            this.errorReporter.listen(this.elementQueue);
        }

    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #52 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.JsvfElement class
 */
(function($, Validation) {

    /**
     * -----------------
     * JsvfElement class
     * -----------------
     * Allows you to manipulate a field just like with Zend Elements.
     * Acts as an intermediary between the validation core logic and the DOM form elements.  It's important to
     * highlight that a JsvfElement doesn't matches one to one with form elements.  Each JsvfElement is tied to a
     * single DOM node which is a container identified with the .jsvfElement class.  It can contains inside multiple
     * form elements, a label, and an error message container in the case of inline-errors.
     * Examples:
     *      // One JsvfElement with one field and its label
     *      <div class="jsvfElement">
     *          <label for="usernameField">Username</label>
     *          <input type="text" name="username" id="usernameField"/>
     *      </div>
     *
     *      // One JsvfElement with multiple fields and no label
     *      <div class="jsvfElement">
     *          <input type="text" name="month"/></div>
     *          <input type="text" name="day"/></div>
     *          <input type="text" name="year"/></div>
     *      </div>
     *
     * Methods:
     *  +getValue()
     *  +getErrorId()
     *  +setAriaValid()
     *  +setAriaInvalid()
     *  +markAsErroneous()
     *  +markAsCorrect()
     *  +validate()
     *  +isValid()
     */
    Validation.JsvfElement = function($jsvfElement, noAutoValidate, noDefaultErrorReporter)
    {
        // do not reinstantiate for the same DOM JsvfElement
        if ($jsvfElement.data('jsvfElement') instanceof Validation.JsvfElement) {
            return $jsvfElement.data('jsvfElement');
        }

        // Persist jsvfElement inside the DOMelement
        $jsvfElement.data('jsvfElement', this);

        this.validationEvent = $jsvfElement.find('[data-validation-events]').attr('data-validation-events') || 'blur';
        this.validators = $.parseJSON($jsvfElement.find('[data-validators]').attr('data-validators'));

        if (this.validators) {
            this.validatorsConfig = this.validators[0];
        }

        this.$elements = $jsvfElement.find('[name]').not('[type="button"]').not('[type="checkbox"]').not('button');
        this.$jsvfElement = $jsvfElement;
        this.$node = $jsvfElement;
        this.name = 1 === this.$elements.size() ?
            this.$elements.attr('name') :
            this.$jsvfElement.find('fieldset').attr('id');
        this.label = this.$jsvfElement.find('label').html() || 'NO_LABEL';
        this.validatorQueue = new Validation.QueueValidators(this);
        this.setResetNoValidate = true;

        var that = this;

        // initialize queue
        if (this.validatorsConfig) {
            $.each(this.validatorsConfig, function(i, validatorSettings) {
                var validator = new Validation.Validator(validatorSettings, that);
                that.validatorQueue.add(validator);
            });
        }

        // initialize error reporter if required
        if (!noDefaultErrorReporter) {
            this.errorReporter = new Validation.ErrorReporterInline();
            this.errorReporter.listen(this.validatorQueue);
        }

        /**
         * ---------------------------------
         * Custom Blur Event for JsvfElement
         * ---------------------------------
         * This snippet makes that JsvfElement can handle only one "blur event", even if it contains multiple
         * form fields (eg. Date).
         * When detecting a blur event over one element, checks if the focus is passed to another
         * element in the same ".jsvfElement" container.  If yes, stops the propagation and the event
         * doesn't reach the container.  If nope, the event continue its propagation to the top and then
         * reaches the container.
         * Some elements don't have to trigger propagation to the jsvfElement. To prevent this,
         * add the jsvfNoPropagate class. See PRO-211801 for more details.
         */
        this.$jsvfElement.delegate('*', this.validationEvent, function (e) {
            if (!$(this).hasClass('jsvfNoPropagate')) {
                setTimeout(function () {
                    if (that.validationEvent !== 'blur' || 0 === that.$jsvfElement.find(':focus').size()) {
                        that.$jsvfElement.trigger('validateElement.jsvf');
                    }
                }, 100);
            }
            return false;
        });

        // bind self auto-validation by default
        if (!noAutoValidate) {
            this.$jsvfElement.bind('validateElement.jsvf', function () {
                var fieldsVisited = that.$jsvfElement.find('.fieldsetValidation').data('fieldsVisited');
                if (fieldsVisited !== undefined) {
                    var performValidation = true;
                    for (var i = 0; i < fieldsVisited.length; i++) {
                        if (!fieldsVisited[i]) {
                            performValidation = false;
                        }
                    }
                    if (performValidation) {
                        that.validate();
                    }
                } else {
                    that.validate();
                }
            });
        }
    };

    Validation.JsvfElement.prototype = {
        getValue: function() {
            var that = this,
                $elements = that.$elements;
            if (1 === $elements.size()) {
                return $elements.val() || '';
            } else {
                if ($elements.is('[type="checkbox"]')) {
                    return $elements.is(':checked') ? $elements.last().val() : '';
                } else if ($elements.is('[type="radio"]')) {
                    var selectedValue = '';

                    $elements.each(function(){
                        if ($(this).prop('checked') || $(this).attr('checked')) {
                            selectedValue = $(this).val();
                        }
                    });
                    return selectedValue;
                }
                var multiValue = [];
                $elements.each(function(i, e) {
                    multiValue.push($(e).val());
                });
                return multiValue;
            }
        },
        getErrorId: function() {
            var name = typeof this.name !== 'undefined' ? this.name : '';
            if (name.indexOf('[') !== -1) {
                name = name.match(/\[(.*?)\]/)[1];
            }
            return name + '-validationError';
        },
        setAriaValid: function() {
            var that = this,
            $elements = that.$elements;
            $elements.filter('[name]').removeAttr('aria-invalid').removeAttr('aria-describedby');
            $elements.siblings('[role="button"]').removeAttr('aria-invalid').removeAttr('aria-describedby');
            $elements.closest('[role="button"]').removeAttr('aria-invalid').removeAttr('aria-describedby');
            $elements.closest('[role="checkbox"]').removeAttr('aria-invalid').removeAttr('aria-describedby');
            $elements.siblings('[role="checkbox"]').removeAttr('aria-invalid').removeAttr('aria-describedby');
        },
        setAriaInvalid: function() {
            var that = this,
            $elements = that.$elements;
            $elements.siblings('.richCheckBox').attr('aria-invalid', 'true')
                .attr('aria-describedby', this.getErrorId());
            $elements.closest('.richCheckBox').attr('aria-invalid', 'true').attr('aria-describedby', this.getErrorId());
            $elements.siblings('.rich-select-button').attr('aria-invalid', 'true')
                .attr('aria-describedby', this.getErrorId());
            $elements.closest('.rich-select-button').attr('aria-invalid', 'true')
                .attr('aria-describedby', this.getErrorId());
            $elements.closest('.ng-invalid').attr('aria-invalid', 'true')
                .attr('aria-describedby', this.getErrorId());
        },
        getErrorClassName: function() {
            // the errorIdName of error class identifier obtained through this.name
            var errorSuffix = '-validationError';
            if (typeof this.name !== 'undefined') {
                return this.name.replace(/.*\[(.*)\]/,"$1") + errorSuffix;
            } else {
                return errorSuffix;
            }
        },
        markAsErroneous: function() {
            var that = this,
                $elements = that.$elements,
                $jsvfElement = that.$jsvfElement,
                fieldMessage = ' There is an error on this field. The error is: ';
                               // ^ fallback text for forms not using JSVF

            var fieldData = $jsvfElement.parents('form').attr('data-fieldLevelA11yMessage');
            if (fieldData !== undefined) {
                fieldMessage = fieldData;
            }
            $jsvfElement.find('label, legend').andSelf().addClass('hasErrors');
            $elements.closest('.standardFormElement.comboBoxStates').addClass('hasErrors').end()
                .closest('.standardFormElement.richCheckBox').addClass('richCheckBoxError').end()
                .closest('.standardFormElement').not('.comboBoxStates, .richCheckBox').addClass('error');
            this.setAriaInvalid();
            $jsvfElement.parents('.jsvfForm').addClass('validationComplete');
        },
        markAsCorrect: function() {
            var that = this,
                $jsvfElement = that.$jsvfElement;
            $jsvfElement.find('label').find('.a11yFieldError').remove();
            $jsvfElement.find('.standardFormElement, label, legend, .formInputElement').andSelf()
                .removeClass('error hasErrors richCheckBoxError jsvfError errorLabel invalidInput');

            // if current elemet is a radio with conditioanl items inside
            // remove only the top level errors
            if ($jsvfElement.find('.radioConditional').length > 0) {
                $jsvfElement.find('.inlineErrors').each(function() {
                    var parentJsvfElement = $(this).closest('.jsvfElement');
                    if (
                        !(
                            parentJsvfElement.hasClass('childElement') &&
                            parentJsvfElement !== $jsvfElement
                        )
                    ) {
                        $(this).remove();
                    }
                });
            } else {
                $jsvfElement.find('.inlineErrors').remove();
            }
            $jsvfElement.parents('.jsvfForm').find('#' +  this.getErrorId()).remove();
            that.setAriaValid();
            return this;
        },
        validate: function(options) {
            var that = this;
            if (!that.$jsvfElement.find('input').hasClass('denyTabOut') &&
                !that.$jsvfElement.find('fieldset').hasClass('denyTabOut') &&
                !that.$jsvfElement.find('select').hasClass('denyTabOut')) {
                if (null !== options) {
                    var callbacks = {};
                    $.extend(callbacks, {onSuccess: function() {}, onFailure: function() {}}, options);
                    $(that.validatorQueue).one(Validation.EVENT_VALIDATED,
                        function(e, token, queueStatus, errorMessage) {
                        if (queueStatus === Validation.STATUS_VALID) {
                            callbacks.onSuccess(queueStatus);
                            that.$jsvfElement.find('input, select').trigger('validation-success');
                        } else {
                            callbacks.onFailure(queueStatus);
                            that.$jsvfElement.find('input, select').trigger('validation-failure');
                        }
                    });
                }
                that.validatorQueue.validate();
            }
        },
        isValid: function() {
            var that = this;
            return that.validatorQueue.isValid();
        },
        enableValidators: function(enableValidators, resetNoValidate) {
            enableValidators = !!enableValidators;
            var that = this;
            that.setResetNoValidate = !!resetNoValidate;
            if (!enableValidators) {
                that.$elements.addClass('jsvfNoValidate');
            } else {
                that.$elements.removeClass('jsvfNoValidate');
            }
            return that;
        },
        mustValidate: function() {
            var that = this;
            return !that.$elements.hasClass('jsvfNoValidate');
        },
        resetNoValidate: function() {
            var that = this;
            if (that.setResetNoValidate) {
                that.$elements.removeClass('jsvfNoValidate');
            }
            return that;
        }
    };

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * (c) Disney. All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney. All rights reserved.
 * @version $Revision: #11 $
 */

/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 *
 * Validation.JsvfElementSet class
 */
(function($, Validation) {

    /**
     * --------------------
     * JsvfElementSet class
     * --------------------
     * Acts as an intermediary between the validation core logic and the DOM fieldsets.
     * A JsvfElementSet is tied to a DOM node which is a container of other ".jsvfElement" nodes.
     * There is no tag or class defined to this node type, so you can instantiate one passing as first argument in the
     * constructor a form element, a fieldset, div or anything you want that contains ".jsvfElements".
     * Allows you to validate a set of JsvfElements.
     *
     * Methods:
     *  + validate()
     *  + isValid()
     *  + each(callback)
     */
    Validation.JsvfElementSet = function($jsvfElementSet, noAutoValidate, noDefaultErrorReporter)
    {
        var $elements = $jsvfElementSet.find(Validation.JSVF_ELEMENT_SELECTOR),
            elementAmount = $elements.length;

        // do not reinstantiate for the same DOM JsvfElementSet; unless there are new elements
        if ($jsvfElementSet.data('jsvfElementSet') instanceof Validation.JsvfElementSet &&
            $jsvfElementSet.data('jsvfElementAmount') === elementAmount) {
            return $jsvfElementSet.data('jsvfElementSet');
        }

        // persist jsvfElementSet inside the DOMform
        $jsvfElementSet.data({
            'jsvfElementSet': this,
            'jsvfElementAmount': elementAmount
        });

        this.$node = $jsvfElementSet;
        this.elementQueue = new Validation.QueueElements();

        var that = this;

        // initialize JsvfElement objects
        $elements.each(function() {
            var jsvfElement = new Validation.JsvfElement($(this), noAutoValidate, noDefaultErrorReporter);
            that.elementQueue.add(jsvfElement.validatorQueue);
        });
    };

    Validation.JsvfElementSet.prototype = {
        validate: function(options) {
            var that = this;
            if (null !== options) {
                var callbacks = {};
                $.extend(callbacks, {
                    onSuccess: function() {},
                    onFailure: function() {},
                    onStart: function() {}
                }, options);
                callbacks.onStart();
                $(that.elementQueue).one(Validation.EVENT_VALIDATED, function(e, token, queueStatus) {
                    if (queueStatus === Validation.STATUS_VALID) {
                        callbacks.onSuccess(queueStatus);
                    } else {
                        callbacks.onFailure(queueStatus);
                    }
                });
            }
            that.elementQueue.validate();
        },
        isValid: function() {
            return this.elementQueue.isValid();
        },
        each: function(callback) {
            this.$node.find(Validation.JSVF_ELEMENT_SELECTOR).each(function() {
                var jsvfElement = $(this).data('jsvfElement');
                callback.apply(jsvfElement, [jsvfElement]);
            });
        }
    };

})(jQuery, PEP.Validation);
/**
 * PEP JS Validation Framework
 * an Event Pooling based framework
 */
(function($, Validation) {

    $.pepPlugin('pepAutoValidators', {
        init: function() {
            var $jsvfForm = $(this).pepAutoValidators('getForm'),
                jsvfForm = null;
            if ($jsvfForm.size()) {
                jsvfForm = new Validation.JsvfForm($jsvfForm);
            }
        },
        removeData: function() {
            var $jsvfForm = $(this).pepAutoValidators('getForm');
            $jsvfForm.removeData();
        },
        getForm: function() {
            return $(this).find(Validation.JSVF_FORM_SELECTOR)
                          .andSelf()
                          .filter(Validation.JSVF_FORM_SELECTOR);
        },
        destroy: function() {

        }
    });

})(jQuery, PEP.Validation);
/**
 * PEP Web Application
 *
 * @copyright (c) Disney.  All rights reserved.
 */

/**
 * Description:
 * This plugin updates locale cookie when a language is selected from the language selector modal or footer
 *
 * Usage:
 *
 * $elem.pepDropCookieOnLanguageSelection();
 */
(function ($) {
    /**
     * objDefaultOptions
     * Default configuration options for the plugin
     *
     * @var object {
     * }
     */
    var defaultCookieJar = 'localeCookie';
    var defaultCookieName = 'contentLocale',
        preferredRegionCookie = 'preferredRegion',
        cartCookie = 'cartIdMapping',
        defaultCurrencyName = 'localeCurrency',
        akamaiJarSuffix = '_jar_aka'; // passed to pepCookieJar

    var translationToLocale = {};

    if (PEP.Config.SiteId === 'dlr') {
        translationToLocale = {
            'es-us': 'es_US'
        };
    } else if (PEP.Config.SiteId === 'wdw') {
        translationToLocale = {
            'es-us': 'en_US',
            'es-ar': 'es_AR',
            'es-mx': 'es_MX',
            'es-pe': 'es_PE',
            'es-co': 'es_CO',
            'es-cl': 'es_CL',
            'en-gb': 'en_GB',
            'pt-br': 'pt_BR'
        };
    } else if (PEP.Config.SiteId === 'dcl') {
        translationToLocale = {
            'en-gb': 'en_GB',
            'en-ca': 'en_CA',
            'en-eu': 'en_EU',
            'en-as': 'en_AS',
            'pt-br': 'pt_BR',
            'es-us': 'es_US',
            'es-ar': 'es_AR',
            'es-mx': 'es_MX',
            'es-pe': 'es_PE',
            'es-co': 'es_CO',
            'es-cl': 'es_CL',
            'de-de': 'de_DE'
        };
    }

    var objDefaultOptions = {
        'window': window,
        'cookieJarName': defaultCookieJar,
        'localeCookieName': defaultCookieName,
        'localeCurrencyName': defaultCurrencyName,
        'versionCookieName': 'version',
        'localeCookieVersion': '1',
        'precedenceCookieName': 'precedence',
        'cookiePrecedence': 2,
        'footerSelector' : '.wdwFooter',
        'internationalLinksSelector' : 'a.languageLink',
        'interstitialClass' : 'triggerInterstitialModal',
        'interstitialWaitClass' : 'languageLinkInterstitialWait',
        'siteLocale' : '', // Determined by Region Action Helper :: getDefaultLanguage() method
        // Determined by Region:: getSupportedLanguages() method
        // Default supportedLocales below is currently replaced (in wdw) by:
        // [en_US,es-us,en_CA,fr-ca,es-ar,es-mx,en-eu,en_GB,es-pe,es-co,es-cl,pt-br]
        // (in dlr by en_US,es-us,ca,fr,au)
        'supportedLocales' : ['en_US', 'en_CA', 'en_GB', 'pt_BR', 'es-us'],
        'supportedCurrencies' : '',
        persistenceLength : 86400, // 60*60*24 - Seconds in one day.
        persistencePath : '/',
        'siteLanguageChangedCookieName': 'siteLanguageChanged',
        dclDefaultContentLocale: 'en'
    };

    /**
     * strPluginName
     * Name of the plugin
     *
     * @var string
     */
    var strPluginName = 'pepDropCookieOnLanguageSelection';
    var finalUri = '';

    $.pepPlugin(strPluginName, {
        /**
         * init
         * Plugs event listeners
         *
         * @param object options.- Parameters to configure the plugin
         *
         * @return each of the objects so plugin can be chained
         */
        init: function (options) {
            options = $.extend(true, {}, objDefaultOptions, options);

            return this.each(function () {
                var $this = $(this);

                $this.data(strPluginName + '_options', options);

                // Check for interstitial modal information
                $this.find(options.internationalLinksSelector).each(function() {
                    var $currentElment = $(this);
                    if ($currentElment.hasClass(options.interstitialClass)) {
                        // Swap the modal trigger to modal waiting flag
                        $currentElment.removeClass(options.interstitialClass);
                        $currentElment.addClass(options.interstitialWaitClass);
                    }
                });


                $(options.footerSelector).delegate(
                    options.internationalLinksSelector,
                    'click.' + strPluginName,
                    function(event) {

                        // Check to show interstitial modal
                        if ($(this).hasClass(options.interstitialWaitClass) &&
                            !!PEP && !!PEP.interstitial
                        ) {
                            $(this).removeClass(options.interstitialWaitClass);
                            PEP.interstitial.openInterstitial(this, function(e) {
                                $this[strPluginName]('languageSelectHandler', $this, $(this), e, options);
                            });
                            event.preventDefault();
                            return false;
                        }

                        var href = $(this).attr('href'),
                            locale = '',
                            origin_locale = '',
                            matches = null,
                            linkTarget = $(this).attr('target');

                        if (typeof href === 'undefined' || href === '' || href === '/') {
                            // If the href isn't set, empty, or contains a '/' then the locale
                            // should be set to the default site locale, which is determined by the region action
                            // helper. This value should be passed into the plugin when it is initialized.
                            locale = options.siteLocale;
                        } else {
                            // Extract the locale from the URL.  Locales are specified in language/language_territory
                            // format (e.g. es, en, en_US, ja_JP, etc.)
                            if (options.siteId === 'dcl' &&
                                !options.isSyndicated &&
                                !PEP.Config.Toggles.Release.disableLocaleCookie) {
                                locale = href;
                            } else {
                                matches = href.match(/\/([a-z]{2}((_|-)[A-z]{2})?)(\/|$)/);
                                if (matches && matches[1]) {
                                    locale = matches[1];
                                }
                            }

                            if (href.match(/^http/)) {
                                var hrefParts = href.split('?'),
                                    origin = window.location.protocol +
                                            "//" + window.location.hostname +
                                            (window.location.port ? ':' + window.location.port: '') + '/';

                                finalUri = window.location.href.toString();
                                matches = finalUri.match(/\/([a-z]{2}((_|-)[A-z]{2})?)(\/|$)/);
                                if (matches && matches[1]) {
                                    origin_locale = matches[1];
                                }
                                if (origin_locale !== '' && finalUri.match(origin_locale) !== null) {
                                    finalUri = finalUri.replace('/' + origin_locale, '');
                                }
                                finalUri = finalUri.replace(origin , hrefParts[0]);
                                if ((hrefParts[1] && hrefParts[1] !== 'languageSelection=true') ||
                                    (hrefParts[0] && hrefParts[0].indexOf(origin) === -1)
                                ) {
                                    finalUri = href;
                                }

                                event.preventDefault();
                                $this[strPluginName]('setCookie', locale);

                                if (defaultCookieJar !== options.cookieJarName) {
                                    $this[strPluginName]('clearStorage');
                                    if (typeof linkTarget === 'undefined' || linkTarget === '') {
                                        if (options.siteId === 'dcl' && !PEP.Config.Toggles.Release.disableLocaleCookie) {
                                            window.location.reload();
                                        } else {
                                            window.location.href = finalUri;
                                        }
                                    } else {
                                        window.open(finalUri, linkTarget);
                                    }
                                } else {
                                    options.window.location.reload(true);
                                }
                            }
                        }

                        if ($.inArray(locale, options.supportedLocales) >= 0) {
                            // Don't actually follow the link
                            event.preventDefault();
                            $this[strPluginName]('setCookie', locale);

                            // refresh the current page.
                            if (defaultCookieJar !== options.cookieJarName) {
                                if (options.siteId &&
                                    options.siteId === 'dcl' &&
                                    !PEP.Config.Toggles.Release.disableLocaleCookie) {
                                    locale = '';
                                }

                                $this[strPluginName]('setUri', locale);
                                $this[strPluginName]('clearStorage');
                                if (typeof linkTarget === 'undefined' || linkTarget === '') {
                                    window.location.href = finalUri;
                                } else {
                                    window.open(finalUri, linkTarget);
                                }
                            } else {
                                options.window.location.reload(true);
                            }
                        }
                    }
                );
            });
        },

        /**
         * Language select handler
         *
         * @param jquery $this current object reference
         * @param object target event target
         * @param event event click event
         * @param object options
         */
        languageSelectHandler: function($this, target, event, options) {

            var href = target.attr('href'),
                locale = '',
                origin_locale = '',
                matches = null,
                linkTarget = target.attr('target');

            if (typeof href === 'undefined' || href === '' || href === '/') {
                // If the href isn't set, empty, or contains a '/' then the locale
                // should be set to the default site locale, which is determined by the region action
                // helper. This value should be passed into the plugin when it is initialized.
                locale = options.siteLocale;
            } else {
                // Extract the locale from the URL.  Locales are specified in language/language_territory
                // format (e.g. es, en, en_US, ja_JP, etc.)
                matches = href.match(/\/([a-z]{2}((_|-)[A-z]{2})?)(\/|$)/);
                if (matches && matches[1]) {
                    locale = matches[1];
                }

                if (href.match(/^http/)) {
                    href = href.split('?');
                    var origin = window.location.protocol +
                                "//" + window.location.hostname +
                                (window.location.port ? ':' + window.location.port: '') + '/';

                    finalUri = window.location.href.toString();
                    matches = finalUri.match(/\/([a-z]{2}((_|-)[A-z]{2})?)(\/|$)/);
                    if (matches && matches[1]) {
                        origin_locale = matches[1];
                    }
                    if (origin_locale !== '' && finalUri.match(origin_locale) !== null) {
                        finalUri = finalUri.replace('/' + origin_locale, '');
                    }
                    finalUri = finalUri.replace(origin , href[0]);

                    event.preventDefault();
                    $this[strPluginName]('setCookie', locale, options);
                    if (defaultCookieJar !== options.cookieJarName) {
                        $this[strPluginName]('clearStorage');
                        if (typeof linkTarget === 'undefined' || linkTarget === '') {
                            window.location.href = finalUri;
                        } else {
                            window.open(finalUri, linkTarget);
                        }
                    } else {
                        options.window.location.reload(true);
                    }
                }
            }

            if ($.inArray(locale, options.supportedLocales) >= 0) {
                // Don't actually follow the link
                event.preventDefault();
                $this[strPluginName]('setCookie', locale, options);

                // refresh the current page.
                if (defaultCookieJar !== options.cookieJarName) {
                    $this[strPluginName]('setUri', locale, options);
                    $this[strPluginName]('clearStorage');
                    if (typeof linkTarget === 'undefined' || linkTarget === '') {
                        window.location.href = finalUri;
                    } else {
                        window.open(finalUri, linkTarget);
                    }
                } else {
                    options.window.location.reload(true);
                }
            }
        },

        /**
         * Set final uri for redirection
         *
         * @param string locale.- locale value to use for the uri
         * @param config inputOptions [Optional]
         */
        setUri: function (locale, inputOptions) {
            var $this = $(this);
            var options = inputOptions || $this.data(strPluginName + '_options');
            if (!window.location.origin) {
                window.location.origin = window.location.protocol +
                    "//" + window.location.hostname +
                    (window.location.port ? ':' + window.location.port: '');
            }
            finalUri = window.location.href.toString().replace(window.location.origin, '');
            if (options.supportedLocales.length > 0) {
                for (var i = 0; i < options.supportedLocales.length; i++) {
                    var supportedLocale = '^/'+options.supportedLocales[i]+'/';
                    var regEx = new RegExp(supportedLocale);
                    if (finalUri.match(regEx) !== null) {
                        finalUri = finalUri.replace(regEx, '/');
                        break;
                    }
                }
            }

            //build the url but do not include the default siteLocale if it is the locale
            var localeInUrl = (!locale || locale === options.siteLocale) ? '' : '/' + locale;
            finalUri = window.location.origin + localeInUrl + finalUri;
        },

        /**
         * Set language and locale cookies
         *
         * @param string locale.- Value to set in the cookie
         * @param config inputOptions [Optional]
         */
        setCookie: function (locale, inputOptions) {

            return this.each(function () {
                var $this = $(this);

                // change jarSuffix for sites using akamai cookies for localeCookie_jar or languageSelection_jar
                // currently wdw only
                var localeCookieJarOptions = null;
                if (PEP.Config.Toggles.Release.disableLocaleCookie) {
                    localeCookieJarOptions = {
                        'jarSuffix' : akamaiJarSuffix
                    };
                }
                var languageSelectionCookieJarOptions = null;
                if (PEP.Config.Toggles.Release.disableLanguageSelectionCookie) {
                    languageSelectionCookieJarOptions = {
                        'jarSuffix' : akamaiJarSuffix
                    };
                }

                var options = inputOptions || $this.data(strPluginName + '_options');
                var cookieJar = $.cookiejar(options.cookieJarName, localeCookieJarOptions);
                var savedPrecedence = cookieJar.getCookie(options.precedenceCookieName);

                // Don't modify the cookie if the cookiePrecedence option is
                // lower than the current precedence
                if (options.cookiePrecedence < savedPrecedence) {
                    return;
                }

                cookieJar.addCookie(options.localeCookieName, locale);
                cookieJar.addCookie(options.versionCookieName, options.localeCookieVersion);
                cookieJar.addCookie(options.precedenceCookieName, options.cookiePrecedence);
                cookieJar.addCookie(options.siteLanguageChangedCookieName, true);

                cookieJar.save({
                    path : options.persistencePath,
                    expires : options.persistenceLength
                });

                // if locale cookie is not set, set it
                if (defaultCookieJar !== options.cookieJarName) {
                    if (translationToLocale[locale]) {
                        locale = translationToLocale[locale];
                    }
                    cookieJar = $.cookiejar(defaultCookieJar, languageSelectionCookieJarOptions);
                    savedPrecedence = cookieJar.getCookie(options.precedenceCookieName);
                    var savedCurrency = cookieJar.getCookie(options.localeCurrencyName);

                    var localeValue = locale;
                    if (options.siteId === 'dcl') {
                        if (!PEP.Config.Toggles.Release.disableLocaleCookie) {
                            // set the contentLocale=en if aka cookie is not used
                            localeValue = options.dclDefaultContentLocale;
                        }
                        cookieJar.addCookie(preferredRegionCookie, locale);
                        if (!!options.supportedCurrencies[locale] &&
                            (options.supportedCurrencies[locale] !== savedCurrency)) {
                                $.cookie(cartCookie, '', {path: '/'});
                        }
                    }

                    cookieJar.addCookie(defaultCookieName, localeValue);
                    cookieJar.addCookie(options.precedenceCookieName, options.cookiePrecedence);
                    // Optional check for Currency field
                    if (!!options.supportedCurrencies && options.supportedCurrencies.hasOwnProperty(locale)) {
                        cookieJar.addCookie(options.localeCurrencyName, options.supportedCurrencies[locale]);
                    }
                    cookieJar.save({
                        path : options.persistencePath,
                        expires : options.persistenceLength
                    });
                }

            });
        },

        /**
        * Clears the storage of translate keys and map data before reloading the page with the new language
        * so the maps cache and its translations reflect the new selected
        * language.
        */
        clearStorage: function() {
            var key = null;
            for (key in sessionStorage) {
                if (
                    sessionStorage.hasOwnProperty(key) &&
                    (key.indexOf('translate.') !== -1 || key.indexOf('finderMapFacilityService') !== -1)
                ) {
                    sessionStorage.removeItem(key);
                }
            }
        },

        /**
         * destroy
         * Unbind event listeners
         *
         * @return each of the objects so plugin can be chained
         */
        destroy: function() {
            return this.each(function() {
                var $this = $(this);
                $this.undelegate('.' + strPluginName);
                $this.removeData(strPluginName + '_options');
            });
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.

 * @copyright (c) Disney.  All rights reserved.
 */

/**
 * Description:
 * This plugin toggles a class on .targetSelector if triggerEvent occurs in triggerSelector.
 * Useful for CSS animation transitions on separate divs, controlled by a checkbox input.
 */
(function ($) {
    var pluginName = 'pepToggleClass',
        defaultOptions = {
            baseSearchSelector: 'body',
            triggerSelector: '.toggleClassTrigger',
            triggerEvent: 'change',
            targetSelector: '.toggleClassTarget',
            triggerOnInit: true,
            toggleClassName: 'toggle',
            cookieKey: null,
            cookiejarOptions: { path : '/', expires : 31536000 },
            triggerCondition: function () {
                return this.is(':checked');
            },
            targetCallback: function (toggle, className) {
                if (toggle) {
                    this.addClass(className);
                } else {
                    this.removeClass(className);
                }
            },
            focusAfterToggle: null
        };

    $.pepPlugin(pluginName, {

        init: function (options) {
            options = $.extend(true, {}, defaultOptions, options);
            var cookieJar = $.cookiejar('classToggles');

            return this.each(function () {
                var $this,
                    targetElement,
                    triggerElement,
                    toggle,
                    savedState;

                $this = $(options.baseSearchSelector);
                triggerElement = $this.find(options.triggerSelector);

                // Restore checkbox state from cookie
                if (options.cookieKey) {
                    var cookieKeys = cookieJar.getJar();
                    if (cookieKeys) {
                        savedState = cookieKeys[options.cookieKey];
                    }

                    // Set the state of the checkbox if cookie key exists
                    if (typeof savedState !== 'undefined') {
                        options.triggerOnInit = true;
                        triggerElement.prop('checked', savedState);
                    }
                }

                function toggleFn() {
                    targetElement = $this.find(options.targetSelector);
                    toggle = options.triggerCondition.call(triggerElement);
                    options.targetCallback.call(targetElement, toggle, options.toggleClassName);
                    if (options.cookieKey) {
                        cookieJar.addCookie(options.cookieKey, toggle);
                        cookieJar.save(options.cookiejarOptions);
                    }
                    // focus the cursor on the provided input, if one was passed
                    if (options.focusAfterToggle !== null) {
                        $(options.focusAfterToggle).focus();
                    }
                }

                // 1st time
                if (options.triggerOnInit) {
                    toggleFn();
                }

                $this.delegate(options.triggerSelector, options.triggerEvent + '.' + pluginName, toggleFn);
            });
        },

        destroy: function () {
            return this.each(function () {
                $(this).undelegate(pluginName);
            });
        }
    });
})(jQuery);
/*
 *  PEP.cookie
 *
 *  Cookie getter and setter library
 *  This function helps to manage cookies in an easy way, with key-values, like jQuery(..dom..).attr()
 */
(function($) {

    /**
     *  $.cookie(key, value) // sets the cookie and returns the document.cookie "command" executed
     *  $.cookie(key) // returns the value
     *  $.cookie(badarguments) // returns -1
     */
    $.cookie = function() {
        var args = Array.prototype.slice.call(arguments),
            key = args.shift(),
            value = args.shift(),
            options = args.shift(),
            commands = [];

        if ('string' === typeof key && 'string' === typeof value) {
            commands.push(key + '=' + $.trim(value));

            if ('object' === typeof options) {
                if (options.expires && 'string' === typeof options.expires) {
                    commands.push('expires=' + options.expires);
                } else if (typeof options.expires === 'number') {
                    var date = new Date();
                    // convert to milliseconds & set the time.
                    date.setTime(date.getTime() + (options.expires * 1000));
                    commands.push('expires=' + date.toUTCString());
                }
                if (options.path && 'string' === typeof options.path) {
                    commands.push('path=' + options.path);
                }
                if (options.domain && 'string' === typeof options.domain) {
                    commands.push('domain=' + options.domain);
                }
                if (options.secure) {
                    commands.push('secure');
                }
            }

            // set the cookie
            var command = commands.join('; ') + ';';
            document.cookie = command;
            return command;
        } else if ('string' === typeof key && !value) {
            var cookies = document.cookie.split(';');
            key += '=';
            for (var i = 0; i < cookies.length; i ++) {
                var cookie = cookies[i];
                while (cookie.charAt(0) === ' ') {
                    cookie = cookie.substring(1, cookie.length);
                }
                if (cookie.indexOf(key) === 0) {
                    return cookie.substring(key.length, cookie.length);
                }
            }
            return '';
        }
        return -1;
    };

    /**
     * Deletes a cookie
     *
     * @param String key
     * @return boolean
     */
    $.cookie.remove = function(key) {
        if ('string' === typeof key) {
            $.cookie(key, '', {expires: 'Thu, 01-Jan-70 00:00:01 GMT'});
            return true;
        }

        return false;
    };

})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #9 $
 */

/**
 * This plugin can be used in conjunction with the cookie jar class in PHP.
 * Uses the pepCookie to do the setting and getting of cookies.
 *
 * - Updated on 02-20-13 to allow for store specific cookie support.
 */

/*global jQuery, window, document, PEP */
(function($) {

    var defaults = {
        'jarSuffix' : '_jar',
        'namespace' : 'global',
        'removeOptions' : {
            'expire' : -1
        }
    };

    if (PEP.cookiejar === undefined) {
        PEP.cookiejar = {};
    }

    var jar = PEP.cookiejar = function(namespace, options) {
        var $this = $(this),
            settings = $.extend({}, defaults, options);

        if (namespace !== undefined && namespace !== null) {
            settings.namespace = namespace;
        }

        $this.data('settings', settings);
        $this.data('cookieData', this.getJar());
    };

    /**
     * Returns the entire cookie jar as an object
     * @return object
     */
    jar.prototype.getJar = function() {
        var $this = $(this),
            settings = $this.data('settings'),
            cookieData = $.cookie(settings.namespace + settings.jarSuffix);

        cookieData = decodeURIComponent(cookieData);
        $this.html(cookieData);
        if ('string' === typeof cookieData && cookieData !== '') {
            cookieData = $.parseJSON(cookieData);
        } else {
            cookieData = {};
        }

        if (
            settings.storeid !== undefined &&
            settings.storeid !== null &&
            cookieData !== null &&
            cookieData[settings.storeid] !== undefined
        ) {
            cookieData = cookieData[settings.storeid];
        }

        return cookieData;
    };

    /**
     * Adds a single cookie key value pair to the jar. Returns the instance of the pep.cookiejar so it's chainable.
     * To persist the cookie to storage, you must call the save method of this same class.
     * @param string key
     * @param string value
     * @return PEP.cookiejar
     */
    jar.prototype.addCookie = function(key, value) {
        var $this = $(this),
            settings = $this.data('settings'),
            cookieData = $this.data('cookieData'),
            newValue = {};

        newValue[key] = value;
        cookieData = $.extend({}, cookieData, newValue, true);
        $this.data('cookieData', cookieData);
        return this;
    };

    /**
     * Removes the cookie matching the given key.  Returns the instance of the pep.cookiejar so it's chainable.
     * To persist the cookie to storage, you must call the save method of this same class.
     * @param string key
     * @return PEP.cookiejar
     */
    jar.prototype.removeCookie = function(key) {
        var $this = $(this),
            cookieData = $this.data('cookieData');

        delete cookieData[key];
        $this.data('cookieData', cookieData);
        return this;
    };

    /**
     * Returns the single value from the jar for the cookie name given.
     * @param string key
     * @return string - value of the cookie in the cookie jar
     */
    jar.prototype.getCookie = function(key) {
        var $this = $(this),
            cookieData = $this.data('cookieData'),
            cookie = null;

        if (cookieData && cookieData[key]) {
            cookie = cookieData[key];
        }

        return cookie;
    };

    /**
     * Saves the entire cookie jar object as a json string
     * @param object options - Accepts path, domain, secure, expires
     * @return boolean
     */
    jar.prototype.save = function(options) {
        var $this = $(this),
            settings = $this.data('settings'),
            cookieData = $this.data('cookieData');

        if (settings.storeid !== undefined && settings.storeid !== null) {
            var data  = cookieData;
            cookieData = {};
            cookieData[settings.storeid] = data;
        }
        var dataStore = encodeURIComponent(JSON.stringify(cookieData));

        return $.cookie(
            settings.namespace + settings.jarSuffix,
            dataStore,
            options
        );
    };

    /**
     * Deletes the entire cookie jar object
     * @param object options - Accepts path, domain, secure, expires  Expires is set to -1 by default.
     * @return boolean
     */
    jar.prototype.remove = function(options) {
        var $this = $(this),
            settings = $this.data('settings');

        options = $.extend({}, defaults.removeOptions, options);
        return $.cookie(settings.namespace + settings.jarSuffix, '', options);
    };

    /**
     * global cookiejar method, can be used by any class.
     * @param string namespace
     * @param object options
     * @return PEP.cookiejar
     */
    $.cookiejar = function(namespace, options) {
        return new PEP.cookiejar(namespace, options);
    };
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #17 $
 */

/**
 * @author adancona <adrian.x.ancona.-nd@disney.com>
 *
 * Description:
 * This plugin brings functionality to the Disney Parks sign up modal on the global
 * footer.
 *
 * Usage:
 *
 * $elem.pepDisneyParksUpdatesSignUpModal();
 */
(function ($) {
    /**
     * objDefaultOptions
     * Default configuration options for the plugin
     *
     * @var object {
     *      'modalOpenerSelector': 'Selector for the link that will open the modal',
     *      'modalWindowSelector': 'Selector for the modal window'
     * }
     */
    var objDefaultOptions = {
        'modalOpenerSelector': '.disneyParksModalOpener',
        'modalWindowSelector': '#disneyParksUpdatesSignUpModal',
        'cancelButtonSelector': '#disneyParksSubscribeCancelButton',
        'successModalSelector': '#disneyParksUpdatesSignUpThankYouModal',
        'successModalCloseButtonSelector': '.successCloseButton',
        'emailInputSelector': '#disneyParksSubscribeEmailField',
        'signUpAnotherEmailSelector': '.signUpAnotherEmail',
        'signUpButtonSelector' : '#disneyParksSubscribeSignUpButton',
        'newsLetterUrl' : '/global-footer/index/news-letter/',
        'pepModal' : '#disneyParksUpdatesModal'
    };

    /**
     * strPluginName
     * Name of the plugin
     *
     * @var string
     */
    var strPluginName = 'pepDisneyParksUpdatesSignUpModal';

    /**
     * strPepModalPluginName
     * Name of the pep modal plugin
     *
     * @var string
     */
    var strPepModalPluginName = 'pepModalUIPlus';

    $.pepPlugin(strPluginName, {
        /**
         * init
         * Plugs event listeners
         *
         * @param object options.- Parameters to configure the plugin
         *
         * @return each of the objects so plugin can be chained
         */
        init: function (options) {
            options = $.extend(true, {}, objDefaultOptions, options);

            return this.each(function () {
                var $this = $(this);

                // save options for usage in other functions
                $this.data(strPluginName + '_options', options);

                $(options.modalOpenerSelector, $this).bind(
                    'click.' + strPluginName,
                    function(event) {
                        $(options.modalWindowSelector, $this).show();

                        // Close the modal when clicking the overlay
                        $('.overlayDialog', $this).click(function(event) {
                            // The class of the element that actually grays all the
                            // area surrounding the modal is centerVertical
                            if ($(event.target).hasClass('centerVertical')) {
                                $this[strPluginName]('restartSubscribeModal');
                                $(options.modalWindowSelector, $this).hide();
                            }
                        });

                        // Don't follow the link
                        event.preventDefault();
                    }
                );
                $(options.successModalSelector, $this).hide();
                var $pepModal = $(options.pepModal);

                // Close the modal when clicking the cancel button
                $(options.cancelButtonSelector, $this).bind(
                    'click.' + strPluginName,
                    function() {
                        $this[strPluginName]('restartSubscribeModal');
                        $(options.modalWindowSelector, $this).hide();
                        $pepModal[strPepModalPluginName]('close');
                    }
                );

                // Close the success modal window when clicking the close button
                $(options.successModalCloseButtonSelector, $this).bind(
                    'click.' + strPluginName,
                    function() {
                        $this[strPluginName]('restartSubscribeModal');
                        $(options.successModalSelector, $this).hide();
                        $pepModal[strPepModalPluginName]('close');
                    }
                );

                $(options.signUpAnotherEmailSelector, $this).bind(
                    'click.' + strPluginName,
                    function(event) {
                        $this[strPluginName]('restartSubscribeModal');

                        $(options.successModalSelector, $this).hide();
                        $(options.modalWindowSelector, $this).show();

                        event.preventDefault();
                    }
                );

                
            });
        },

        /**
         * showThankYouModal
         * Hide subscribe modal and show thank you modal after successfully
         * signing up user to newsletter
         *
         * @return each of the objects so plugin can be chained
         */
        showThankYouModal: function() {
            return this.each(function () {
                var $this = $(this),
                    options = $this.data(strPluginName + '_options'),
                    $emailInput =  $this.find('#disneyParksSubscribeEmailField'),
                    csrfToken = $("#pep_csrf").val(),
                    signUpLanguage = $("#signUpLanguage").val();

                $.ajax({
                    type: "POST",
                    url: options.newsLetterUrl,
                    headers: {"Pragma": "no-cache"},
                    dataType: 'json',
                    data: {
                        'email': $emailInput.val(),
                        'pep_csrf': csrfToken,
                        'signUpLanguage' : signUpLanguage
                    },
                    success: function(data) {
                        if (data.success) {
                            $(options.modalWindowSelector, $this).hide();
                            $(options.successModalSelector, $this).show();
                            $('.disneyParksSubscribeSuccess h1').attr('tabindex', '-1').focus();
                        } else {
                            var jsvfElement = new PEP.Validation.JsvfElement(
                                    $('#disneyParksSubscribeEmailFieldid-base')
                                ),
                                errorHtml = '<li>' + data.message + '</li>';
                            jsvfElement.markAsErroneous();
                            if ($emailInput.next('inlineErrros').length === 0) {
                                $emailInput.after('<ul class="inlineErrors">' + errorHtml + '</ul>');
                            } else {
                                $this.find('.inlineErrrors').html(errorHtml);
                            }
                        }
                    },
                    error: function(data) {

                    }
                });

            });
        },

        /**
         * restartSubscribeModal
         * Restarts subscribe modal to it's initial state
         *
         * @return each of the objects so plugin can be chained
         */
        restartSubscribeModal: function() {
            return this.each(function () {
                var $this = $(this);
                $this.pepClientSideValidationWithEvent('clearFormValidation');
                $(objDefaultOptions.emailInputSelector, $this).val('');
            });
        },

        /**
         * destroy
         * Unbind event listeners
         *
         * @return each of the objects so plugin can be chained
         */
        destroy: function() {
            return this.each(function() {
                var $this = $(this);
                $(objDefaultOptions.modalOpenerSelector, $this)
                        .unbind('.' + strPluginName);
                $(objDefaultOptions.cancelButtonSelector, $this)
                        .unbind('.' + strPluginName);
                $(objDefaultOptions.successModalCloseButtonSelector, $this)
                        .unbind('.' + strPluginName);
                $(objDefaultOptions.signUpAnotherEmailSelector, $this)
                        .unbind('.' + strPluginName);
            });
        }
    });
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #8 $
 */

/**
 * @author adancona <adrian.x.ancona.-nd@disney.com>
 *
 * Description:
 * This plugin allows a developer to esily perform client side validation.
 * Depending on the parameters passed to the plugin, the developer can specify which
 * actions should take effect if the validation passes or not.
 *
 * Usage:
 * This plugin is useful for validating a form using the PEP validation framework
 *
 * $elem.pepClientSideValidationWithEvent();
 *
 * By default the plugin looks for a submit button on the page and runs the
 * validations when the button is clicked.
 * After the validation is done the event is triggered on the form, and the form
 * is submitted
 */
(function ($) {
    /**
     * objDefaultOptions
     * Default configuration options for the plugin
     *
     * @var object Expects these parameters: {
     *     'strTriggerSelector': 'jQuery Selector for the element that will trigger
     *                           the validation'
     *     'strTriggerEvent': 'jQuery event that will start the validations when
     *                         triggerd against "strTriggerSelector"',
     *     'strFormSelector': 'jQuery selector for the form that will be validated',
     *     'onSuccess': 'Plugin that will be executed on success' {
     *          'target': 'Selector that plugin will use',
     *          'plugin': 'Plugin that will be called',
     *          'method': 'Function of the plugin that will be executed'
     *     },
     *     'onFailure': 'Plugin that will be executed on failure' {
     *          'target': 'Selector that plugin will use',
     *          'plugin': 'Plugin that will be called',
     *          'method': 'Function of the plugin that will be executed'
     *     }
     * }
     */
    var objDefaultOptions = {
        'strTriggerSelector': 'button[type=submit]',
        'strTriggerEvent': 'click',
        'strFormSelector': '.jsvfForm',
        'strPageLevelErrorSelector': '.errorSummaryBlock',
        'submitOnSuccess': true,
        'onSuccess': {
            'target': '.jsvfForm',
            'plugin': 'pepClientSideValidationWithEvent',
            'method': 'onSuccessDefaultAction'
        },
        'onFailure': {
            'target': '.jsvfForm',
            'plugin': 'pepClientSideValidationWithEvent',
            'method': 'onFailureDefaultAction'
        }
    };

    /**
     * strPluginName
     * Name of the plugin
     *
     * @var string
     */
    var strPluginName = 'pepClientSideValidationWithEvent';

    $.pepPlugin(strPluginName, {
        /**
         * init
         * initializes the validation plugin. Attach event listener that will start
         * the validation
         *
         * @param object objOptions.- See objDefaultOptions for a description of each
         *                         index
         *
         * @return each of the objects so plugin can be chained
         */
        init: function (objOptions) {
            var options = $.extend(true, {}, objDefaultOptions, objOptions);
            return this.each(function () {
                var $this = $(this);
                var bFormIsValid = false;

                $this.data(strPluginName + '-data', options);

                $(options.strTriggerSelector, $this).bind(
                    options.strTriggerEvent + '.' + strPluginName,
                    function(event) {
                        // Hide page level error message in case it was already
                        // being shown to the user
                        $(options.strPageLevelErrorSelector).hide();

                        bFormIsValid =  $this[strPluginName](
                            'validateForm',
                            options.strFormSelector
                        );
                        var successOrFailure;
                        if (bFormIsValid) {
                            successOrFailure = 'onSuccess';
                        } else {
                            successOrFailure = 'onFailure';
                        }
                        try {
                            $(options[successOrFailure].target)
                                    [options[successOrFailure].plugin]
                                    (options[successOrFailure].method, $this);
                        } catch(e) {}
                        event.preventDefault();
                    }
                );
            });
        },

        /**
         * validateForm
         * Runs the validations against the given form
         *
         * @param string strFormSelector.- jQuery selector for the form to validate
         *
         * @return boolean True if form is valid, false otherwise
         */
        validateForm: function(strFormSelector) {
            var jsvfElementSet = new PEP.Validation.JsvfElementSet(
                $(strFormSelector),
                true,
                false
            );
            jsvfElementSet.validate();
            return jsvfElementSet.isValid();
        },

        /**
         * onSuccessDefaultAction
         * Default action to execute on success
         *
         * @param object $targetElement.- jQuery object that has the plugin attached
         */
        onSuccessDefaultAction: function($targetElement) {
            var options = $targetElement.data(strPluginName + '-data');
            $(options.strFormSelector).trigger('formIsValid');
            if (options.submitOnSuccess) {
                $(options.strFormSelector).submit();
            }
        },

        /**
         * onSuccessDefaultAction
         * Default action to execute on success
         *
         * @param object $targetElement.- jQuery object that has the plugin attached
         */
         onFailureDefaultAction: function($targetElement) {
            var options = $targetElement.data(strPluginName + '-data');
            $(options.strPageLevelErrorSelector).show();
            $(options.strFormSelector).trigger('formIsNotValid');
         },

        /**
         * clearFormValidation
         * Clears form validations and error messages
         */
         clearFormValidation: function() {
            return this.each(function () {
                var $this = $(this);

                var options = $this.data(strPluginName + '-data');
                var jsvfElementSet = new PEP.Validation.JsvfElementSet(
                    $(options.strFormSelector),
                    true,
                    false
                );
                jsvfElementSet.each(function() {
                    this.markAsCorrect();
                });
            });
         },

        /**
         * destroy
         * Removes all events bound by this plugin
         */
        destroy: function() {
            return this.each(function () {
                var $this = $(this);

                var options = $this.data(strPluginName + '-data');

                $(options.strTriggerSelector).unbind(
                    options.strTriggerEvent + '.' + strPluginName
                );

                $this.removeData(strPluginName + '-data');
            });
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #21 $
 */

/**
 * This plugin handles the enabling/disabling of inputs as well as the activating/deactivating of client-side
 * validators.
 */

(function($) {

    $.pepPlugin('pepClientSideValidatorToggle', {
        init: function() {
            var $this = this;
            var inputElement = $this.find('.inputElement');

            var jsvfElement = null;
            if ($this.hasClass('jsvfElement')) {
                // for elements that are VF-enabled, save their validators for later reactivation
                jsvfElement = new PEP.Validation.JsvfElement($this);
                $($this).data('vfqueue', jsvfElement.validatorQueue);
                // deactivate validators for elements that have already been disabled server-side
                if (inputElement.attr('disabled') === 'disabled') {
                    $this.pepClientSideValidatorToggle('toggleValidation', false);
                }
            }

            // bind events to enable/disable the input via JS
            $this.bind('disable-input.pepClientSideValidatorToggle', function(event, clearValue) {
                if (clearValue) { inputElement.trigger('reset-input-to-default'); }
                if ($this.hasClass('jsvfElement')) {
                    $this.pepClientSideValidatorToggle('toggleValidation', false);
                }

                inputElement
                    .parents('.selectBox').find('.select-toggle').attr('tabindex', '')
                    .end().end()
                    .trigger('disable-element')
                    .prop('disabled', true)
                    .attr('disabled', 'disabled')
                    .attr('aria-disabled', true)
                    .end()
                    .addClass('disabled')
                    // some plugins have buttons for widgets, eg datepickers, search boxes
                    .find('button')
                    .prop('disabled', true)
                    .attr('disabled', 'disabled')
                    .end()
                    .addClass('disabled');

                $this.find('.richRadio').attr('aria-disabled', true);

                // stop propagation
                return false;
            });

            $this.bind('enable-input.pepClientSideValidatorToggle', function(event) {
                if ($this.hasClass('jsvfElement')) {
                    $this.pepClientSideValidatorToggle('toggleValidation', true);
                }

                inputElement
                    .parents('.selectBox').find('.select-toggle').attr('tabindex', '0')
                    .end().end()
                    .trigger('enable-element')
                    .prop('disabled', false)
                    .attr('disabled', false)
                    .attr('aria-disabled', false)
                    .end()
                    .removeClass('disabled')
                    // some plugins have buttons for widgets, eg datepickers, search boxes
                    .find('.inputElement + button')
                    .prop('disabled', false)
                    .attr('disabled', false)
                    .end()
                    .removeClass('disabled');

                $this.find('.formInputElement,.standardFormElement').removeClass('disabled');
                $this.find('.richRadio').attr('aria-disabled', false);
                // stop propagation
                return false;
            });

            return this;
        },
        toggleValidation: function(activateValidators) {
            var jsvfForm = new PEP.Validation.JsvfForm(this.closest('form.jsvfForm'));
            var jsvfElement = new PEP.Validation.JsvfElement(this);

            if (jsvfElement) {
                jsvfElement.validatorQueue = activateValidators ? this.data('vfqueue')
                    : new PEP.Validation.QueueValidators(jsvfElement);
                jsvfElement.errorReporter.listen(jsvfElement.validatorQueue);
                jsvfForm.elementQueue.add(jsvfElement.validatorQueue);
                if (!activateValidators) { jsvfElement.validate(); }
            }
            return this;
        },
        destroy: function() {
            return this.unbind('.pepClientSideValidatorToggle');
        }
    });

})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #4 $
 */

/*
 * This plugin adds 'active' state functionality to any element in IE by adding a manual 'active' class on mousedown.
 * Other browsers handle the active state through CSS alone (.button:active)
 *
 * USAGE:
 *
 * $pluginData = $this->view->autoPluginHelper('pepActiveStyleSupport');
 *
 * <span data-plugins="$pluginData" $attribs><etc...
 *
 */

(function($) {
    $.pepPlugin('pepActiveStyleSupport', {
        init: function() {
            if ($.browser && $.browser.msie) {
                this.bind('mousedown.pepActiveStyleSupport', function() {
                    $(this).addClass('active');
                });
                this.bind('mouseout.pepActiveStyleSupport mouseup.pepActiveStyleSupport', function() {
                    $(this).removeClass('active');
                });
            }

            return this;
        },
        destroy : function() {
            return this.unbind('.pepActiveStyleSupport');
        }
    });
})(jQuery);
/*
 * pepModularOverlay
 *
 * Open (display) or close (hide) a modal dialog.
 *
 */
(function ($) {

    var _settings = {
        dialogLauncher: null
    };

    // $.data() access keys
    var _dataKeys = {
        options: 'pepModularOverlay.options'
    };

    $.pepPlugin('pepModularOverlay', {
        init: function(options) {
            var $this = this;
            options = $.extend({}, _settings, options);
            this.data(_dataKeys.options, options);    // Saves the custom options

            $.fn.pepModularOverlay.closed = 0;

            // if launcher is set, setup the launcher
            if (options.dialogLauncher !== null) {
                // If launcher is link, only bind to anchor not parent.
                var anchorObject = $(options.dialogLauncher).closest("a");
                var triggerObject = (anchorObject.length > 0) ?
                    anchorObject : this.find(options.dialogLauncher).parent();

                // Opens the dialog when the launcher element is clicked
                triggerObject.bind('click.pepModularOverlay', function() {
                    $this.pepModularOverlay('open');
                    return false;
                });
            }

            return this.delegate('.overlayCloseButton', 'click.pepModularOverlay', function() {
                $(this).closest(':pepModularOverlay').pepModularOverlay('close');
                return false;
            });
        },
        open: function() {
            $.fn.pepModularOverlay.closed = 0;
            var $modalOverlay = this.show();
            // TODO: use styled native scrolling on modal overlays instead of JS PEP plugin.
            // Check for the existence of the custom selector, to avoid the syntax error you get otherwise.
            if ($.expr[':'].pepCustomScroll) {
                // Restart the pepCustomScroll container, so that it meassures the container size accurately.
                $modalOverlay.find(':pepCustomScroll').pepCustomScroll();
            }
            return $modalOverlay;
        },
        close: function() {
            $.fn.pepModularOverlay.closed = 1;
            return this.hide();
        },
        destroy: function() {
            var $this = this;
            var options = this.data(_dataKeys.options);

            // Removes any stored data
            $.each(_dataKeys, function(key, value) {
                $this.removeData(value);
            });

            return this.unbind('.pepModularOverlay');
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576944 $
 * - $DateTime: 2015/05/26 00:30:13 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #8 $
 */

/*
 * This plugin adds 'activated' state functionality to PEP global buttons in IE.
 * Other browsers handle the active state through CSS alone.
 *
 * USAGE:
 *
 * $pluginData = $this->view->autoPluginHelper('pepButtonIEActiveFix');
 *
 * <span data-plugins="$pluginData" $attribs><etc...
 *
 */

(function($) {
    $.pepPlugin('pepButtonIEActiveFix', {
        init: function() {
            if ($(document).find('.no-cssgradients').size() !== 0) {
                this.bind('mousedown.pepButtonIEActiveFix', function() {
                    $(this).addClass('active');
                });
                this.bind('mouseup.pepButtonIEActiveFix', function() {
                    $(this).removeClass('active');
                });
                //Begin Fix for CheckBoxButton on IE
                $(document).bind('click.pepButtonIEActiveFix', function() {
                    $(this).find('.checkbox-button span.button').addClass('iefix');
                    $(this).find('.checkbox-button span.button').removeClass('iefix');
                });
                $('.checkbox-button').bind('keydown.pepButtonIEActiveFix', function() {
                    $(this).find('span.button').addClass('iefix');
                    $(this).find('span.button').removeClass('iefix');
                });
                $('.checkbox-button.selected').ready(function() {
                    $(this).find('span.button').addClass('iefix');
                    $(this).find('span.button').removeClass('iefix');
                });
                //End Fix for CheckBoxButton on IE
            }
            return this;
        },
        destroy : function() {
            return this.unbind('.pepButtonIEActiveFix');
        }
    });
})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

(function($) {
    $.pepPlugin('pepManagePreferences', {
        init: function() {
            var $self = this;
            $('[name$="global_footer/legal/onetrust_manage_preferences"]').bind("click", function(e) {
                $self['pepManagePreferences']('showManagePreferenceModal');
            });
        },
        showManagePreferenceModal: function() {
            var $self = $(this);
            $('#onetrust-banner-sdk, #close-pc-btn-handler').css('display','none');
            //Display background filter and manage preferences
            $('.onetrust-pc-dark-filter, #onetrust-pc-sdk').css('display','block')
                .css('visibility','visible').css('opacity','1');
            $('.onetrust-pc-dark-filter, #onetrust-pc-sdk').removeClass('ot-hide');
            $('#close-pc-btn-handler').show();
        }
    });

})(jQuery);
(function($, PEP) {

    var PLUGIN_NAME = 'pepGatedLink';

    $.pepPlugin(PLUGIN_NAME, {

        init: function(config) {
            var $this = $(this),
                options = {
                    returnURL: window.location.href, 
                    successCallback: function(guestData) {
                        $this.pepGatedLink(config.successCallback, guestData, config);
                    }
                };
                
            $this.bind('click.' + PLUGIN_NAME, function(e) {
                e.preventDefault();
                //the pepLoginModal plugin takes time, let's do it as a last resort
                //check pep namespace for nge eligibility info first
                if(PEP.ngeEnabled) {
                    $this.pepGatedLink(config.successCallback, {"ngeEligible":"ACTIVE"});
                } else {
                    $(document).trigger('openModal.pepLoginModal', options);
                }
            });
            return this;
        },
        
        /*
         * based on eligibility lets either let the guest pass or show them
         * the how to become eligible 
         */
        ngeEligibilityFlow: function (guestData, config) {
            var $this = $(this);
            if(guestData.ngeEligible==="ACTIVE") {
                window.location.href = $this.attr('href');
            } else {
                $(config.modalId).pepModalUIPlus(config.modalConfig, true);
            }
        },
        
        destroy: function() {
            return this.unbind("."+PLUGIN_NAME);
        }
    });

})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * Metadata:
 * - $Author: pater062 $
 * - $DateTime: 9/21/2017 $
 *
 * @copyright (c) Walt Disney Parks and Resorts Online. All rights reserved.
 * @version $Revision: #1 $
 */
(function($, PEP) {

    var FILE = 'ProfileCsrfUtils.serviceClient.js',
        dependency = PEP.Dependency.init(FILE),
        linkGenerator = dependency.uses('PEP.link.Generator'),
        ProfileCsrfUtils = function () {},
        _getTokenUrl = linkGenerator.build('/authentication/status'),
        PLUGIN_NAME = 'PEP.ServiceClient.ProfileCsrfUtils',
        LOGGER = PEP.Log.Factory.createLogger(PLUGIN_NAME);

    ProfileCsrfUtils.prototype.getToken = function() {
        return $.ajax({
            url: _getTokenUrl,
            async: true,
            error: function(error) {
               LOGGER.error(error, 'Error fetching profile csrf token');
            }
        })
        .then(function(resp) {
            return resp.csrf.token;
        });
    };

    window.PEP = window.PEP || {};
    window.PEP.ServiceClient = window.PEP.ServiceClient || {};
    window.PEP.ServiceClient.ProfileCsrfUtils = window.PEP.ServiceClient.ProfileCsrfUtils || ProfileCsrfUtils;

})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #29 $
 */

/**
 * Login modal plugin
 *
 *    _settings:
 *        @param skipSignIn - currently not used but will be used for 'skip login' step.
 *        @param returnURL - URL to return to after 'forgotpassword' or 'createAccount' flow.
 *               *NOTE* if blank will default to successURL
 *        @param successURL - URL to route to after login success.
 *        @param dialogLauncher - element to bind to to open modal.
 *        @param loginPageSubmitButton - selector for login page submit
 *        @param loginPageCancelButton - selector for login page cancel.
 *        @param loginPageURL - URL for the login page to route to incase of error.
 *        @param loginURL - URL for the ajax request to hit to get the modal view.
 *        @param loingSubmitPage - URL for the ajax request to hit when the form is submitted.
 *               *NOTE* defaults to loginURL if not set.
 *        @param analyticsErrorCodes - *not used carried over from cart.
 *        @param showPleaseWait - *not used carred over from cart.
 */
(function($, PEP) {

    var PLUGIN_NAMESPACE = '.pepLoginModal',
        FILE = 'jquery.pepLoginModal.js',
        dependency = PEP.Dependency.init(FILE),
        linkGenerator = dependency.uses('PEP.link.Generator'),
        profileCsrfUtil = new PEP.ServiceClient.ProfileCsrfUtils(),
        _settings = {
            skipSignIn: false,
            returnURL: '',
            successURL: '',
            cancelURL: '',
            dialogLauncher: '',
            loginPageSubmitButton: '#loginPageSubmitButton',
            loginPageCancelButton: '#loginPageCancelButton',
            loginSpinner: '#signInSpinner',
            loginPageURL: linkGenerator.build('/authentication/login/'),
            loginURL: linkGenerator.build('/authentication/login-form/'),
            loginSubmitPageURL: '',
            resetRedirectURL: linkGenerator.build('/authentication/redirect-to-cancel-url/'),
            analyticsErrorCodes: '#analyticsErrorCodes',
            showPleaseWait: true,
            successCallback: '',
            errorCallback: ''
        };

    // $.data() access keys
    var _dataKeys = {
        options: 'pepLoginModal.options'
    };

    $.pepPlugin('pepLoginModal', {
        _retrievingDialogContent: false,
        init: function(options) {
            var $this = this;

            options = $.extend({}, _settings, options);
            if (!options.loginSubmitPageURL) {
                options.loginSubmitPageURL = options.loginURL;
            }

            if (!options.returnURL) {
                options.returnURL = options.successURL;
            }

            $(this).data(_dataKeys.options, options);    // Saves the custom options

            var openPepLoginModal = function(e, params) {
                e.preventDefault();
                //if params set overwrite the current options.
                if (params) {
                    $.extend($this.data(_dataKeys.options), params);
                }
                $this.pepLoginModal('openLoginDialog');
            };

            var resetRedirects = function(e) {
                $this.pepLoginModal('resetSessionRedirects');
            };

            //bind open modal events.
            $(options.dialogLauncher).bind('click' + PLUGIN_NAMESPACE, openPepLoginModal);
            $(document).bind('openModal' + PLUGIN_NAMESPACE, openPepLoginModal);

            //bind listener for resetting session redirects. This will give other plugins
            //(i.e: pepDineConflictingReservations) the ability to clear the session redirects
            //without duplicating code
            $(document).bind('resetRedirects' + PLUGIN_NAMESPACE, resetRedirects);

            return this;
        },

        /**
         * Function: openLoginDialog
         * Makes an ajax call to get the view to be placed inside the modal.
         */
        openLoginDialog : function () {
            // Prevent ajax request from being sent twice
            if (this._retrievingDialogContent === true) {
                return false;
            }

            this._retrievingDialogContent = true;
            var $this = this,
                options = this.data(_dataKeys.options),
                loginURL = options.loginURL,
                loginPageURL = options.loginPageURL,
                headers = {"DisneyPEP-ReturnTo-Uri": options.returnURL},
                isAsyncCall = (typeof options.openDialogAsync !== 'undefined') ? options.openDialogAsync : false;

            if (options.cancelURL) {
                headers['DisneyPEP-Cancel-Uri'] = options.cancelURL;
            }

            var _self = this;
            // get modal content
            $.ajax({
                url: loginURL,
                headers: headers,
                type: 'GET',
                dataType: 'html',
                async: isAsyncCall,
                success: function(data, textStatus, jqXHR) {
                    _self._retrievingDialogContent = false;
                    if (jqXHR.getResponseHeader("Forward") !== null) {
                        // already logged in go to successURL or default to Forward response.
                        if (typeof options.successCallback !== 'function') {
                            if (options.successURL !== "") {
                                window.location.href = options.successURL;
                            } else {
                                window.location.href = jqXHR.getResponseHeader("Forward");
                            }
                        } else {
                            data = $this.pepLoginModal('getValidParsedJson', data);
                            if (data.hasError) {
                                if (typeof options.errorCallback === 'function'){
                                    options.errorCallback.call(this, {});
                                }
                            } else {
                                options.successCallback.call(this, data);
                            }
                        }

                    } else {
                        $this.pepLoginModal('initLoginDialog', data, false);
                    }
                },
                error: function() {
                    _self._retrievingDialogContent = false;
                    window.location.href = loginPageURL;
                }
            });

            return this;
        },

        /**
         * Function: cancelLoginDialog
         * Close the login dialog when the user presses cancel and send an ajax request
         * to clear the redirect URL from the session. This will prevent the page from redirecting
         * to stale URL's when the user logs in from the main "/login" page
         * @param jQuery object $dialog - Login Dialog
         *
         */
        cancelLoginDialog: function($dialog) {
             // close login modal
            $dialog.find('.modalContainer.hide').pepModalUIPlus('close');

            // Clear redirect URI's from the session
            $(this).pepLoginModal('resetSessionRedirects');
        },

        /**
         * Function: resetSessionRedirects
         * Make an ajax request to unset the session redirects, so the user doesn't
         * ever receive a stale URL
         *
         */
        resetSessionRedirects: function() {
            // Get default cancel URL from cancel button element
            var options    = this.data(_dataKeys.options);
            var cancelURL  = options.resetRedirectURL;
            var headers    = {"DisneyPEP-ResetRedirect-Urls": 1};

            // Send AJAX request to clear session redirect variable
            $.ajax({
                url:      cancelURL,
                headers:  headers,
                type:     'GET',
                async:    false,
                success:  function(data, textStatus, jqXHR) {},
                error:    function() {}
            });
        },

        /**
         * Function: initLoginDialog
         * Opens the modal and populates the html inside the modal.
         *
         * @param data - Html to put inside the modal.
         * @param isError - error that may be returned.
         */
        initLoginDialog : function (data, isError) {
            var $this = this;
            var options = $this.data(_dataKeys.options);
            var $dialog = $(this).closest('.signInContainer').find('.modalContainer.hide');

            //open pepUIPlusModal
            $dialog.html(data).find("[data-plugins]");
            $dialog.trigger('loginModalOpen');
            $dialog.html('');

            //webkit bug - see https://jira.nge.wdig.com/browse/PRO-1210
            if (options.webkitRemoveNode && $.browser.webkit) {
                var node = $(options.webkitRemoveNode);
                if (node.length > 0) {
                    node = node[0];
                    options.webkitRemoved = {
                        parentNode: node.parentNode,
                        nextSibling: node.nextSibling,
                        node: node.parentNode.removeChild(node)
                    };
                }
            }

            $this.pepLoginModal('initEvents', isError);

            return this;
        },

        /**
         * Function initEvents
         * Initializes events for this element.
         *
         * @param isError - error that may be returned.
         */
        initEvents : function (isError) {
            var $this = this,
                options = this.data(_dataKeys.options),
                $dialog = $('.signInContainer'),
                $modal = $("#modalTmpContent"),
                $cancelButton = $(options.loginPageCancelButton),
                triggerEvent = isError ? 'signInError' : 'signInOnCheckOut',
                $formSubmitButtons = $modal.find("form :submit");

            // submit form event
            if ($formSubmitButtons.length > 0) {
                //Covers all buttons that submit the form
                $formSubmitButtons.bind('click' + PLUGIN_NAMESPACE, function(e) {
                    var $form  = $(this).parents('form:first');

                    if (this.name === 'forgotPassword') {
                        e.preventDefault();
                        $this.pepLoginModal('submitLogin', $form, this);
                    } else if ($form.pepClientSideDoneValidation('validateForm', $form) === true) {
                        e.preventDefault();

                        // Prevent 2x click
                        // The form is valid so we are going to hide the Done button and show the spinner
                        $(this).unbind('click'  + PLUGIN_NAMESPACE).bind('click'  + PLUGIN_NAMESPACE, function(evt){
                            evt.preventDefault();
                            return false;
                        }).hide();
                        $form.find(options.loginSpinner).show();

                        $this.pepLoginModal('submitLogin', $form, this);
                    }
                });
            }

            //webkit bug - see https://jira.nge.wdig.com/browse/PRO-1210
            $(document).bind('dialogclose', function () {
                var removed;
                if ((removed = options.webkitRemoved)) {
                    removed.parentNode.insertBefore(removed.node, removed.nextSibling);
                    options.webkitRemoved = null;
                    delete options.webkitRemoved;
                }
            });

            // cancel button event added only when no cancel url is specified
            if(options.cancelURL === ""){
                $cancelButton.bind('click' + PLUGIN_NAMESPACE, function(e) {
                    e.preventDefault();
                    $this.pepLoginModal("cancelLoginDialog", $dialog);

                    // By adding this, we eliminate the need for multiple
                    // event listeners
                    if (typeof options.cancelCallback === "function") {
                        options.cancelCallback();
                    }
                });
            }

            $(document).bind('closeModal' + PLUGIN_NAMESPACE, function(e) {
                $dialog.find('.modalContainer.hide').pepModalUIPlus('close');
            });

            // create account link and validation of email address issue
            var createAccountLink = $modal.find('.createAccount');
            if (createAccountLink.length > 0) {
                createAccountLink.bind('click' + PLUGIN_NAMESPACE, function(e){
                    var $errors = $modal.find('.jsvfElement');

                    //remove each error before continuing.
                    $errors.each(function() {
                        $(this).pepClientSideValidatorToggle('toggleValidation', false);
                    });
                });
            }

//            $this.pepCheckOutLogin('updateAnalytics', triggerEvent); @todo: Put analytics back in.

            return this;
        },

        // @todo: Not used at the moment, specifically for cart don't know if it is needed here.
        toggleForceOfCartSubmenuVisibilityOnCartBug : function(event) {
            var submenu = $(this).closest('.gnbCart .gnbSubmenu');

            // if this was not triggered but button on cart bug, return
            if (submenu.lenght <= 0) {
                return;
            }

            if (event === 'close' && submenu.hasClass('showAlways') === true) {
                submenu.removeClass('showAlways');
            } else if (event === 'open' && submenu.hasClass('showAlways') === false) {
                submenu.addClass('showAlways');
            }
            return;
        },

        /**
         * Function: submitLogin
         * Makes an ajax call to log the user in and handles continuing the process or displaying
         * errors should something go wrong in the login process.
         *
         * @param form - form data to be submitted
         * @param button - button that was clicked.
         */
        submitLogin : function(form, button) {
            var $this = this,
                options = this.data(_dataKeys.options),
                formData = form.serialize() + "&" + button.name + "=1&pep_csrf=",
                headers = {"DisneyPEP-ReturnTo-Uri": options.returnURL};

            if (options.cancelURL) {
                headers['DisneyPEP-Cancel-Uri'] = options.cancelURL;
            }

            profileCsrfUtil.getToken()
                .then(function(profileCsrfToken) {
                    formData += profileCsrfToken;
                    $.ajax({
                        type: "POST",
                        headers: headers,
                        url: options.loginSubmitPageURL,
                        data: formData,
                        dataType: 'html',
                        success: function(data, textStatus, jqXHR) {
                            if (jqXHR.getResponseHeader("Login") === "success" &&
                                typeof options.successCallback === 'function'
                            ) {
                                data = $this.pepLoginModal('getValidParsedJson', data);
                                if (data.hasError) {
                                    if (typeof options.errorCallback === 'function') {
                                        options.errorCallback.call(this, {});
                                    }
                                } else {
                                    // if we stay on the page we should update the guest greeting
                                    $(".accountContainer").first().html(data.chromeGreeting);
                                    $(document).trigger('successfulModalLogin' + PLUGIN_NAMESPACE, data);
                                    options.successCallback.call(this, data);
                                }
                            } else if (jqXHR.getResponseHeader("Login") === "success" && options.successURL !== "") {
                                // default success URL
                                window.location = options.successURL;
                            } else if (jqXHR.getResponseHeader("Forward") !== null) {
                                // login ok, use Location header to redirect
                                // note: http 302 redicts is handled by browser
                                window.location = jqXHR.getResponseHeader("Forward");
                            } else if (jqXHR.getResponseHeader("Login") === "401") {
                                // login error, render html
                                $this.pepLoginModal('initLoginDialog', data, true);
                            } else {
                                window.location.reload(true);
                            }
                        },
                        error: function(data) {
                            $this.pepLoginModal('_showSubmitLoginError', options, $this);
                        }
                    });
                })
                .fail(function() {
                    $this.pepLoginModal('_showSubmitLoginError', options, $this);
                });

            return this;
        },

        /**
         * Method that handles error event occurring during submitLogin.
         */
        _showSubmitLoginError: function(options) {
            if (typeof options.errorCallback === 'function') {
                options.errorCallback.call(this, {});
            } else {
                window.location.reload(true);
            }
        },

        /**
         * Gracefully handle a parseJSON error for login data coming back
         * @param data - raw response from AJAX call for login data
         * @return JSON Object
         */
        getValidParsedJson: function (data) {
            var jsonData = {},
                parsedData;

            try {
                parsedData = $.parseJSON(data);
                // Check that we got the correct Guest information
                if (typeof parsedData.guestFirstName === 'string' && parsedData.guestFirstName !== "") {
                    jsonData = parsedData;
                } else {
                    jsonData.hasError = true;
                }
            } catch(err) {
                jsonData.hasError = true;
            }

            return jsonData;
        },

        // @todo: move to its own file to handle just the analytics
        updateAnalytics : function (triggerEvent) {
            var $dialog = this.closest('.checkOutLoginButtonWrapper').find('.modalContainer.hide');

            var $form = $dialog.find("form"),
                WDPRO = window.WDPRO;

            if (!!WDPRO &&
                !!WDPRO.Analytics &&
                !!WDPRO.Analytics.Framework &&
                !!WDPRO.Analytics.Framework.analyticsModel
            ) {
                //make sure form loaded before setting analytics
                if ($form.length > 0) {

                    //track initializing signin page with error codes
                    var updatedModel = null;

                    if (triggerEvent === 'signInError') {
                        updatedModel = {
                            "trackingModel": {
                                "errorCodes": 'invalidLogin'
                            }
                        };
                    }

                    if (!!WDPRO &&
                        !!WDPRO.Analytics &&
                        !!WDPRO.Analytics.Framework &&
                        !!WDPRO.Analytics.Framework.analyticsModel
                    ) {
                        WDPRO.Analytics.Framework.updateElement('#checkOutLoginButton', triggerEvent, updatedModel);
                    }
                }
            }

            return this;
        },

        destroy : function() {
            return this.unbind('.pepLoginModal');
        }
    });
})(jQuery, PEP);
/**
* PEP Web Application
*
* (c) Disney.  All rights reserved.
*
* @copyright (c) Disney.  All rights reserved.
*/

/**
 * Description:
 * The purpose of the plugin is to provide keyboard accessibility for the global nav.
 */
(function($) {
    var pluginName = 'pepGlobalNavigationBar',
        selectors = {
            nav: '.globalNavigationBar',
            categories: {
                all: '.gnbCategory',
                focus: '.gnbCategory:has(a:focus)'
            } ,
            links: {
                focus: 'a:focus',
                visible: 'a:visible'
            } ,
            notifications: '.messagingNotificationOverlay'
        };

    if (typeof PEP.Config.DEVICE_PROFILE !== 'undefined' && PEP.Config.DEVICE_PROFILE.IS_IPAD) {
        var $gnbCategories = $('.gnbCategory');

        var touchMenu = function(event) {
            if (!event.currentTarget.classList.contains('touched')) {
                event.preventDefault();
                $gnbCategories.removeClass('touched');
                event.currentTarget.classList.add('touched');
            }
        };

        $gnbCategories.each(function() {
            $(this)[0].addEventListener('touchstart', touchMenu, { passive: false });
        });
    }

    // Focusing outside of the nav will cause all categories to become inactive
    $(document).on('focusin.' + pluginName, function(e) {
        if ($(e.target).closest(selectors.categories.all).length === 0) {
            // focusin did not occur within the navigation
            $(selectors.categories.all).removeClass('categoryFocus');
        }
    });

    if ($('body').find('.pepSyndicatedComponent.responsive-mode').length > 0) {
        /** Adds <meta name='viewport'> for those sites in which the tag is not present
         * ie: FastPass+ Planning
         */
        var viewport = false;
        $('head').find('meta').each(function(index, meta) {
            if ($(meta).attr('name') === 'viewport') {
                viewport = true;
            }
        });

        if (!viewport) {
            $('head').prepend('<meta name="viewport" content="width=device-width,initial-scale=1">');
        }
    }


    $('body').on('click', function(e) {
        if ($('body').hasClass('mobile-nav-open') && $(e.target).closest('.gnbLinkContainer').length === 0) {
            $('.pepSyndicatedComponent, body').removeClass('mobile-nav-open');
            e.preventDefault();
            return;
        }
        if (!$(e.target).is('.mobileNav.list, .mobileNav.list *')) {
            return;
        }
        $('.pepSyndicatedComponent, body').toggleClass('mobile-nav-open');
    });

    $('body').on('click', function(e) {
        if (!$(e.target).is('.mobileNav.search, .mobileNav.search *')) {
            return;
        }
        if (typeof ME !== 'undefined') {
            if (typeof ME.state.fullscreen !== 'undefined' && !ME.state.fullscreen) {
                $('.mobileSearch').toggleClass('mobile-search-open');
            }
            return;
        }

        //If `ME` media engine V3 is undefined then always open search box
        $('.mobileSearch').toggleClass('mobile-search-open');
    });

    $('body').on('click.submenu', '.responsive-mode .gnbCategory a.gnbCategoryTitle', function(e) {
        var $gnbCategory = $(e.target).closest('.gnbCategory');

        if (!$gnbCategory.is('.hoverable') && $('body').hasClass('mobile-nav-open')) {
            e.preventDefault();
        }

        if (!$gnbCategory.is('.open, .gnbCart')) {
            $('.responsive-mode .gnbCategory').removeClass('open');
            $gnbCategory.addClass('open');
        } else {
            $gnbCategory.removeClass('open');
        }
    });

    $('#skipNavigation').click(function() {
        $('#pageContent').attr('tabindex', -1);
    });

    $('#languageDialogResponsive').click(function() {
        $('.pepSyndicatedComponent, body').removeClass('mobile-nav-open');
    });

    //accessible nestedLink
    $('.nestedLink').keyup(function(event) {
        if (event.keyCode === 13) {
            $(event.target).click();
        }
    });

    //remove underline on parent of nestedLink when hovered
    $('.nestedLink').hover(
      function() {
        $(this).closest('.gnbParkHoursOuterWrapper').addClass('normal');
      }, function() {
        $(this).closest('.gnbParkHoursOuterWrapper').removeClass('normal');
      }
    );

    $.pepPlugin(pluginName, {
        /**
         * Init PLugin
         */
        init: function(opt) {
            return this.each(function () {
                var $this = $(this),
                    settings = {
                        'menuActive': false
                    };

                $this.data(pluginName, settings);

                // Remove GNB notification overlay if it exists somewhere else in document
                // @TODO The  UI+ element should handle the management of modal overlays
                // figure out why this was nessisary and remove it.
                if ($(selectors.notifications).length > 1) {
                    $(selectors.notifications, $this).remove();
                }
                // When a category recieves focus, remove category class name from sibling categories
                // and add it to the menu that gained focus if menu has been activated
                $this.delegate(selectors.categories.all, 'focusin.' + pluginName, function(e) {
                    var $targ = $(this);
                    $targ.siblings(selectors.categories.all).removeClass('categoryFocus');
                    if ($this.data(pluginName).menuActive) {
                        $targ.addClass('categoryFocus');
                    }
                })
                // mouseleave event handler to remove categoryFocus css class from category.
                // This solves for case where user tabs onto menu then interacts with it using the mouse
                .delegate(selectors.categories.all, 'mouseleave.' + pluginName, function(e) {
                    $(this).removeClass('categoryFocus');
                })
                // keydown event handler for arrow key navigation
                .delegate(selectors.links.visible, 'keydown.' + pluginName, function(e) {
                    // Note: $this has not been defined in this event handler. It references the
                    // global nav and not the link element that gained focus.
                    var $category,
                        preventDefault = false;

                    switch(e.which) {
                        // up arrow key
                        case 38:
                            $this.pepGlobalNavigationBar('moveLink', -1);
                            preventDefault = true;
                            break;
                        // down arrow key
                        case 40:
                            $this.pepGlobalNavigationBar('moveLink', 1);
                            preventDefault = true;
                            break;
                        // left arrow key
                        case 37:
                            $this.pepGlobalNavigationBar('moveCategory', -1);
                            preventDefault = true;
                            break;
                        // right arrow key
                        case 39:
                            $this.pepGlobalNavigationBar('moveCategory', 1);
                            preventDefault = true;
                            break;
                        // esc key
                        case 27:
                            // Remove class on focused category. Do not blur or the tab position will be lost
                            // and the next tab press will start from the top of the document
                            $('.gnbCategory.categoryFocus a.gnbCategoryTitle', $this).focus();
                            $(selectors.categories.all, $this).removeClass('categoryFocus');
                            $this.data(pluginName).menuActive = false;
                            preventDefault = true;
                            break;
                        // enter key
                        case 13:
                            // only preventDefault if this is the first keydown where we activate the menu.
                            // Susequent enter keydown events should follow the active link.
                            $category = $(selectors.categories.focus, $this);
                            if (!$category.hasClass('categoryFocus')) {
                                $category.addClass('categoryFocus');
                                $this.data(pluginName).menuActive = true;
                                preventDefault = true;
                            }
                            break;
                    }
                    if (preventDefault) {
                        // IE is too cool for event.preventDefault()
                        // when dealing with keyboard events. Check
                        // if it is available before attempting to use.
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        return false;
                    }
                });

            });
        },
        /**
         * Moves focus to previous or next visible link in navigation
         * @param int n positive or negative number indicating the direction to move focus
         */
        moveLink: function (n) {
            var $category = $(selectors.categories.focus),
                $link = $(selectors.links.focus, $category),
                $links = $(selectors.links.visible, $category),
                num = (n > -1) ? 1 : -1,
                idx = $links.index($link) + num;
            if (idx >= 0 && idx < $links.length) {
                $($links.get(idx)).focus();
                return this;
            }
            return this.pepGlobalNavigationBar('moveCategory', num);
        },
        /**
         * Moves focus to first visible link of the previous or next category in the navigation
         * @param int n positive or negative number indicating the direction to move focus
         */
        moveCategory: function (n) {
            var $category = $(selectors.categories.focus, this),
                $categories = $(selectors.categories.all, this),
                num = (n > -1) ? 1 : -1,
                idx = $categories.index($category) + num;
            if (idx >= 0 && idx < $categories.length) {
                $($categories.get(idx))
                    .find(selectors.links.visible)
                    .first()
                    .focus();
            }
            return this;
        },
        /**
         * Destroy Plugin
         */
        destroy: function() {
            return this.each(function() {
                $(this).undelegate(pluginName);
            });
        }
    });
})(jQuery);
(function ($) {
    var pluginName = "pepGlobalNavigationBarAccordion",
        defaults = {
            /* Selectors */
            "topLevelNavSelector": ".gnbCategoryTitle",
            "categorySelector": ".gnbCategory",
            "subMenuSelector": ".gnbSubmenu",
            "linkContainerSelector": ".gnbLinkContainer",
            "mobileSubmenuSelector": ".mobileOnlySubmenuTitle, [class=gnbCategoryTitle]",
            "subMenuInnerContainerSelector": ".gnbSubmenusWrapper, .submenuPlacement",
            "showMobileNavButtonSelector": ".mobileNav.list",
            "showSearchSelector": ".mobileNav.search",
            "chromeContainerSelector": ".chromeContainer",
            "profileLoggedInSelector": ".loggedIn.mobileOnly",
            "myDVSubmenuWrapperSelector": ".gnbMyDisneyVacation .gnbSubmenusWrapper",
            "searchInputSelector": ".searchBoxContainer .formInputElement .searchBox input",
            "searchFormSelector": ".chromeContainer .searchBoxContainer #globalSearchForm",

            /* Classes */
            "toggleNavClass": "gnbLinkContainerClosed",
            "arrowOpenClass": "mobileArrowOpen",
            "arrowClosedClass": "mobileArrowClosed",
            "navCartClass": "gnbCart",
            "loggedInClass": "loggedIn",
            "mobileToggledClass": "mobileToggled",
            "accordionHeadHeight": 44
        },
        // Accordion, so only one item is open at a time.
        $currentlyOpen = null,
        $currentlyOpenLink = null,
        $linkContainer = null,
        $searchBox = null,
        $linksContainerOpen = false,
        $searchContainerOpen = false,

        onClick = function (e) {
            // At the mobile breakpoint, the pretty hover menu turns into a
            // accordion, so clicks should open the accordion instead of going
            // to the link
            var $this = $(this),
                $submenu = $this.closest(defaults.categorySelector).find('.gnbSubmenu'),
                $body = $('body');
            e.preventDefault();
            e.stopImmediatePropagation();
            // only one item open at a time
            if ($currentlyOpen !== null && !$currentlyOpenLink.is($this)) {
                $currentlyOpen.slideToggle();
                $currentlyOpenLink.removeClass(defaults.arrowOpenClass);
            }
            if ($currentlyOpenLink !== null && $currentlyOpenLink.is($this)) {
                $currentlyOpen = null;
                $currentlyOpenLink = null;
            } else {
                $currentlyOpen = $submenu;
                $currentlyOpenLink = $this;
            }

            $submenu.slideToggle();
            if(!$this.hasClass(defaults.arrowOpenClass)){
               $body.animate({scrollTop: $this.data('offsetTop')},{duration: 500} );
            }

            $this.toggleClass(defaults.arrowOpenClass);

            /* If the menu has been toggled in the mobile size,
             * add a class that overwrites the display: none CSS */
            if(!$submenu.hasClass(defaults.mobileToggledClass)) {
                $submenu.addClass(defaults.mobileToggledClass);
            }
        },
        onShowNavClick = function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            var $this = $(this),
                $gnbLinksContainer = $this.parent().parent().find(defaults.linkContainerSelector);
            
            if ($searchContainerOpen) {
                $searchBox.slideUp();
                $searchContainerOpen = !$searchContainerOpen;
                $searchBox.toggleClass("searchContainerRounded");
            }
            $gnbLinksContainer.slideToggle();
            $gnbLinksContainer.toggleClass("gnbLinkContainerRounded");
            $linksContainerOpen = !$linksContainerOpen;
        },

        onSearchClick = function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            var $this = $(this),
                $gnbLinksContainer = $(defaults.linkContainerSelector);
            if ($linksContainerOpen) {
                $gnbLinksContainer.slideUp();
                $linksContainerOpen = !$linksContainerOpen;
                $gnbLinksContainer.toggleClass("gnbLinkContainerRounded");
            }
            $searchBox.slideToggle();
            $searchBox.toggleClass("searchContainerRounded");
            $searchContainerOpen = !$searchContainerOpen;
        },

        onMobileSubmenuClick = function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            var $this = $(this), 
                $body = $('body'),
                $submenu = $this.closest(".gnbSubmenu"),
            $extraListItems = $this.closest(".gnbSubmenusWrapper").find(".extraListItems");
            $extraListItems.slideToggle();
            if(!$this.hasClass(defaults.arrowOpenClass)){
                $body.animate({scrollTop: $this.offset().top},{duration: 500} );
            }
            $this.toggleClass(defaults.arrowOpenClass);
            

        },
        init = function (options) {
            defaults = $.extend(true, defaults, options);
            // Getting inited on the element with this plugin name

            var topLevelNav = this.find(defaults.topLevelNavSelector),
                $body = $("body");
            topLevelNav.each(function (i) {
                var $this = $(this);
                if (!$this.parent().hasClass(defaults.navCartClass)) {
                    $this.bind({
                        "tap": onClick,
                        "click": onClick
                    });
                }
                $this.data({"offsetTop": (i+1) * (defaults.accordionHeadHeight)});
            });
            this.find(defaults.showMobileNavButtonSelector).bind({
                "tap": onShowNavClick,
                "click": onShowNavClick
            });
            this.find(defaults.showSearchSelector).bind({
                "tap": onSearchClick,
                "click": onSearchClick
            });
            this.find(defaults.mobileSubmenuSelector).bind({
                "tap": onMobileSubmenuClick,
                "click": onMobileSubmenuClick
            });

            $searchBox = $body.find(defaults.chromeContainerSelector);
            $linkContainer = $(this).find(defaults.linkContainerSelector);

            /* Add class with different heights if signed in */ 
            if($(this).find(defaults.profileLoggedInSelector).length) {
                $searchBox.addClass(defaults.loggedInClass);
                $linkContainer.addClass(defaults.loggedInClass);
                $(this).find(defaults.myDVSubmenuWrapperSelector).addClass(defaults.loggedInClass);
            }

            //This unbinds the over effects that are attached in jquery.pepGlobalNavigationBar.js
            $(defaults.topLevelNavSelector).unbind('mouseenter.globalNavMenu').unbind('mouseleave.globalNavMenu');

        },
        destroy = function () {

        },
        methods = {
            "init": init,
            "destroy": destroy
        };
    $.pepPlugin(pluginName, methods);
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #6 $
 */

/**
 * Post pepSyndicated content processing
 * - trigger the pepPlugin processing for the .pepSyndicatedComponent(s)
 */

$(function() {
    var syndicatedAutoPluginTimer;
    function syndicatedAutoPlugin() {
        var list = jQuery('.pepSyndicatedComponent').find('[data-plugins]');
        if (list.length > 0) {
            list.pepAutoPlugin();
        } else {
             syndicatedAutoPluginTimer = setTimeout(syndicatedAutoPlugin, 500);
        }
    }
    if (typeof(syndicatedAutoPluginTimer) !== 'undefined') {
        clearTimeout(syndicatedAutoPluginTimer);
    }
    syndicatedAutoPluginTimer = setTimeout(
        syndicatedAutoPlugin,
        500
    );
});
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #48 $
 */

/**
 * The pepNotificationMessages plugin handles ajax requests for displaying notifications
 * and marking them as read.
 */
(function($) {
    /* Constants */
    var PLUGIN = 'pepNotificationMessages',
        FILE = 'jquery.' + PLUGIN + '.js',
        FADE_TIME = 400,    // In milliseconds
        AJAX_TIMEOUT = 120000,    // In milliseconds
        firstMessageRetrieval = true,

        /* Plugin Variables */
        _options = {
            dismissButton: '.messagingNotificationOverlay .dismissButton .linkButton',
            footerContainer: '#footerContainer',
            modularDialogContainerSolidBackground: '.messagingNotificationOverlay',
            dismissText: '.dismissText',
            loading: '.loading',
            mainMessagingContainer: '.mainMessagingContainer',
            messagesList: '#messagesList',
            modularContent: '#modularContent',
            modalTitle: '#ui-dialog-title-contents',
            serviceDownContainer: '#serviceDown',
            closeButton: '.overlayCloseButton.button.primary',
            dialogLauncher: '.notificationsLink',
            modalContainer: '.modalContainer',
            showHideLegal: '#showHideLegalDisclaimer',
            ajaxGetMessagesUri: '/notifications/ajax-get-messages',
            ajaxMarkMessageAsReadUri: '/notifications/ajax-mark-message-as-read',
            ajaxSaveDismissSessionUri: '/notifications/ajax-get-saved-dismiss-session',
            notificationMenuBadge: '.messageCountBadge',
            notificationsHolder: '#notificationsHolder'
        },
        _repositionTimer,

        /* Dependencies */
        LinkGenerator;

    $.pepPlugin(PLUGIN, {

        init: function(options) {

            var dependency = PEP.Dependency.init(FILE);
            LinkGenerator = dependency.uses('PEP.link.Generator');
            _options = $.extend({}, true, _options, options);

            var $this = this,
                $dismissButton = $(_options.dismissButton),
                $dismissText = $(_options.dismissText),
                $loading = $(_options.loading),
                $footerContainer = $(_options.footerContainer),
                $mainMessagingContainer = $(_options.mainMessagingContainer),
                $modularDialogContainerSolidBackground = $(_options.modularDialogContainerSolidBackground),
                $modularContent = $(_options.modularContent),
                $modalTitle = $(_options.modalTitle),
                $serviceDownContainer = $(_options.serviceDownContainer),
                $closeButton = $(_options.closeButton),
                $dialogLauncher = $(_options.dialogLauncher),
                $modalContainer = $(_options.modalContainer),
                $showHideLegal = $(_options.showHideLegal);

            $(document)
                .on('click.pepNotificationMessages keypress.pepNotificationMessages', _options.showHideLegal, 
                    function(event) {
                        event.preventDefault();
                        var $target = $('#modalTmpContent div.legalDisclaimer');
                        if (event.type === 'keypress' && event.keyCode !== $.ui.keyCode.ENTER){
                            return;
                        }
                        $target.toggleClass('hidden');
                        $this.pepNotificationMessages('setOverlayStyles');
                    }
                );

            $(document)
                .on('click.pepNotificationMessages keypress.pepNotificationMessages', _options.dismissButton, 
                    function(event) {
                        event.preventDefault();
                        if (event.type === 'keypress' && event.keyCode !== $.ui.keyCode.ENTER){
                            return;
                        }
                        // calling remove twice is a temporary fix to a larger UI+ popup issue.
                        // @todo - solve the duplicate content problem globally for the UI+ modal and remove this
                        $('.ui-dialog #footerContainer').remove();
                        $('#footerContainer').remove();
                        if ($modularDialogContainerSolidBackground.hasClass('serviceDownBackgroundContainer')) {
                            $modularDialogContainerSolidBackground
                                .removeClass('serviceDownBackgroundContainer')
                                .addClass('dismissedServiceDownBackgroundContainer');
                        } else {
                            $modularDialogContainerSolidBackground
                                .removeClass('largeBackgroundContainer')
                                .addClass('dismissedBackgroundContainer');
                        }

                        $this.pepNotificationMessages('ajaxSaveDismissSession', $footerContainer);
                    }
                );

            $this.bind('resetFirstMessageRetrieval', function() {
                firstMessageRetrieval = true;
            });

            $dialogLauncher
                .bind('click.pepNotificationMessages keypress.pepNotificationMessages', function(event){
                    event.preventDefault();
                    if(event.type === 'keypress' && event.keyCode !== $.ui.keyCode.ENTER){
                        return;
                    }
                    $modalContainer.trigger('openMessagesDialog');
                    if (firstMessageRetrieval) {
                        $(_options.mainMessagingContainer).html('');
                        $('.mainContainer .loading').show();
                        $this.pepNotificationMessages('ajaxGetMessages');
                        firstMessageRetrieval = false;
                    }

                    var $target = $('#modalTmpContent div.legalDisclaimer');
                    if (!($target.hasClass('hidden'))) {
                        $target.addClass('hidden');
                    }

                    $this.pepNotificationMessages('setOverlayStyles');
                    $(window).resize(function(){
                        clearTimeout(_repositionTimer);
                        _repositionTimer = setTimeout (function () {
                            $this.pepNotificationMessages('setOverlayStyles');
                        }, 400);
                    });
            });

            //To avoid a bigger modal when the service is loading
            if ($dismissText.length === 0) {
                $modularDialogContainerSolidBackground.addClass('modularDialogContainerSolidBackgroundDismissed');
            }

            $(document)
                .on('click.pepNotificationMessages', '.markAsRead', function() {
                    var messageId = $(this).attr('id'),
                        $background = $('#pageContainer'),
                        $individualMessageBackground = $background.find('#' + messageId),
                        $individualMessageLoadingBackground = $background.find('#loading-' + messageId),
                        $visible = $('#modalTmpContent'),
                        $individualMessageVisible = $visible.find('#' + messageId),
                        $individualMessageLoadingVisible = $visible.find('#loading-' + messageId);

                    if ($('#messagesList .markingAsRead').length === 0) {
                        $individualMessageBackground
                            .removeClass('icons icon-interactive-xs close-default markAsRead')
                            .removeAttr('href')
                            .addClass('markingAsRead');
                        $individualMessageLoadingBackground
                            .addClass('markAsReadLoading')
                            .removeClass('hide');

                        $individualMessageVisible
                            .removeClass('icons icon-interactive-xs close-default markAsRead')
                            .removeAttr('href')
                            .addClass('markingAsRead');
                        $individualMessageLoadingVisible
                            .addClass('markAsReadLoading')
                            .removeClass('hide');

                        $this.pepNotificationMessages('ajaxMarkMessageAsRead', messageId);
                    }
                });

            return $this;
        },

        setOverlayStyles: function() {
            $(this).pepModalUIPlus('repositionModal');
            if (Modernizr.touch === true) {
                $('#tmp_overlay_background').css({
                    'position': 'fixed',
                    'overflow-y': 'scroll'
                });
            }
        },

        ajaxMarkMessageAsRead: function(messageId) {
            //Background items (as rendered)
            var $background = $('#pageContainer'),
                $individualMessageContainerBackground = $background.find('#li-' + messageId),
                $individualMessageBackground = $background.find('#' + messageId),
                $individualMessageLoadingBackground = $background.find('#loading-' + messageId),

                //Visible items (in the UI+ modal)
                $visible = $('#modalTmpContent'),
                $individualMessageContainerVisible = $visible.find('#li-' + messageId),
                $individualMessageVisible = $visible.find('#' + messageId),
                $individualMessageLoadingVisible = $visible.find('#loading-' + messageId);

            $.ajax({
                timeout: AJAX_TIMEOUT,
                url: LinkGenerator.build(_options.ajaxMarkMessageAsReadUri),
                data: {msgId: messageId},
                dataType: 'html',
                success: function(data) {
                    var content = $(data);
                    $individualMessageBackground.removeClass('markingAsRead');
                    $individualMessageLoadingBackground
                        .addClass('hide')
                        .removeClass('markAsReadLoading');
                    $individualMessageContainerBackground.addClass('markedAsRead');

                    $individualMessageLoadingVisible
                        .addClass('hide')
                        .removeClass('markAsReadLoading');
                    $individualMessageVisible.removeClass();
                    $individualMessageContainerVisible.addClass('markedAsRead');
                    var badge = $(_options.notificationMenuBadge),
                        updateBadgeCount = parseInt(badge.text(), 10) - 1;
                    badge.text(updateBadgeCount);

                    if (updateBadgeCount === 0) {
                        $(_options.notificationsHolder).hide();
                    }
                },
                error: function(xhr, textStatus, error) {
                    var message = 'An Error Occurred while fetching your messages. Error: ' + textStatus;
                    $individualMessageLoadingBackground
                        .addClass('hide')
                        .removeClass('markAsReadLoading');
                    $individualMessageBackground
                        .removeClass('markingAsRead')
                        .addClass('icons icon-interactive-xs close-default markAsRead')
                        .attr('href', '#');

                    $individualMessageLoadingVisible
                        .addClass('hide')
                        .removeClass('markAsReadLoading');
                    $individualMessageVisible
                        .removeClass('markingAsRead')
                        .addClass('icons icon-interactive-xs close-default markAsRead')
                        .attr('href', '#');
                }
            });
        },

        ajaxGetMessages: function() {
            var $loading = $(_options.loading),
                $mainMessagingContainer = $(_options.mainMessagingContainer),
                $modularDialogContainerSolidBackground = $(_options.modularDialogContainerSolidBackground),
                $dismissText = $(_options.dismissText),
                $modularContent = $(_options.modularContent),
                $this = this;

            $.ajax({
                timeout: AJAX_TIMEOUT,
                url: LinkGenerator.build(_options.ajaxGetMessagesUri),
                dataType: 'html',
                success: function(data) {
                    $loading.css('display', 'none');
                    $mainMessagingContainer.html(data);
                    var divContent = $(data);

                    $modularDialogContainerSolidBackground
                        .removeClass('modularDialogContainerSolidBackgroundDismissed');

                    if (divContent.hasClass('serviceDown')) {
                        if ($dismissText.length === 0) {
                            $modularDialogContainerSolidBackground
                                .removeClass('largeBackgroundContainer')
                                .removeClass('serviceDownBackgroundContainer')
                                .addClass('dismissedServiceDownBackgroundContainer');
                        } else {
                            $modularDialogContainerSolidBackground
                                .removeClass('dismissedServiceDownBackgroundContainer')
                                .addClass('serviceDownBackgroundContainer');
                        }
                    } else {
                        if ($dismissText.length === 0) {
                            $modularDialogContainerSolidBackground
                                .removeClass('largeBackgroundContainer')
                                .addClass('dismissedBackgroundContainer');
                        } else {
                            $modularDialogContainerSolidBackground
                                .removeClass('dismissedBackgroundContainer')
                                .addClass('largeBackgroundContainer');
                        }
                    }
                },
                error: function(xhr, textStatus, error) {
                    $loading.css('display', 'none');
                    // TODO Real Guest-Centric Error Handling
                    var message = 'An Error Occurred while fetching your messages. Error: ' + textStatus;
                },
                complete: function() {
                    // repositions the modal on complete
                    $this.pepNotificationMessages('setOverlayStyles');
                }
            });
        },

        ajaxSaveDismissSession: function($footerContainer) {
            $.ajax({
                timeout: AJAX_TIMEOUT,
                url: LinkGenerator.build(_options.ajaxSaveDismissSessionUri)
            });
        },

        destroy: function() {
            $(this).unbind('.pepNotificationMessages');
            this.removeData('pepNotificationMessages-options');
            return this;
        }

    });

})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * A plugin to load the user notifications
 * asynchronously when the menu option in the Global
 * Navigation Bar is expanded.
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #25 $
 */

(function($) {
    var defaultOptions = {
        contentUrl : '/notifications/',
        notificationsSubmenuSelector : '.leftSubmenu.gnbProfileSection'
    };

    $.pepPlugin('pepNotificationAsyncLoader', {
        isLoaded: false,
        init: function(options) {
            var $this = $(this);
            options = $.extend(true, {}, defaultOptions, options);
            if (!$this.isLoaded) {
                $this.pepNotificationAsyncLoader(
                    'ajaxCallRequestNotifications',
                    options.notificationsSubmenuSelector,
                    options.contentUrl
                );
                $this.isLoaded = true;
            }
            return $(this);
        },

        ajaxCallRequestNotifications: function(submenu, notificationsLoadUrl) {
            var $this = $(this),
                $menuBadge = $('#primaryMenuItemMessageNotificationBadge');
            $.ajax({
                url: notificationsLoadUrl,
                dataType: 'json',
                type: 'GET',
                success: function(data) {
                    $(submenu + ' > .spinner, ' + submenu + ' > .spinnerSmall').remove();
                    $(submenu + ' .profileLink').removeClass('hidden');
                    $(submenu).prepend(data.avatar);
                    if (parseInt(data.totalMessageCount, 10) > 0) {
                        var notificationBadge = $this.find(".messageCountBadge");
                        if (parseInt(data.unreadMessageCount, 10) > 0) {
                            notificationBadge.text(data.unreadMessageCount);
                            $menuBadge.text(data.unreadMessageCount);
                            $menuBadge.show();
                            setTimeout(function(){
                                notificationBadge.trigger('messageCount');
                            }, 500);
                        } else {
                            notificationBadge.hide();
                            $menuBadge.hide();
                        }
                        $("#notificationsHolder, .notificationsHolder").fadeIn(500);
                    }
                },
                error: function(e) {
                    $("#notificationsHolder, .notificationsHolder").hide();
                    $menuBadge.hide();
                }
            });
        },

        destroy: function() {
            this.removeData('pepNotificationAsyncLoader-options');
            return this.unbind('.pepNotificationAsyncLoader');
        }
    });
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * Perforce Metadata:
 * - $Author: leemike $
 * - $Change: 1576920 $
 * - $DateTime: 2015/05/25 19:25:46 $
 *
 * @copyright (c) Disney.  All rights reserved.
 * @version $Revision: #37 $
 */

/**
 * @author lzappa
 *
 * A plugin to load the semi-detailed cart (cart bug)
 * asynchronously when the menu option in the Global
 * Navigation Bar is expanded.
 *
 */

(function ($) {
    var PLUGIN_EVENT_NAMESPACE = 'pepCartSemiDetailedAsyncLoader',
        CART_SEMI_DETAIL_VALIDATING_LINK = '/cart/semi-detail-validation-in-progress',
        CART_SEMI_DETAIL_VALIDATED_LINK = '/cart/semi-detail-validated',
        CART_SEMI_DETAIL_LINK = '/cart/semi-detail',
        CART_SEMI_DETAIL_CHECKOUT_LINK = 'WDW_Cart_Overlay_Checkout',
        CART_SEMI_DETAIL_VALIDATION_IN_PROGRESS_STRING = 'true',
        CART_SEMI_DETAIL_EMPTY_CART = '#semiDetailEmptyCart',
        CART_ICON_CLASS = '.gnbCart .cartIcon',
        CART_EMPTY_CLASS = 'cartEmpty-default',
        CART_FULL_CLASS = 'cartFull-default',
        theCartValidationIsInProgress = false,
        defaultOptions = {
            loadType: 'viaAjax',
            analyticsData: {},
            detailLink: CART_SEMI_DETAIL_LINK
        },
        semiDetailLoaded = false,
        isFullCart = false,
        options;

    /**
     * Decodes the embedded data received from hidden input
     *
     * @param encoded - decode encoded base64 analytics string
     */
    function _decodeData(encoded) {
        try {
            return $.parseJSON(PEP.util.base64Decode(encoded)) || {};
        } catch(e) {
            return {};
        }
    }

    $.pepPlugin('pepCartSemiDetailedAsyncLoader', {
        /**
         * Initialize plugin
         * @param JSON
         */
        init: function(pluginOptions) {
            var $this = this;

            // need to check if cart if full to update cart icon state
            $this.isFullCart = $(CART_ICON_CLASS).hasClass(CART_FULL_CLASS);

            options = $.extend(true, {}, defaultOptions, pluginOptions);
            // WDW-172491, Cart Bug: iPad - When expanded, the cart bug just shows a never-ending spinner
            // Pre-loading the semi-detail content for the iOS
            if (Modernizr.appleios || $this.isFullCart) {
                $this.pepCartSemiDetailedAsyncLoader('ajaxCallRequestCart', options.detailLink);
                if ($this.isFullCart) {
                    $this.semiDetailLoaded = true;
                }
            }


            if (options.loadType === 'viaAjax') {
                $this.pepCartSemiDetailedAsyncLoader('initViaAjax');
            }

            return $this;
        },

        // initialize cart-bug icon
        // if cart is full, css = .cartFull-default
        // if cart is empty, css = .cartEmpty-default
        // PRO-262201 - Cart Bug showing full while empty on non-cart pages
        // if you had tickets in another store & switched languages
        initCartBugIcon: function() {
            if ($(CART_SEMI_DETAIL_EMPTY_CART).length === 1) {
                $(CART_ICON_CLASS).addClass(CART_EMPTY_CLASS).removeClass(CART_FULL_CLASS);
            } else {
                $(CART_ICON_CLASS).addClass(CART_FULL_CLASS);
            }
        },

        //initialize when semi-cart is to be loaded via ajax
        initViaAjax: function() {
            var $this = this,
                // focusin used for keyboard navigation, mouseenter used for mouse interaction
                events = 'mouseenter.' + PLUGIN_EVENT_NAMESPACE + ' focusin.' + PLUGIN_EVENT_NAMESPACE;

            $this.closest('.gnbCart').one(events, function(event) {
                if (!$this.semiDetailLoaded) {
                    //send ajax request for cart data
                    $this.pepCartSemiDetailedAsyncLoader('ajaxCallRequestCart', options.detailLink);
                    // .one() doesn't seem to work correctly in Firefox, so we need a state variable
                    // to make sure we only make the ajax call once.
                    $this.semiDetailLoaded = true;
                }
            });

            // If guest clicks on cart icon, then we do not want to show submenu anymore (except for ipad)
            if (!Modernizr.appleios) {
                $('.gnbCart > a').bind('click.' + PLUGIN_EVENT_NAMESPACE, function(event) {
                    $('.gnbCart > .gnbSubmenu').remove();
                });
            }

            return $this;
        },

        ajaxCallRequestCart: function(semiDetailedLoadUrl) {
            var $this = this;

            $.ajax({
                url: semiDetailedLoadUrl,
                type: 'GET',
                success: function(data) {
                    if (this.url === options.detailLink && theCartValidationIsInProgress) {
                        // Ignore the current response since the cart validation is in progress
                        // Now, we request the validated cart blocking the request until it finishes
                        $this.pepCartSemiDetailedAsyncLoader('ajaxCallRequestCart', CART_SEMI_DETAIL_VALIDATED_LINK);
                    } else if (this.url === CART_SEMI_DETAIL_VALIDATING_LINK) {
                        if (data === CART_SEMI_DETAIL_VALIDATION_IN_PROGRESS_STRING) {
                            theCartValidationIsInProgress = true;
                            $('#pepCartSemiDetailAvailabilityText').show("slow");
                        }
                    } else {
                        $('.gnbCart .gnbSubmenusWrapper').html(data);
                        $('.gnbCart .gnbSubmenusWrapper')
                            .html(data)
                            .find('[data-plugins]')
                            .pepAutoPlugin();
                    }

                    $this.pepCartSemiDetailedAsyncLoader('convertedPriceDisclaimerToggle');

                    /**
                     * Hack for please wait on cart bug, this will be remove when we have confirmation
                     * on where to add the please wait html
                     */
                    $('#checkOutLoginButton').bind('click.' + PLUGIN_EVENT_NAMESPACE, function(event) {
                        if ($(this).attr('href').indexOf('proceed-to-checkout') !== -1) {
                            $('.gnbCart .gnbSubmenu').css('display', 'block');
                            $(this).pepPleaseWait('open');
                        }
                    });

                },
                error: function(e) {
                    $('#pepCartSemiDetail').find('#pepCartSemiDetailLoaderImage').hide();
                    $('#pepCartSemiDetail').find('#pepCartSemiDetailAvailabilityText').hide();
                    $('#pepCartSemiDetail').find('#pepCartSemiDetailLoaderErrorTitle').show();
                    $('#pepCartSemiDetail').find('#pepCartSemiDetailLoaderErrorText').show();
                }
            }).done(function () {
                $this.pepCartSemiDetailedAsyncLoader('initCartBugIcon');
            });
        },

        /**
         * Converted Price Disclaimer - Accordion Toggle
         */
        convertedPriceDisclaimerToggle: function() {
            var wrapper = $('#cartSemiDetailConvertedDetails');
            $(wrapper).find('.disclaimerToggle').bind('click.' + PLUGIN_EVENT_NAMESPACE, function(event) {
                $(wrapper).find('.disclaimer').toggleClass('open');
                var toggle = $(wrapper).find('.disclaimerToggle'),
                    ariaExpanded = toggle.attr('aria-expanded') === 'true' ? 'false' : 'true';

                toggle.attr('aria-expanded', ariaExpanded);
            });
        },

        destroy: function() {
            return this.unbind('.pepCartSemiDetailedAsyncLoader');
        }
    });
})(jQuery);
/**
 * pepValidateResidency
 *
 * DESCRIPTION:
 *   Displays the modal for profile residency verification.
 *
 * DEPENDENCIES :
 *   pepModalUIPlus
 *
 * IMPLEMENTATION:
 *   $pluginData = $this->autoPluginHelper(
 *       array('pepValidateResidency')
 *   );
 */

/**
 * SKELETON FOR FLORIDA RESIDENT VALIDATION. WILL UPDATE ONCE PROFILE HANDOFF HAS BEEN FINALIZED.
 * ALL THE MODAL CONTENTS IS JUST FOR DEMO. ACTUAL CONTENTS WILL BE COMING FROM EXTERNAL URL AND
 * LOADED THROUGH IFRAME.
 */

(function ($) {
    var PLUGIN_NAME = 'pepValidateResidency',
        _siteId = window.globalSiteId || PEP.Config.SiteId || 'WDW',
        _options = {
            launcher: null,
            showOnLoad: false,
            continueUrl: '',
            iframeSrc: '',
            iframeInitHeight: 150,
            pleaseWaitTemplate: '',
            loadingTitle: '',
            modalWidth: '465px',
            modalHeight: '650px',
            maxLoadTime: 10000,
            allowedOrigins: [
                'disney.idmelabs.com',
                'disney.id.me',
                'disney.go.com'
            ],
            analytics: {
                initiated: {
                    trackingElement: 'startFLResVerification',
                    trackingModel: {
                        trackingType: 'customLink',
                        linkId: _siteId.toUpperCase() + '_Cart_Checkout_Button_Link',
                        events: ['selfServiceInitiated'],
                        selfServiceType: ['FLResVerification']
                    }
                },
                completed: {
                    trackingElement: 'endFLResVerification',
                    trackingModel: {
                        trackingType: 'customLink',
                        linkId: _siteId.toUpperCase() + '_Cart_Checkout_Button_Link',
                        events: ['selfServiceCompleted'],
                        selfServiceType: ['FLResVerification']
                    }
                },
                statusMap: {
                    success: 'FLResVerifySuccess',
                    error: 'FLResVerifyNotSuccess',
                    cancel: 'FLResVerifyOptedOut'
                }
            }
        },
        _deferred = {},
        _titleTemplate = '<div id="pepValidateResidencyModalTitle"><div class="img"></div></div>',
        _iframeId = 'pepValidateResidencyIframeContainer',
        _iframeContainer = $('<iframe scrolling="no"></iframe>'),
        _modalId = 'pepValidateResidencyModalContainer',
        _modalContainer = $('<div id="' + _modalId + '"></div>'),
        _opener = $('<div>'),
        _loadingContainer = $('<div id="pepValidateResidencyLoadingContainer">' +
            '<div id="pepValidateResidencyLoadingTitle"></div><div id="loadingOverlayContainer">' +
            '<div class="loadingSpinnerContainer" style="-ms-transform:scale(0.7);"></div></div></div>'),
        _pleaseWaitContainer = $('<div style="position:relative;"></div>');

    $.pepPlugin(PLUGIN_NAME, {
        init: function(options) {
            var self = this;

            _options = $.extend({}, _options, options);
            self.data('options', _options);

            if (_options.showOnLoad) {
                self[PLUGIN_NAME]('openModal');
            }

            if (_options.launcher) {
                $(_options.launcher).on('click', function() {
                    self[PLUGIN_NAME]('openModal');
                    return false;
                });
            }

            return this;
        },

        openModal: function() {
            var self = this;

            _loadingContainer.find('#pepValidateResidencyLoadingTitle').html(_options.loadingTitle);
            _iframeContainer.attr('id', _iframeId)
                .attr('src', _options.iframeSrc)
                .attr('onload', '$(this).' + PLUGIN_NAME + '("frameOnLoad")');
            _modalContainer.append(_iframeContainer);
            _opener.append(_modalContainer);
            _opener.pepModalUIPlus({width: _options.modalWidth}, true);
            _opener.one('modal-closing', function() {
                self[PLUGIN_NAME]('closeModal', 'cancel');
            });

            self[PLUGIN_NAME]('transitionFrame');
            self[PLUGIN_NAME]('addHandleMessage');
            self[PLUGIN_NAME]('sendAnalytics', 'initiated');
        },

        frameOnLoad: function() {
            this[PLUGIN_NAME]('frameResize');
        },

        frameResize: function(height) {
            var $iframe = $('#' + _iframeId);
            if (height && !isNaN(parseInt(height, 10))) {
                $('#pepValidateResidencyLoadingContainer, #pepValidateResidencyModalTitle').remove();
                $iframe.css('visibility', 'visible');
                $iframe.height(height);
                _opener.pepModalUIPlus('callRepositionModal');
                if (_deferred.frameLoad && _deferred.frameLoad.state() !== 'resolved') {
                    _deferred.frameLoad.resolve();
                }
            }
        },

        transitionFrame: function() {
            var self = this,
                $iframe = $('#' + _iframeId),
                $modal = $('#' + _modalId);

            $iframe.css('visibility', 'hidden');
            $iframe.height(_options.iframeInitHeight);
            $modal.prepend(_titleTemplate, _loadingContainer);
            _opener.pepModalUIPlus('callRepositionModal');

            _deferred.frameLoad = $.Deferred();
            setTimeout(function() {
                if (_deferred.frameLoad.state() !== 'resolved') {
                    self[PLUGIN_NAME]('closeModal', '');
                }
            }, _options.maxLoadTime);
        },

        closeModal: function(status) {
            var self = this;

            _opener.pepModalUIPlus('close');
            if (_options.launcher) {
                $(_options.launcher).off('click').attr('href', _options.continueUrl);
            }
            if ($.fn.pepPleaseWait && $('.pleaseWaitContainer .modularDialogContainer').width() > 0) {
                $(_options.pleaseWaitTemplate).appendTo(_pleaseWaitContainer.appendTo('body')).removeClass('hidden');
            }

            if (status) {
                _deferred.analytics = $.Deferred();
                self[PLUGIN_NAME]('sendAnalytics', 'completed', status);
                $.when(_deferred.analytics).done(function() {
                    window.location = _options.continueUrl;
                });
            } else {
                window.location = _options.continueUrl;
            }
        },

        sendAnalytics: function(eventType, status) {
            if (WDPRO && WDPRO.Analytics && WDPRO.Analytics.Framework) {
                var framework = WDPRO.Analytics.Framework,
                    trackingModel = _options.analytics[eventType].trackingModel;

                if (status) {
                    trackingModel.contentType = _options.analytics.statusMap[status];
                }

                framework.trackElement(_options.analytics[eventType].trackingElement, trackingModel);

                if (_deferred.analytics && _deferred.analytics.state() !== 'resolved') {
                    setTimeout(function() {
                        _deferred.analytics.resolve();
                    }, 300);
                }
            }
        },

        addHandleMessage: function() {
            var self = this;

            function handleMessage(e) {
                var allowOrigin = false,
                    originLocation = typeof e.origin === 'string' ? e.origin.toLowerCase() : '';

                if (originLocation.indexOf(location.hostname.toLowerCase()) >= 0) {
                    allowOrigin = true;
                } else {
                    $.each(_options.allowedOrigins, function(index, value) {
                        if (originLocation.indexOf(value.toLowerCase()) >= 0) {
                            allowOrigin = true;
                        }
                    });
                }
                if (!allowOrigin) {
                    return;
                }

                if (e.data.unload) {
                    self[PLUGIN_NAME]('transitionFrame');
                }
                if (e.data.height) {
                    setTimeout(function() {
                        self[PLUGIN_NAME]('frameResize', e.data.height);
                    }, 0);
                }
                if (e.data.verification && e.data.verification.status) {
                    self[PLUGIN_NAME]('closeModal', e.data.verification.status.toLowerCase());
                }
            }

            if (window.attachEvent) {
                window.attachEvent('message', handleMessage);
            } else {
                window.addEventListener('message', handleMessage);
            }
        }
    });
})(jQuery);
/**
* PEP Web Application
*
* (c) Disney.  All rights reserved.
*
* Perforce Metadata:
* - $Author: leemike $
* - $Change: 1576944 $
* - $DateTime: 2015/05/26 00:30:13 $
*
* @copyright (c) Disney.  All rights reserved.
* @version $Revision: #7 $
*/

/**
 * Description:
 * The purpose of the plugin is to handle the global footer events and interaction
 * - Load the global footer asynchronously
 */
(function($) {
    var defaultOptions = {
            event: 'click',
            openClass: 'open',
            selectors: {
                head: '#accordionHead',
                content: '#accordionContent',
                internalTag: '',
                closeContent: ''
            },
            touchStart: 'touchstart',
            touchEnd: 'touchend',
            touchMove: 'touchmove',
            keypress: 'keypress',
            sensitive: '5',
            closeContent: false
    };
    $.pepPlugin('pepAccordion', {
        init: function(options) {
            options = $.extend({}, defaultOptions, options);

            return this.each(function () {
                var $this = $(this),
                    $accordionHead = $(options.selectors.head),
                    $content = $(options.selectors.content),
                    $startCoords = {},
                    $endCoords = {},
                    $target = $accordionHead.find(options.selectors.internalTag);

                /**
                 * Prevent re-assigning listeners if plugin is loaded twice
                 */
                if($target.data('accordionInit')) {
                    return;
                }
                $target.data('accordionInit', true);

                function doSlide(e) {
                    var $currentTarget = $(e.currentTarget).find('a');

                    if (options.closeOpenContent) {
                        $accordionHead.find('.openItem').each(function() {
                            if ($(this).get(0) !== $content.get(0)) {
                                $(this)
                                    .removeClass('openItem')
                                    .attr('aria-expanded', false)
                                    .slideUp();
                            }
                        });
                    }

                    $accordionHead.addClass('open');
                    $this.find('li > a').attr('aria-expanded', false);

                    if ($accordionHead.is('#mobileMoreLinks')) {
                        $accordionHead.find('img.svgIcon').toggleClass('activeDarkBlue actionBrightBlue');
                    }

                    if (options.closeOpenContent) {
                        $content.addClass('openItem');
                    }

                    $content.slideToggle({
                        complete: function() {
                            if ($content.is(':visible') === false) {
                                $accordionHead.removeClass('open');
                                $content.attr('aria-expanded', false);
                                $currentTarget.attr('aria-expanded', false);
                            } else {
                                $content.attr('aria-expanded', true);
                                $currentTarget.attr('aria-expanded', true);
                            }
                        }
                    });
                }

                /**
                 * If a selector for closeContent is set then bind a close event to it
                 */
                if (!!options.selectors.closeContent) {
                    $content
                        .find(options.selectors.closeContent)
                        .on(options.event + ' ' + options.keypress, function(event) {
                            if (event.type === options.keypress && event.keyCode !== $.ui.keyCode.ENTER) {
                                return false;
                            }

                            $content
                                .removeClass('openItem')
                                .attr('aria-expanded', false)
                                .slideUp();

                            $this.find('li > a').attr('aria-expanded', false);
                        });
                }

                /**
                 * Prevent swipe to open accordion with touchend event
                 */
                if (options.event === options.touchEnd) {
                    $target.on(options.touchStart, function(e) {
                        $endCoords = e.originalEvent.targetTouches[0];
                        $startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
                        $startCoords.pageY = e.originalEvent.targetTouches[0].pageY;
                    });
                    $target.on(options.touchMove, function(e) {
                        $endCoords = e.originalEvent.targetTouches[0];
                    });
                }

                $target.on(options.event, function(e) {
                    e.preventDefault();
                    // Only touch within the sensitive threshold can open the menu
                    if (options.event === options.touchEnd) {
                       if ( Math.abs($endCoords.pageX - $startCoords.pageX) < options.sensitive &&
                            Math.abs($endCoords.pageY - $startCoords.pageY) < options.sensitive) {
                           doSlide(e);
                       }
                    } else {
                       // Handle the legacy click event
                       doSlide(e);
                    }
                });
            });
        }
    });
})(jQuery);
/**
* PEP Web Application
*
* (c) Disney.  All rights reserved.
*
* Perforce Metadata:
* - $Author: leemike $
* - $Change: 1576944 $
* - $DateTime: 2015/05/26 00:30:13 $
*
* @copyright (c) Disney.  All rights reserved.
* @version $Revision: #10 $
*/

/**
 * Description:
 * The purpose of the plugin is to dynamically load and display the Disney.com header chrome on guest interaction
 */
(function ($) {
    var pluginName = 'pepChromeHeader',
        defaults = {
            'globalHeaderSelector' : '.pepGlobalHeader',
            'toggleLinkSelector'      : '.visitLink',
            'activeChromeId'          : '#goc-bar',
            'menuChromeId'            : '#goc-menu',
            'slideDuration'           : 500,
            'fadeDuration'            : 500,
            'directLink'              : false,
            'region'                  : 'us' // options: us, latino, pt, uk
        },

        $menuChrome = false,
        bChromeScriptLoaded = false,
        bChromeToggleOpen = false,
        focusChrome = function() {
            $("#goc-desktop-global").find("a:first").focus();
        }, 
        unfocusChrome = function() {
            $(defaults.toggleLinkSelector).focus();
        },
        mutationHandler = function(mutationRecords) {
            focusChrome();
        },
        attachScriptTag = function () {
            bChromeScriptLoaded = true;

            var gocScript = document.createElement('script'),
                ukRegions = ['uk', 'eu'];;
            window.GOC = {
                opts: {
                    bg: 'dark'
                }
            };
            
            gocScript.async = true;

            if (ukRegions.indexOf(defaults.region) !== -1) {
                gocScript.src = '//snavbar.disneyinternational.com/uk/03/navbar.js';
            } else {
                gocScript.src = '//a.dilcdn.com/g/' + defaults.region + '/parks/basic.js';
            }

            $(defaults.globalHeaderSelector).prepend('<div id="goc"></div><div id="goc-cover"><div>');

            $('#goc').animate({'height': '38px'}, defaults.slideDuration, function () {
                document.getElementById('goc-cover').style.display = 'block';
                document.getElementsByTagName("head")[0].appendChild(gocScript); 
                setTimeout( function () {
                    $('#goc-cover').fadeOut();
                }, defaults.fadeDuration);
                
            });
        }, 
        displayChrome = function () {
            if (!bChromeScriptLoaded) {
                attachScriptTag();
                var targetNode = $("#goc-cover")[0],
                    MutationObserver = window.MutationObserver || window.WebKitMutationObserver,
                    observer = new MutationObserver(mutationHandler),
                    obsConfig = { childList: true, characterData: true, attributes: true, subtree: true };
                observer.observe(targetNode, obsConfig);
            } else {              
                $(defaults.activeChromeId).animate({'height': '38px'}, defaults.slideDuration, function () {
                    $(this).css({'overflow': 'visible'});
                });

                if ($menuChrome.length) {
                    $menuChrome.animate({'top': '0'}, defaults.slideDuration);
                }

                focusChrome();
            }
        },

        hideChrome = function () {
            $(defaults.activeChromeId).css({'overflow': 'hidden'}).animate({'height': '0'}, defaults.slideDuration);

            $menuChrome = $(defaults.menuChromeId);
            var btnHeight = $menuChrome.find('#goc-button').outerHeight();

            if ($menuChrome.length) {
                $menuChrome.animate({'top': '-' + btnHeight + 'px'}, defaults.slideDuration);
            }
        },

        onToggleChromeClick = function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            $(defaults.globalHeaderSelector).toggleClass('open');

            if (!bChromeToggleOpen) {
                displayChrome();
                bChromeToggleOpen = true;
            } else {
                hideChrome();
                unfocusChrome();
                bChromeToggleOpen = false;
            }
            /*global WDPRO */
            // PRO-31847 Add analytics tracking to the toggle
            if(!!WDPRO && !!WDPRO.Analytics && !!WDPRO.Analytics.Framework) {
                var updatedModel = {
                    "trackingModel": {
                        "events": bChromeToggleOpen ? "Show_Disney_Chrome" : "Hide_Disney_Chrome"
                    }
                };
                WDPRO.Analytics.Framework.updateElement(
                    '.visitLink', 'clickVisitLinkAnalytic', updatedModel
                );
            }
        },

        init = function (options) {
            defaults = $.extend(true, defaults, options);

            if(defaults.directLink === false) {
                this.find(defaults.toggleLinkSelector).bind({
                    'click': onToggleChromeClick
                });
            }

        },

        methods = {
            'init': init
        };
    $.pepPlugin(pluginName, methods);
})(jQuery);/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

(function($) {
    var pluginName = 'pepAsyncGlobalMessaging',
        cookieName = 'async-global-message-',
        localeDetectionRegExp = /^\/[\w]{2}(-|_)[\w]{2}\/|^\/(\w{2})\//,
        disneySiteRegExp = /(disney)\w+|(disney)\W+/,
        defaultOptions = {
            after: '.pepGlobalHeader',
            genericMessage: {
                cookieExpirationDays: 365
            },
            configurations: {
                useMessageCenter: 'false',
                title: 'Important Information <a class="message-center__header__more" href="#"' +
                    'aria-label="View Now Important Information">View Now</a>' +
                    '<a class="message-center__header__less" href="#"' +
                    'aria-label="Hide Important Information">Hide</a>',
                closeText: 'Close Message',
                viewedMessagesPlural: "Show %s viewed messages",
                viewedMessagesSingular: "Show %s viewed message"
            }
        },

        TEMPLATE =
            '{{#configurations}}' +
                '<div class="message-center{{#isCollapsed}} message-center--collapsed{{/isCollapsed}}" data-nosnippet>' +
                    '<div class="message-center__header">' +
                        '<div class="message-center__header__wrapper">' +
                            '<div class="message-center__header__icon" aria-hidden="true">i</div>' +
                            '<div class="message-center__header__title">{{{title}}}' +
                                '{{#readMoreText}}' +
                                    '<a class="message-center__header__more" href="#">{{{readMoreText}}}</a>' +
                                '{{/readMoreText}}' +
                                '{{#viewLessText}}' +
                                    '<a class="message-center__header__less" href="#">{{{viewLessText}}}</a>' +
                                '{{/viewLessText}}' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="message-center__container">' +
                        '<div class="message-center__container__wrapper">' +
                            '{{#viewedMessages}}' +
                                '{{#isViewedCollapsed}}' +
                                    '<div class="message-center__message message-center__message--viewed">' +
                                        '<div class="message-center__message__data__title' +
                                            ' message-center__message__data__title--viewed">' +
                                            '<a class="message-center__viewed__more" href="#">' +
                                                '{{{viewedMessagesText}}}' +
                                            '</a>' +
                                        '</div>' +
                                    '</div>' +
                                '{{/isViewedCollapsed}}' +
                                '<div class="message-center__viewed-wrapper' +
                                    '{{#isViewedCollapsed}} ' +
                                        'message-center__viewed-wrapper--collapsed' +
                                    '{{/isViewedCollapsed}}">' +
                                    '{{#messagesViewedArray}}' +
                                        '<div class="message-center__message message-center__message--{{{type}}}"' +
                                            'id={{{id}}}>' +
                                            '<div class="message-center__message__icon" aria-hidden="true">i</div>' +
                                            '<div class="message-center__message__data">' +
                                                '<div class="message-center__message__data__title">{{{title}}}</div>' +
                                                '<div class="message-center__message__data__content">' +
                                                    '{{#content}}' +
                                                        '{{{content}}}' +
                                                    '{{/content}}' +
                                                '</div>' +
                                            '</div>' +
                                            '{{#dismissible}}' +
                                                '<div class="message-center__message__close" role="button"' +
                                                    'tabindex="0" aria-label="{{{closeText}}}">{{{closeText}}}</div>' +
                                            '{{/dismissible}}' +
                                        '</div>' +
                                    '{{/messagesViewedArray}}' +
                                '</div>' +
                            '{{/viewedMessages}}' +
                            '{{#messagesArray}}' +
                                '<div class="message-center__message message-center__message--{{{type}}}"' +
                                    'id={{{id}}}>' +
                                    '<div class="message-center__message__icon" aria-hidden="true">i</div>' +
                                    '<div class="message-center__message__data">' +
                                        '<div class="message-center__message__data__title">{{{title}}}</div>' +
                                        '<div class="message-center__message__data__content">' +
                                            '{{#content}}' +
                                                '{{{content}}}' +
                                            '{{/content}}' +
                                        '</div>' +
                                    '</div>' +
                                    '{{#dismissible}}' +
                                        '<div class="message-center__message__close" role="button"' +
                                            'tabindex="0" aria-label="{{{closeText}}}">{{{closeText}}}</div>' +
                                    '{{/dismissible}}' +
                                '</div>' +
                            '{{/messagesArray}}' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '{{/configurations}}',

        OLD_TEMPLATE =
            '{{#messagesArray}}' +
                '<div class="global-messaging-old" id={{{id}}}>' +
                    '<div class="global-messaging-old__wrapper">' +
                        '<div class="global-messaging-old__icon" aria-hidden="true">i</div>' +
                        '<div class="global-messaging-old__data">' +
                            '<div class="global-messaging-old__data__title">{{{title}}}</div>' +
                            '<div class="global-messaging-old__data__content">{{{content}}}</div>' +
                        '</div>' +
                        '{{#dismissible}}' +
                            '<div class="global-messaging-old__close" role="button" tabindex="0"' +
                                'aria-label="{{{closeText}}}">{{{closeText}}}</div>' +
                        '{{/dismissible}}' +
                    '</div>' +
                '</div>' +
            '{{/messagesArray}}',

        closeMessageHandler = function(event) {
            var id = $(this).closest('.message-center__message, .global-messaging-old').attr('id'),
                expiration = '',
                expirationDays = '',
                expires = new Date(),
                messages = event.data.messages;
            document.getElementById(id).remove();
            if (document.getElementsByClassName('message-center__message').length === 0 &&
                document.getElementsByClassName('message-center').length > 0) {
                    document.getElementsByClassName('message-center')[0].remove();
            }
            // Cookie expiration value
            $.each(messages, function(index, message) {
                if (id === message.id) {
                    expiration = message.expiration;
                    return false;
                }
            });
            expirationDays = expiration ? expiration : defaultOptions.genericMessage.cookieExpirationDays;
            expires.setDate(expires.getDate() + expirationDays);
            $.cookie(id, 'true', {path: '/', expires: expires.toString()});
            // To track the close button in the analytics call
            if (window.WDPRO && WDPRO.Analytics && WDPRO.Analytics.Framework) {
                var siteId = PEP.Config.SiteId.toUpperCase();
                var updatedModel = {
                    trackingType: 'customLink',
                    linkId: siteId + '_' + id + '_Close'
                };
                WDPRO.Analytics.Framework.trackElement('ViewModal', updatedModel);
            }
        },

        removeDuplicates = function(messageIds) {
            return messageIds.filter(function(id, index, result) {
                return result.indexOf(id) === index;
            });
        },

        removeIdsFromViewed = function(messageIds, messageCenterViewed) {
            return messageCenterViewed.filter(function(viewed) {
                return messageIds.indexOf(viewed) === -1;
            });
        },

        toggleMessageCenterHandler = function(event) {
            event.preventDefault();
            var messageIds = event.data.messageIds,
                messageCenterViewed = JSON.parse(sessionStorage.getItem('messageCenterViewed')) || [],
                messageCenterIsCollapsed = document.getElementsByClassName('message-center')[0]
                    .classList.contains('message-center--collapsed');
            if (messageCenterIsCollapsed) {
                messageCenterViewed = removeIdsFromViewed(messageIds, messageCenterViewed);
            } else {
                messageCenterViewed = removeDuplicates(messageCenterViewed.concat(messageIds));
            }
            sessionStorage.setItem('messageCenterViewed', JSON.stringify(messageCenterViewed));
            $('.message-center').toggleClass('message-center--collapsed', 500);
        },

        toggleViewedMessageHandler = function(event) {
            event.preventDefault();
            var messageIds = event.data.messageIds,
                messageCenterViewed = JSON.parse(sessionStorage.getItem('messageCenterViewed')) || [];
            messageCenterViewed = removeIdsFromViewed(messageIds, messageCenterViewed);
            sessionStorage.setItem('messageCenterViewed', JSON.stringify(messageCenterViewed));
            $('.message-center__message.message-center__message--viewed').toggle(500);
            $('.message-center__viewed-wrapper').toggleClass('message-center__viewed-wrapper--collapsed');
        };

    $.pepPlugin(pluginName, {
        init: function(options) {
            var isMatch = document.referrer.match(disneySiteRegExp);
            if (!isMatch) {
                sessionStorage.removeItem('messageCenterViewed');
            }
            window.PEP = window.PEP || {};
            // to validate pepPlugins that should run once despite of being called in multiple scripts
            window.PEP.executedPlugins = window.PEP.executedPlugins || [];
            if (window.PEP.executedPlugins.indexOf(pluginName) !== -1) {
                return;
            }
            window.PEP.executedPlugins.push(pluginName);

            options = $.extend(true, {}, defaultOptions, options);
            $.ajax({
                method: 'GET',
                url: options.url + '/',
                success: function(data, status, xhr) {
                    // We check if there are messages to avoid doing unnecessary processing.
                    if (!data.alerts || !Array.isArray(data.alerts)) {
                        return;
                    }

                    var $this = $(this);
                    $this.pepAsyncGlobalMessaging('processData', options, data);
                    document.dispatchEvent(new CustomEvent('GLOBAL_MESSAGES_READY'));
                },
                error: function(error) {
                    console.log(error);
                }
            });
        },

        /*
         * Returns the HTML for the messages using a Mustache Template.
         *
         * @param messages Object
         *
         * @return String
         */
        processData: function(options, data) {
            var messagesArray = [],
                messagesViewedArray = [],
                oldMessagesArray = [],
                messageIdsArray = [],
                html = '',
                useMessageCenter = '',
                storageViewedMessages = JSON.parse(sessionStorage.getItem('messageCenterViewed')) || [],
                path = window.location.pathname.match(localeDetectionRegExp) ?
                    '/' + window.location.pathname.replace(localeDetectionRegExp, '') :
                    window.location.pathname,
                messages = data.alerts,
                configurations = (data.descriptions && data.descriptions.length && data.descriptions[0].sections) ? 
                    data.descriptions[0].sections : {};

            // Configs
            configurations = $.extend(true, {}, defaultOptions.configurations, configurations);
            useMessageCenter = configurations.useMessageCenter === 'true' ||
                sessionStorage.getItem('useMessageCenter') === "true";

            $.each(messages, function(index, message) {
                var messageId =
                    (cookieName + message.type + '-' + message.content.length).replace(/[^A-Za-z0-9\-]/g, ''),
                    hasToDisplay = $(this).pepAsyncGlobalMessaging('hasToDisplay', message, messageId, path),
                    isTerms = message.type === 'terms';
                    message.type = message.type.toLowerCase().replace(' ', '_');
                if (hasToDisplay) {
                    message.id = messageId;
                    message.closeText = configurations.closeText;
                    message.content = (message.content !== '&nbsp;' && message.content.trim() !== '') ?
                        message.content : false;
                    messageIdsArray.push(message.id);
                    message.viewed = storageViewedMessages.indexOf(message.id) !== -1;
                    if (isTerms) {
                        message.expiration = 30;
                    }
                    if (useMessageCenter) {
                        message.viewed ? messagesViewedArray.push(message) : messagesArray.push(message);
                    } else {
                        oldMessagesArray.push(message);
                    }
                }
            });
            //Viewed Configs
            configurations.viewedMessages = messagesViewedArray.length > 0;
            configurations.isViewedCollapsed = !(messagesArray.length === 0 && messagesViewedArray.length > 0);
            configurations.isCollapsed = messagesArray.length === 0;
            configurations.viewedMessagesText = messagesViewedArray.length > 1 ?
                configurations.viewedMessagesPlural : configurations.viewedMessagesSingular;
            configurations.viewedMessagesText =
                configurations.viewedMessagesText.replace('%s', messagesViewedArray.length);

            $(this).pepAsyncGlobalMessaging('closeMessage', messagesArray.concat(messagesViewedArray)
                .concat(oldMessagesArray));
            $(this).pepAsyncGlobalMessaging('toggle', messageIdsArray);
            $(this).pepAsyncGlobalMessaging('toggleViewedLink', messageIdsArray);
            if (messagesArray.length > 0 || messagesViewedArray.length > 0) {
                html +=
                    Mustache.to_html(TEMPLATE, {
                        messagesArray: messagesArray,
                        messagesViewedArray: messagesViewedArray,
                        configurations: configurations
                    });
            }
            if (oldMessagesArray.length > 0) {
                html +=
                    Mustache.to_html(OLD_TEMPLATE, {messagesArray: oldMessagesArray, configurations: configurations});
            }
            if (useMessageCenter) {
                $(options.after).before(html);
            } else {
                $(options.after).after(html);
            }
            return html;
        },

        /*
         * Determines if the message has to be displayed based on the page urls
         * that the producer set for the message to be shown and to be excluded.
         * We also check if the user already dismissed the message so we don't show it again.
         *
         * @param message Object
         * @param messageId String
         * @param path String
         *
         * @return boolean
         */
        hasToDisplay: function(message, messageId, path) {
            var mustDisplayMessage = false,
                excluded = false,
                exclude = message.exclude || [],
                cookieValue = $.cookie(messageId);

            if (exclude.length > 0) {
                $.each(exclude, function(index, rule) {
                    var regExp = '^' + rule.replace('*', '.*') + '$';
                    if (path.match(regExp)) {
                        excluded = true;
                        return false;
                    }
                });
            }
            if (!excluded) {
                $.each(message.pages, function(index, page) {
                    var regExp = '^' + page.replace('*', '.*') + '$';
                    if (!cookieValue && path.match(regExp)) {
                        mustDisplayMessage = true;
                        return false;
                    }
                });
            }
            return mustDisplayMessage;
        },

        closeMessage: function(messages) {
            var closeMessageSelectors = '.message-center__message__close, .global-messaging-old__close';
            $('body').on('click',
                closeMessageSelectors,
                {messages: messages},
                closeMessageHandler
            );
        },

        toggle: function(messageIdsArray) {
            var toggleSelector = '.message-center__header__less, .message-center__header__more';
            $('body').on('click',
                toggleSelector,
                {messageIds: messageIdsArray},
                toggleMessageCenterHandler
            );
        },

        toggleViewedLink: function(messageIdsArray) {
            var toggleSelector = '.message-center__viewed__more';
            $('body').on('click',
                toggleSelector,
                {messageIds: messageIdsArray},
                toggleViewedMessageHandler
            );
        }
    });
})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

(function($) {
    var pluginName = 'pepCookiesPolicyMessage',
        closeMessageHandler = function(event) {
            if (!event.target.matches('.cookiesPolicyMessageButton')) {
                return;
            }
            event.preventDefault();
            $('#cookiesPolicyMessageLayout').remove();
            var expiration = new Date();
            var oneYear = new Date(expiration.getTime() + 31536000000);
            expiration = oneYear.toGMTString();
            $.cookie('COOKIE_POLICY', 'true', {path: '/', expires: expiration});
        };

        if (!$.cookie('COOKIE_POLICY')) {
            document.addEventListener('click', closeMessageHandler, false);
        }

    $.pepPlugin(pluginName, {
        init: function() {
            $('.cookiesPolicyMessageButton').on('click', closeMessageHandler);
        }
    });

})(jQuery);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

/**
 * jquery.pepBrowserUpgradeMessage.js
 *
 * This plugin contains the functionality for closing the Browser Upgrade Message 
 * in case is displayed when an unsupported is been used
 */

(function($) {
    var pluginName = 'pepBrowserUpgradeMessage';
    
    closeMessageHandler = function() {
        event.preventDefault();
        $('.browserUpgradeMessageContainer').hide();
        $.cookie('BROWSER_UPGRADE_MESSAGE_DISPLAY', 'HIDE', {path: '/'});
    };

    $.pepPlugin(pluginName, {
        init: function() {
             $('#closeUpgradeMessage').on('click', closeMessageHandler);
        }
    });
})(jQuery);


try {
    var urlHostName = window.location.hostname;
    var geoLocationEuDomain = 'www.disneyworld.eu';
    var geoLocationUkDomain = 'www.disneyworld.co.uk';

    if (!(urlHostName.includes(geoLocationEuDomain) ||
        urlHostName.includes(geoLocationUkDomain))) {
            setTimeout(function () {
                window.lpTag=window.lpTag||{};if(typeof window.lpTag._tagCount==='undefined'){window.lpTag={site:'65526753',section:lpTag.section||'',autoStart:lpTag.autoStart===false?false:true,ovr:lpTag.ovr||{},_v:'1.5.1',_tagCount:1,protocol:location.protocol,events:{bind:function(app,ev,fn){lpTag.defer(function(){lpTag.events.bind(app,ev,fn)},0)},trigger:function(app,ev,json){lpTag.defer(function(){lpTag.events.trigger(app,ev,json)},1)}},defer:function(fn,fnType){if(fnType==0){this._defB=this._defB||[];this._defB.push(fn)}else if(fnType==1){this._defT=this._defT||[];this._defT.push(fn)}else{this._defL=this._defL||[];this._defL.push(fn)}},load:function(src,chr,id){var t=this;setTimeout(function(){t._load(src,chr,id)},0)},_load:function(src,chr,id){var url=src;if(!src){url=this.protocol+'//'+((this.ovr&&this.ovr.domain)?this.ovr.domain:'lptag.liveperson.net')+'/tag/tag.js?site='+this.site}var s=document.createElement('script');s.setAttribute('charset',chr?chr:'UTF-8');if(id){s.setAttribute('id',id)}s.setAttribute('src',url);document.getElementsByTagName('head').item(0).appendChild(s)},init:function(){this._timing=this._timing||{};this._timing.start=(new Date()).getTime();var that=this;if(window.attachEvent){window.attachEvent('onload',function(){that._domReady('domReady')})}else{window.addEventListener('DOMContentLoaded',function(){that._domReady('contReady')},false);window.addEventListener('load',function(){that._domReady('domReady')},false)}if(typeof(window._lptStop)=='undefined'){this.load()}},start:function(){this.autoStart=true},_domReady:function(n){if(!this.isDom){this.isDom=true;this.events.trigger('LPT','DOM_READY',{t:n})}this._timing[n]=(new Date()).getTime()},vars:lpTag.vars||[],dbs:lpTag.dbs||[],ctn:lpTag.ctn||[],sdes:lpTag.sdes||[],ev:lpTag.ev||[]};lpTag.init()}else{window.lpTag._tagCount+=1}
            }, 2000);
    }
} catch (error) {
    logError('JSON PARSE ERROR!', error);
}/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

(function($) {
    var PLUGIN_NAME = 'pepCobrowse';

    $.pepPlugin(PLUGIN_NAME, {
        init: function(options) {
            var $self = $(this);
            $(options.wrapperClass + ' ' + options.connectButton.id).bind('click', function(e) {
                $self[PLUGIN_NAME]('requestCobrowse', $(this), options.connectButton);
            });
            $(options.wrapperClass + ' ' + options.closeButton.id).on('click', function(e) {
                $self[PLUGIN_NAME]('closeCobrowseModal', $(this), options.closeButton);
            });
        },
        requestCobrowse: function(button, options) {
            var $self = $(this),
                serviceId = document.querySelector('#modalTmpContent #txtCoBrowseCode').value;

            if (!serviceId) {
                $self[PLUGIN_NAME]('showErrorMessage');
                return;
            }

            window.lpTag.taglets.cobrowse.loadApi(function (visitorApi) {
                window.console.log('CoBrowse visitor API loaded');
                visitorApi.once('sessionRejected', function () {
                    $self[PLUGIN_NAME]('showErrorMessage');
                });

                visitorApi.once('sessionOffered', function (event) {
                    window.console.log('Agent answered the request and offers a CoBrowse session');
                    // Set to false if you would like to ask the visitor to confirm the session start.
                    var automaticallyAcceptOffer = true;

                    if (automaticallyAcceptOffer || window.confirm(
                        "Would you like to start a CoBrowse session with '" + event.agentAlias + "'?")) {
                        visitorApi.acceptSupportOffer(event);
                    } else {
                        visitorApi.cancelSupportOffer(event);
                    }
                    button.pepModalUIPlus('close');
                });

                function sessionReadyCallback(startEvent) {
                    if (startEvent) {
                        window.console.log('Session is ready and will be started shortly.');
                    }
                    button.pepModalUIPlus('close');
                }

                visitorApi.requestSupport({serviceId: serviceId}, sessionReadyCallback);
            });
        },
        closeCobrowseModal: function(button, options) {
            var $self = $(this);
            button.pepModalUIPlus('close');
        },
        showErrorMessage: function() {
            // Show the error message with some generics css styles
            document.querySelector('#modalTmpContent #invalidCobrowseId').classList.remove('hide');
            document.querySelector('#modalTmpContent #errorMessageWrapper').classList.add(
                'errorSummaryBlock',
                'hasErrors'
            );
            document.querySelector('#modalTmpContent #errorMessageWrapper label').classList.add('hasErrors');
        }
    });
})(jQuery, PEP);
/**
 * PEP Web Application
 *
 * (c) Disney.  All rights reserved.
 *
 * @copyright (c) Disney.  All rights reserved.
 */

(function ($) {

    var PLUGIN_NAME = 'pepLightBoxSyndicated',
        defaults = {
            'disneyIdAppId': 'TPR-AULANIIBC.WEB-PROD',
            'disneyIdDomain': '//www.disneyaulani.com',
            'disneyIdModalOpen': false
        };

    $.pepPlugin(PLUGIN_NAME, {
        init: function (options) {
            var $self = $(this);
            $self[PLUGIN_NAME]('addScripts', options);

            var countAttempts = 0;
            var disneyIdLoadedInterval = setInterval(function () {
                if (typeof window.DisneyID !== 'undefined' && typeof window.didobject !== 'undefined') {
                    $self[PLUGIN_NAME]('initDisneyId', options);
                    clearInterval(disneyIdLoadedInterval);
                }
                if (countAttempts++ === 10) {
                    clearInterval(disneyIdLoadedInterval);
                }
            }, 300);
        },

        addScripts: function (options) {
            // didstep is a global variable used by disneyIdLibrary and it should be previously declared
            window.didstep = '';

            // This script defines the didobject variable as global (window.didobject)
            var disneyIdLibraryScript = document.createElement('script');
            disneyIdLibraryScript.setAttribute('src', options.disneyIdLibrary);
            document.getElementsByTagName('head').item(0).appendChild(disneyIdLibraryScript);

            // This script defines the DisneyID variable as global (window.DisneyID)
            var disneyIdScript = document.createElement('script');
            disneyIdScript.setAttribute('id', 'disneyid-script');
            disneyIdScript.setAttribute('src', options.goregDomain + '/v2/outer/DisneyID.js');
            document.getElementsByTagName('head').item(0).appendChild(disneyIdScript);
        },

        initDisneyId: function (options) {
            if (window.location.href.indexOf('disneyaulani.com/jp') >= 0) {
                return;
            }

            var responder = options.disneyIdResponder;
            if (options.disneyIdDomain) {
                var domain = options.disneyIdDomain;
                // Local environments should use directly disneyIdDomain by default
                if (/local/.test(window.location.href)) {
                    domain = defaults.disneyIdDomain;
                }
                responder = domain + (options.disneyIdResponder || responder);
            }

            var disneyId = window.DisneyID.get({
                clientId: options.disneyIdAppId || defaults.disneyIdAppId,
                responderPage: responder,
                debug: true,
                blueCookie: true,
                cssOverride: options.disneyIdCss
            });

            var $self = $(this);
            $self[PLUGIN_NAME]('disneyIdEvents', disneyId);
            $self[PLUGIN_NAME]('disneyIdEventsResponsive', disneyId);
        },

        disneyIdEvents: function (disneyId) {
            var disneyIdObject = window.didobject;
            disneyId.on('login', disneyIdObject.onDIDLogin);
            disneyId.on('login', function (guest) {
                disneyIdObject.updateGuest(guest);
            });
            disneyId.on('refresh', function (guest) {
                disneyIdObject.updateGuest(guest);
            });
            disneyId.on('reauth', function (guest) {
                disneyIdObject.updateGuest(guest);
            });
            disneyId.on('close', disneyIdObject.onDIDClose);
            disneyId.on('logout', disneyIdObject.onDIDLogout);
            disneyId.on('update', disneyIdObject.onDIDUpdate);
            disneyId.on('create', function () {
                setTimeout(function () {
                    disneyId.getGuest(true).then(function (guest) {
                        window.didobject.onDIDCreate(guest);
                    });
                }, 1000);
            });
            disneyId.init().then(function (data) {
                disneyIdObject.onInit(disneyId);
                disneyIdObject.checkTriggers(disneyId);
                var name = data.loggedIn ? data.guest.profile.firstName : '';
                if (typeof WDPRO !== 'undefined') {
                    disneyIdObject.fireProp29(data.loggedIn);
                }
                disneyIdObject.updateGuest(data.guest || {});
                disneyIdObject.updateLogin(name);
            }).fail(function (data) {
                throw ('did error:' + data);
            });
        },

        /**
         * This method is only used to responsive view.
         */
        disneyIdEventsResponsive: function (disneyId) {
            $('.gnbSignIn .disidResponsive').click(function () {
                defaults.disneyIdModalOpen = true;
                $('.pepSyndicatedComponent, body').removeClass('mobile-nav-open'); // Close Mobile Navigation Bar
            });
            disneyId.on('close', function () {
                if (defaults.disneyIdModalOpen) {
                    defaults.disneyIdModalOpen = false;
                    $('.pepSyndicatedComponent, body').addClass('mobile-nav-open'); // Open Mobile Navigation Bar
                }
            });
        }
    });

})(jQuery);
$(document).ready(function() {
    window.PEP.DCL_SYNDICATED_HEADER = {
        CART: {
            vars: {
                cartIdMappingCookie: null,
                cartIdMapping: null,
                containerEl: null,
                constants: {
                    bugTitle: 'Your Cart',
                    price: 'Cruise Price',
                    viewCartDetails: 'View Cart Details',
                    cartPage: '/cart/',
                    checkOutButton: 'Next',
                    localeCurrency: 'USD',
                    stateroom: 'Stateroom',
                    number: 'Number',
                    emptyPrice: '$0.00',
                    emptyCartCopy: 'Your cart is empty.',
                    cruiseListing: '/cruises-destinations/list/',
                    savedCruises: '/login/?returnUrl=%2Fcruises-destinations%2Flist%2Fsaved%2F&cancelUrl=%2F',
                    nextButtonUrl: '/cart/',
                    findACruise: 'Find a Cruise',
                    mySavedCruises: 'My Saved Cruises',
                    dclSavedCruisesToggle: false,
                }
            },
            init: function() {
                var webapiSubdirectory = PEP.Config.Toggles.Release.dclAwsMigrationSwitch ?
                    '/dcl-apps-sales-webapi' :
                    '/wam';

                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.ajaxURLs = {
                    cartData: webapiSubdirectory + '/cruise-booking-service/carts/[CART_ID_MAPPING]/?view=cart'
                };

                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMappingCookie = window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('cartIdMapping');
    
                if (!document.querySelector('.gnbCategory.gnbCart .gnbSubmenu .gnbSubmenusWrapper')) {
                    document.querySelector('.gnbCategory.gnbCart').insertAdjacentHTML('beforeend', '<div class="gnbSubmenu"><div class="gnbSubmenusWrapper"></div></div>');
                }
    
                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.containerEl = document.querySelector('.gnbCategory.gnbCart .gnbSubmenu .gnbSubmenusWrapper');
                window.PEP.DCL_SYNDICATED_HEADER.CART.generateShadowBlocker();
    
                window.PEP.DCL_SYNDICATED_HEADER.CART.initStyles();
    
                if (window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMappingCookie) {
                    console.log('CART MAPPING COOKIE FOUND!');
    
                    try {
                        window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMapping = JSON.parse(decodeURIComponent(window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMappingCookie))['new'];
    
                        if (window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMapping) {
                            console.log('CART DATA JSON PARSE SUCCESS!');
                            window.PEP.DCL_SYNDICATED_HEADER.CART.vars.ajaxURLs.cartData = window.PEP.DCL_SYNDICATED_HEADER.CART.vars.ajaxURLs.cartData.replace(
                                '[CART_ID_MAPPING]',
                                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.cartIdMapping
                            );
                            window.PEP.DCL_SYNDICATED_HEADER.CART.loadCartData();
                        } else {
                            window.PEP.DCL_SYNDICATED_HEADER.CART.generateCartDefaultHTML();
                        }
                    } catch(error) {
                        console.log('CART DATA JSON PARSE ERROR!', error);
                        window.PEP.DCL_SYNDICATED_HEADER.CART.generateCartDefaultHTML();
                    }
                } else {
                    console.log('CART MAPPING COOKIE NOT FOUND!');
                    window.PEP.DCL_SYNDICATED_HEADER.CART.generateCartDefaultHTML();
                }
            },
            initStyles: function() {
                document.body.insertAdjacentHTML('beforeend', "<style>@media (min-width: 975px) {.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover {border-radius: 10px 10px 0 0;box-shadow: 0 -1px 4px -1px rgba(100,100,100,0.5),0 0 4px 1px rgba(100,100,100,0.5);z-index: 2000;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .shadowBlocker {background-color: #fff;opacity: 0;visibility: hidden;height: 10px;position: absolute;top: 28px;width: 100%;z-index: 2001;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbCategoryTitle {color: #1994D7;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu {display: block;left: auto;margin-left: 0;opacity: 1;right: 0;visibility: visible;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper {background-color: #fff;padding: 18px 0;width: 280px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-title {font-size: 1.2rem;padding: 0 20px;white-space: normal;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-title h2 {display: none;font-size: 14px;margin: 0;padding: 0;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-separator {border: none;border-bottom: 1px solid #d0d7de;margin: 10px 0}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body {line-height: 1.5;margin-top: 20px;padding: 0 20px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .text-center {text-align: center;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .cart-empty {font-size: 12px;margin-bottom: 10px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .cruise-name {font-size: 12px;font-weight: 700;margin-bottom: 10px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .departure-date {margin-bottom: 20px}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .stateroom-item .title {font-size: 12px;font-weight: 700;padding-bottom: 3px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .stateroom-item .description {font-size: 12px;margin: 0 0 10px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-cruise,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-resort,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-saved-cruises,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-tickets {display: inline-block;background-color: #fff;color: #253b56;padding: 10px 20px 0;margin-bottom: 30px;margin-top: 15px;text-decoration: none;border-radius: 10px;box-shadow: 0 2px 5px #a1afc0;background-image: linear-gradient(to bottom,#fff 23%,rgba(236,241,244,.6) 80%);background-repeat: repeat-x;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-cruise:hover,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-resort:hover,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-saved-cruises:hover,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-tickets:hover {color: #1994d7;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-cruise .icon span,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-resort .icon span,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-saved-cruises .icon span,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body .find-tickets .icon span {line-height: 50px;font-size: 40px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-cruise,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-saved-cruises {font-size: 12px;padding: 10px 0 0;width: 110px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-saved-cruises {margin-left: 15px}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-cruise .find-a-cruise-icon::before,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-saved-cruises .my-saved-cruises-icon::before {font-family: 'pepmdx';font-size: 40px;line-height: 50px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-cruise .find-a-cruise-icon::before {content: '\\e081';}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-saved-cruises .my-saved-cruises-icon::before {content: '\\e108';}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-cruise .title,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-body a.find-saved-cruises .title {margin: 0 0 10px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary {margin-top: 20px;padding: 0 20px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .price-summary::after {content: '';clear: both;display: block;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .price-summary .title {font-size: 12px;font-weight: 700;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .price-summary .price-currency-block {float: right;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .price-summary .price-currency-block .price {display: inline-block;font-size: 24px;font-weight: 300;line-height: 32px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .price-summary .price-currency-block .currency {display: inline-block;font-size: 10px;font-weight: 400;padding-left: 3px;line-height: 22px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .cta-links {padding-top: 10px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .cta-links .cruise-details-link {padding-top: 5px;font-size: 12px;font-weight: 400;float: left;color: #169ebe;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .cta-links .cruise-details-link:hover {text-decoration: underline;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .cta-links .check-out-button a {background-color: #169ebe;color: #fff;display: inline-block;border: none;border-radius: 3px;font-size: 16px;font-weight: 400;float: right;line-height: 24px;text-align: center;transition: background-color .17s;padding: 8px 10px;max-width: 250px;min-width: 110px;white-space: nowrap;vertical-align: middle;text-decoration: none;text-shadow: none;box-shadow: none;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .cta-links .check-out-button a:hover {background-color: #117e98;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-summary .left-link {padding-right: 20px;display: inline-block}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .saved-cart {font-size: 14px}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle {color: #253b56;cursor: pointer;line-height: 34px;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .cart-icon {display: inline-block;font-family: 'wdwicons';font-size: 26px;position: relative;text-rendering: geometricPrecision;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .cart-icon::before {content: '\\e0c0';}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .titleHolder {display: inline-block;font-weight: 700;line-height: 21px;max-width: 180px;padding: 14px 0;vertical-align: middle;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle {font-weight: 400;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .titleIcon,.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .titleOpenCloseArrow {display: none;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .titleIcon {display: inline-block;font-size: 18px;margin-top: -4px;position: relative;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart .gnbCategoryTitle .titleHolder {font-weight: 400;line-height: normal;max-width: none;padding: 0;vertical-align: baseline;width: auto;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .shadowBlocker {opacity: 1;visibility: visible;}.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu .gnbSubmenusWrapper .cart-bug-title h2 {display: block;font-weight: 700;line-height: 16px;}}@media (min-width: 1246px) {.pepSyndicatedComponent .dcl .gnbCategory.gnbCart:hover .gnbSubmenu {left: 0;right: auto;}}</style>");
            },
            loadCartData: function() {
                fetch(window.PEP.DCL_SYNDICATED_HEADER.CART.vars.ajaxURLs.cartData, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'text/plain',
                        'Authorization': 'BEARER ' + window.PEP.DCL_SYNDICATED_HEADER.vars.authToken
                    }
                })
                .then(function(resp) {
                    return resp.json();
                })
                .then(function(data) {
                    console.log('CART DATA AJAX SUCCESS!', data);

                    if (window.PEP.DCL_SYNDICATED_HEADER.CART.vars.containerEl) {
                        window.PEP.DCL_SYNDICATED_HEADER.CART.generateCartHTML(data);
                        window.PEP.DCL_SYNDICATED_HEADER.CART.updateCartStatusIcon(data);
                    }
                })
                .catch(function(error) {
                    console.log('CART DATA AJAX ERROR!', error);
                    window.PEP.DCL_SYNDICATED_HEADER.CART.generateCartDefaultHTML();
                });
            },
            generateShadowBlocker: function() {
                if (!document.querySelector('.gnbCart .shadowBlocker') &&
                    document.querySelector('.gnbCart .gnbCategoryTitle')) {
                    document.querySelector('.gnbCart .gnbCategoryTitle').insertAdjacentHTML('afterend', '<div class="shadowBlocker"></div>');
                }
            },
            updateCartStatusIcon: function(cartData) {
                if (cartData.totalNumberOfItems > 0 && document.querySelector('.icon__cart-empty')) {
                    document.querySelector('.icon__cart-empty').classList.add('icon__cart-full');
                    document.querySelector('.icon__cart-empty').classList.remove('icon__cart-empty');
                }
            },
            generateCartHTML: function(cartData) {
                var cartHTML = '' +
                    '<div class="cart-bug-title gutter-sm-large">' +
                        '<h2>' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.bugTitle + '</h2>' +
                    '</div>' +
                    '<hr class="cart-bug-separator">' +
                    '<div class="cart-bug-body gutter-sm-large">';
                if (cartData.totalNumberOfItems > 0) {
                    cartHTML += '' +
                        '<div>' +
                            '<p class="cruise-name">' + cartData.voyage.productName + '</p>' +
                            '<ul class="list-items">';
                    for (var i = 0; i < cartData.entries.length; i++) {
                        var stateroomItem = cartData.entries[i];
                        cartHTML += '' +
                                '<li class="stateroom-item" id="' + (i + 1) + '">' +
                                    '<div class="title">' +
                                        '<span>' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.stateroom + '</span> ' + (i + 1) + ' &ndash; ';
                        if (stateroomItem.stateroom.stateroomId !== 'GTY') {
                            cartHTML += '' +
                                        '<span>' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.number + '&nbsp</span>';
                        }
                        if (!stateroomItem.errors) {
                            cartHTML += '' +
                                        '<span>' + stateroomItem.stateroom.stateroomId + '</span>';
                        }
                        if (stateroomItem.errors) {
                            cartHTML += '' +
                                        '<span>' + stateroomItem.errors[0].errorDescription + '</span>';
                        }
                        cartHTML += '' +
                                    '</div>';
                        if (stateroomItem.errors) {
                            cartHTML += '' +
                                    '<div class="not-available">' + stateroomItem.errors[0].errorDescription + '</div>';
                        }
                        cartHTML += '' +
                                    '<p class="description">' + stateroomItem.stateroom.stateroomSubTypeDesc + '</p>' +
                                '</li>';
                    }
                    cartHTML += '' +
                            '</ul>' +
                        '</div>';
                } else {
                    cartHTML += '' +
                        '<div class="text-center">' +
                            '<p class="cart-empty">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.emptyCartCopy + '</p>' +
                            '<a target="_self" class="find-cruise" href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.cruiseListing + '" aria-label="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.findACruise + '">' +
                                '<span class="icon find-a-cruise-icon" icon="&#57473;"></span>' +
                                '<p class="title">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.findACruise + '</p>' +
                            '</a>' +
                        (window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.dclSavedCruisesToggle ? '' +
                            '<a target="_self" class="find-saved-cruises" href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.savedCruises + '" aria-label="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.mySavedCruises + '">' +
                                '<span class="icon my-saved-cruises-icon" icon="&#57608;"></span>' +
                                '<p class="title">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.mySavedCruises + '</p>' +
                            '</a>' : ''
                        ) +
                        '</div>';
                }
                cartHTML += '' +
                    '</div>';
                    cartHTML += '' +
                    '<hr class="cart-bug-separator">' +
                    '<div class="cart-bug-summary gutter-sm-large">';
                if (cartData.totalNumberOfItems > 0) {
                    if (!cartData.sailingsNotAvailable) {
                        cartHTML += '' +
                        '<div class="price-summary clearfix">' +
                            '<span class="title pull-left">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.price + '</span>' +
                            '<span class="price-currency-block">' +
                                '<span class="price">' + window.PEP.DCL_SYNDICATED_HEADER.utils.moneyFormat(cartData.pricing.total) + '</span>' +
                                '<span class="currency">' + cartData.pricing.currency + '</span>' +
                            '</span>' +
                            '<span class="price"></span>' +
                        '</div>';
                    }
                    cartHTML += '' +
                        '<div class="cta-links clearfix">' +
                            '<a target="_self" class="cruise-details-link pull-left" ' +
                                'wdpr-analytics-track-link="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.viewCartDetails + '" ' +
                                'href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.cartPage + '">' +
                                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.viewCartDetails +
                            '</a>';
                    if (!cartData.sailingsNotAvailable) {
                        cartHTML += '' +
                            '<div class="check-out-button">' +
                                '<a target="_self" href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.nextButtonUrl + '">' +
                                    '<span>' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.checkOutButton + '</span>' +
                                '</a>' +
                            '</div>';
                    }
                    cartHTML += '' +
                        '</div>';
                } else {
                    cartHTML += '' +
                        '<div class="price-summary empty">' +
                            '<span class="title pull-left">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.price + '</span>' +
                            '<span class="price-currency-block">' +
                                '<span class="price">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.emptyPrice + '</span>' +
                                '<span class="currency">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.localeCurrency + '</span>' +
                            '</span>' +
                        '</div>';
                }
                cartHTML += '' +
                    '</div>';
                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.containerEl.innerHTML = cartHTML;
            },
            generateCartDefaultHTML: function() {
                console.log('Loading default cart data.');
                var cartHTML = '' +
                    '<div class="cart-bug-title gutter-sm-large">' +
                        '<h2>' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.bugTitle + '</h2>' +
                    '</div>' +
                    '<hr class="cart-bug-separator">' +
                    '<div class="cart-bug-body gutter-sm-large">' +
                        '<div class="text-center">' +
                            '<p class="cart-empty">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.emptyCartCopy + '</p>' +
                            '<a target="_self" class="find-cruise" href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.cruiseListing + '" aria-label="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.findACruise + '">' +
                                '<span class="icon find-a-cruise-icon" icon="&#57473;"></span>' +
                                '<p class="title">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.findACruise + '</p>' +
                            '</a>' +
                        (window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.dclSavedCruisesToggle ? '' +
                            '<a target="_self" class="find-saved-cruises" href="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.savedCruises + '" aria-label="' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.mySavedCruises + '">' +
                                '<span class="icon my-saved-cruises-icon" icon="&#57608;"></span>' +
                                '<p class="title">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.mySavedCruises + '</p>' +
                            '</a>' : ''
                        ) +
                        '</div>' +
                    '</div>' +
                    '<hr class="cart-bug-separator">' +
                    '<div class="cart-bug-summary gutter-sm-large">' +
                        '<div class="price-summary empty">' +
                            '<span class="title pull-left">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.price + '</span>' +
                            '<span class="price-currency-block">' +
                                '<span class="price">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.emptyPrice + '</span>' +
                                '<span class="currency">' + window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.localeCurrency + '</span>' +
                            '</span>' +
                        '</div>' +
                    '</div>';
                window.PEP.DCL_SYNDICATED_HEADER.CART.vars.containerEl.innerHTML = cartHTML;
            }
        },
        EARLY_BOOKING: {
            vars: {
                ajaxURLs: {
                    guestAffiliations: '/profile-service/v4/guests/[SWID]/affiliations?site=DCL',
                    earlyBookingMessages: '/resource-bundle/castaway-club-affiliations/'
                },
                containerEl: null,
                dismissButtonEl: null,
                earlyBookingLevel: -1,
                earlyBookingLevelName: '',
                earlyBookingLevels: [
                    'SILVER',
                    'GOLD',
                    'PLATINUM',
                    'TAEarlyBookingBanner'
                ],
                swidCookie: null
            },
            fetchEarlyBookingMessages: function() {
                fetch(window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.ajaxURLs.earlyBookingMessages)
                    .then(function(resp) {
                        return resp.json();
                    })
                    .then(function(data) {
                        if (data && data.earlyBookingAffiliations) {
                            console.log('EARLY BOOKING MESSAGES AJAX SUCCESS!', data);

                            window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.showEarlyBookingMessage(data);
                        } else {
                            console.log('EARLY BOOKING MESSAGES AJAX ERROR!');
                        }
                    })
                    .catch(function(error) {
                        console.log('EARLY BOOKING MESSAGES AJAX ERROR!', error);
                    });
            },
            showEarlyBookingMessage: function(data) {
                var entry = data.earlyBookingAffiliations[window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevelName];

                if (entry && entry.enabled && new Date(data.serverTime) > new Date(entry.bookingDateTime)) {
                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.generateEarlyBookingMessageHTML(entry.bannerMessage);
                }
            },
            generateEarlyBookingMessageHTML: function(message) {
                console.log('GENERATING EARLY BOOKING MESSAGE HTML!');

                var messageHTML = '';
                if (window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('rememberme')) {
                    try {
                        var rememberMeCookie = JSON.parse(decodeURIComponent(window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('rememberme')));
                        if (rememberMeCookie) {
                            console.log('CART DATA JSON PARSE SUCCESS!');
                            var firstName = rememberMeCookie.name.replace(/\+/g, ' ');
                            message = message.replace(/\${firstName}/gi, firstName);
                        }
                    } catch(error) {
                        console.log('CART DATA JSON PARSE ERROR!', error);
                    }
                }

                message = message.replace(/\[\[/gi, '<');
                message = message.replace(/\]\]/gi, '>');

                messageHTML = '<section id="early-booking-message"><p>' + message +
                        '<a id="early-booking-message-dismiss" href="#">Close Message</a></p></section>';

                if (document.getElementById('headerWrapper')) {
                    document.getElementById('headerWrapper').insertAdjacentHTML('beforeend', messageHTML);
                } else if (document.getElementById('dcl-header')) {
                    document.getElementById('dcl-header').insertAdjacentHTML('beforeend', messageHTML);
                }

                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.containerEl = document.getElementById('early-booking-message');
                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.dismissButtonEl = document.getElementById('early-booking-message-dismiss');
                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.initStyles();
                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.initJS();
            },
            initStyles: function() {
                document.body.insertAdjacentHTML('beforeend', "<style>#early-booking-message {background: #2D3B52;clear: both;padding: 0 20px;}#early-booking-message p {color: #FFF;font-size: 12px;line-height: 18px;margin: 0 auto;padding: 12px 40px 12px 0;position: relative;}#early-booking-message p a {color: #FFF;text-decoration: underline;}#early-booking-message p a:hover {opacity: 0.8;}#early-booking-message-dismiss {font-size: 0;text-decoration: none;float:right;}#early-booking-message-dismiss::before {color: #FFF;content: '\\e300';display: flex;flex-direction: column;font-family: pepmdx;font-size: 25px;height: 100%;justify-content: center;right: -10px;position: absolute;top: 0;}@media (min-width: 975px) {#early-booking-message {padding: 0 20px;}#early-booking-message p {padding: 12px 15px;width: 930px;}#early-booking-message-dismiss::before {right: 10px;}}</style>");
            },
            initJS: function() {
                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.dismissButtonEl.addEventListener('click', function(e) {
                    e.preventDefault();
                    window.PEP.DCL_SYNDICATED_HEADER.vars.containerEl.removeChild(window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.containerEl);
                    window.PEP.DCL_SYNDICATED_HEADER.utils.setSessionCookie('earlyBookingMessageClosed', 'true');
                });
            },
            init: function() {
                const swidRegex = /^\{[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}\}$/;
                const swid = window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('SWID');
                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.swidCookie = null;
                if (swid.match(swidRegex)) {
                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.swidCookie = encodeURIComponent(swid);
                }
                
                if (window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('TICKET_DATA_jar')) {
                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevelName = 'TAEarlyBookingBanner';
                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.fetchEarlyBookingMessages();
                    return;
                }

                if (window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.swidCookie) {
                    console.log('SWID COOKIE FOUND!');

                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.ajaxURLs.guestAffiliations =
                        window.PEP.DCL_SYNDICATED_HEADER.utils.getAPIBaseURL() +
                        window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.ajaxURLs.guestAffiliations.replace(
                            '[SWID]',
                            window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.swidCookie
                        );

                    fetch(window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.ajaxURLs.guestAffiliations, {
                        method: 'GET',  
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'BEARER ' + window.PEP.DCL_SYNDICATED_HEADER.vars.authToken
                        }
                    })
                    .then(function(resp) {
                        return resp.json();
                    })
                    .then(function(data) {
                        if (data && data.entries && data.entries.length) {
                            console.log('GUEST AFFILIATIONS AJAX SUCCESS!', data);

                            for (var i in data.entries) {
                                var affiliation = data.entries[i];

                                if (affiliation.affiliationType === 'CASTAWAYCLUB') {
                                    var earlyBookingLevelIndex = window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevels.indexOf(affiliation.level);

                                    if (earlyBookingLevelIndex > window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevel) {
                                        window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevel = earlyBookingLevelIndex;
                                    }
                                }
                            }

                            if (window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevel > -1) {
                                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevelName =
                                    window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevels[
                                        window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevel
                                    ];
                                console.log('GUEST AFFILIATION FOR EARLY BOOKING FOUND!', window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.vars.earlyBookingLevelName);

                                window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.fetchEarlyBookingMessages();
                            } else {
                                console.log('GUEST AFFILIATION FOR EARLY BOOKING NOT FOUND!');
                            }
                        } else {
                            console.log('GUEST AFFILIATIONS AJAX ERROR!');
                        }
                    })
                    .catch(function(error) {
                        console.log('GUEST AFFILIATIONS AJAX ERROR!', error);
                    });
                } else {
                    console.log('SWID COOKIE NOT FOUND!');
                }
            }
        },
        vars: {
            ajaxURLs: {
                authToken: PEP.Config.Toggles.Release.enableNewProfileURL ?
                    '/profile-api/authentication/get-client-token/' :
                    '/authentication/get-client-token/' 
            },
            authToken: null,
            containerEl: null
        },
        utils: {
            getEnvironment: function() {
                var url = window.location.href
                    env = '';

                if (url.indexOf('latest') >= 0) {
                    env = 'latest';
                } else if (url.indexOf('stage') >= 0) {
                    env = 'stage';
                } else if (url.indexOf('lt01') >= 0) {
                    env = 'load';
                } else {
                    env = 'prod';
                }

                return env;
            },
            getAPIBaseURL: function() {
                var env = window.PEP.DCL_SYNDICATED_HEADER.utils.getEnvironment();
                env = env === 'prod' ? '' : env + '.';

                return window.location.protocol + '//' + env + 'profile-svc.wdprapps.disney.com'; 
            },
            getCookie: function(name) {
                var value = '; ' + document.cookie;
                var parts = value.split('; ' + name + '=');
                return parts.length <= 3 ?
                    parts.pop().split(';').shift() :
                    null;
            },
            setSessionCookie: function(name, value) {
                document.cookie = name + '=' + value + ';path=/;';
            },
            moneyFormat: function(amount) {
                var formatter = new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: window.PEP.DCL_SYNDICATED_HEADER.CART.vars.constants.localeCurrency
                });

                return formatter.format(amount);
            }
        },
        fetchAuthToken: function() {
            fetch(window.PEP.DCL_SYNDICATED_HEADER.vars.ajaxURLs.authToken)
            .then(function(resp) {
                return resp.json();
            })
            .then(function(data) {
                console.log('TOKEN AJAX SUCCESS!', data);
                window.PEP.DCL_SYNDICATED_HEADER.vars.authToken = data.access_token;

                if (window.PEP.DCL_SYNDICATED_HEADER.vars.authToken) {
                    // INITIALIZE CART
                    if (document.querySelector('.gnbCategory.gnbCart')) {
                        window.PEP.DCL_SYNDICATED_HEADER.CART.init();
                    }
                    // INITIALIZE EARLY BOOKING
                    if (window.PEP.DCL_SYNDICATED_HEADER.utils.getCookie('earlyBookingMessageClosed') !== 'true') {
                        window.PEP.DCL_SYNDICATED_HEADER.EARLY_BOOKING.init();
                    }
                } else {
                    console.log('TOKEN AJAX ERROR!');
                }
            })
            .catch(function(error) {
                console.log('TOKEN AJAX ERROR!', error);
            });
        },
        init: function() {
            if (document.querySelector('.pepGlobalHeader.dcl')) {
                // FETCH AUTH TOKEN
                window.PEP.DCL_SYNDICATED_HEADER.vars.containerEl = document.getElementById('headerWrapper')
                window.PEP.DCL_SYNDICATED_HEADER.fetchAuthToken();
            }
        }
    };

    window.PEP.DCL_SYNDICATED_HEADER.init();
});
